{"version":3,"file":"index.js","mappings":"AAAA,MAAM,EAA+BA,ECWZC,YAAYC,MAwG9B,MAAMC,EAAiB,EAAAH,EAC3BI,OAAO,CACN,GAAI,EAAAJ,EAAEK,SAASC,WACf,GAAI,EAAAN,EAAEK,SAASC,WACf,GAAI,EAAAN,EAAEK,SAASE,IAAI,CAAEC,QAAS,cAAeF,WAC7CC,IAAK,EAAAP,EAAEK,SAASE,IAAI,CAAEC,QAAS,gBAEhCC,SAGUC,EAAqB,EAAAV,EAC/BI,OAAO,CACNO,cAAe,EAAAX,EAAEK,SACjBO,aAAc,EAAAZ,EAAEa,SAASP,WACzBQ,yBAA0B,EAAAd,EAAEa,SAASP,WACrCS,UAAW,EAAAf,EAAEa,SAASP,WACtBU,sBAAuB,EAAAhB,EAAEa,SAASP,WAClCW,MAAO,EAAAjB,EAAEkB,MAAM,CAAC,EAAAlB,EAAEK,SAAU,EAAAL,EAAEa,SAAU,EAAAb,EAAEmB,YAAYb,WACtDc,eAAgB,EAAApB,EAAEK,SAASC,WAC3Be,cAAe,EAAArB,EACZK,SACAiB,MAAM,4BAA6B,CAClCd,QAAS,4BAEVF,aAEJG,SAGUc,EAAmB,EAAAvB,EAC7BI,OAAO,CACNoB,KAAM,EAAAxB,EAAEyB,QAAQ,gBAChBC,YAAa,EAAA1B,EAAEK,SACfsB,SAAU,EAAA3B,EAAEa,SAASe,QAAQ,GAC7BC,WAAY,EAAA7B,EAAE8B,MAAMpB,GAAoBqB,SAAS,CAAEvB,QAAS,oBAE7DC,SAGUuB,EAAoB,EAAAhC,EAAEI,OAAO,CACxC6B,GAAI,EAAAjC,EAAEK,SACN6B,aAAc,EAAAlC,EAAEmC,KAAK,CAAC,OAAQ,OAAQ,CAAE3B,QAAS,wCAAqCoB,QAAQ,QAC9FQ,OAAQ,EAAApC,EAAE8B,MAAM3B,GAAgB4B,SAAS,CAAEvB,QAAS,4BAIzC6B,EAAqB,EAAArC,EAC/BI,OAAO,CACNkC,oBAAqB,EAAAtC,EAAEK,SAASC,WAChCiC,UAAW,EAAAvC,EAAE8B,MAAME,GAAmB1B,WACtCkC,SAAU,EAAAxC,EAAE8B,MAAMP,GAAkBjB,aAErCG,SAGUgC,EAAoB,EAAAzC,EAAEI,OAAO,CACxCsC,WAAY,EAAA1C,EAAEK,SACdsC,aAAc,EAAA3C,EAAEa,SAASe,QAAQ,GACjCgB,cAAe,EAAA5C,EAAE8B,MAAM,EAAA9B,EAAEa,UAAUe,QAAQ,IAC3CiB,cAAe,EAAA7C,EAAEmB,UAAUS,SAAQ,GACnCkB,cAAevB,EAAiBjB,aAIrByC,EAAoB,EAAA/C,EAAEI,OAAO,CACxC4C,aAAc,EAAAhD,EAAE8B,MAAMW,GACtBQ,KAAM,EAAAjD,EAAEmC,KAAK,CAAC,OAAQ,SAAU,WAAWP,QAAQ,QACnDsB,OAAQ,EAAAlD,EAAEa,SAASsC,IAAI,GAAGC,IAAI,GAAGxB,QAAQ,IACzCyB,qBAAsB,EAAArD,EAAEa,SAASyC,WAAW1B,QAAQ,MACpD2B,wBAAyB,EAAAvD,EAAE8B,MAAM,EAAA9B,EAAEK,UAAUuB,QAAQ,IACrD4B,iBAAkB,EAAAxD,EAAEyD,OAAO,EAAAzD,EAAEK,SAAU,EAAAL,EAAE0D,OAAOpD,aAG5CqD,EAAwB,eAQ9B,SAASC,EAAoBC,GAE3B,IAAKA,GAA8B,iBAAZA,EAAsB,OAAO,KAGpD,MAAMC,EAAmBD,EAAQE,OAAOC,QAAQ,IAAK,KAErD,IAAIC,EAIJ,GADAA,EAAQH,EAASG,MAAM,+BACnBA,EAAO,CACT,MAAMC,EAAQC,SAASF,EAAM,GAAI,IAC3BG,EAAUD,SAASF,EAAM,GAAI,IAEnC,GAAIC,GAAS,GAAKA,EAAQ,IAAME,GAAW,GAAKA,EAAU,GACxD,OAAe,GAARF,EAAaE,CAExB,CAIA,GADAH,EAAQH,EAASG,MAAM,oCACnBA,EAAO,CACT,MAAMC,EAAQC,SAASF,EAAM,GAAI,IAC3BG,EAAUD,SAASF,EAAM,GAAI,IACnC,GAAIC,GAAS,GAAKA,EAAQ,IAAME,GAAW,GAAKA,EAAU,GACxD,OAAe,GAARF,EAAaE,CAExB,CAMA,OAAO,IACT,CAKA,MAAMC,EAAa,MAGjB,IAAIC,EAAyC,CAAC,EAM9C,SAASC,EACPC,EACAC,GAEA,IAAKA,EAAU,OAAO,EAGtB,IAAK,MAAMC,KAAaF,EAAQ3C,WAAY,CAC1C,MAAM8C,EAAeC,EAAEC,IAAIJ,EAAUC,EAAU/D,eAE/C,IAAImE,GAAe,EACfC,GAAY,EAGhB,QAAiCC,IAA7BN,EAAUtD,eACZ2D,GAAY,EAEgB,iBAAjBJ,GAA6BA,EAAaM,SAASP,EAAUtD,kBACtE0D,GAAe,QAEZ,QAAgCE,IAA5BN,EAAUrD,eAGnB,GAFA0D,GAAY,EAEgB,iBAAjBJ,EAA2B,CACpC,MAAMO,EAAuBtB,EAAoBe,GAEjD,GAA6B,OAAzBO,EAA+B,CACjC,MAAOC,EAAUC,GAAUV,EAAUrD,cAAcgE,MAAM,KACnDC,EAAe1B,EAAoBuB,GACnCI,EAAa3B,EAAoBwB,GAElB,OAAjBE,GAAwC,OAAfC,IAIzBT,EAFEQ,GAAgBC,EAEHL,GAAwBI,GAAgBJ,GAAwBK,EAGhEL,GAAwBI,GAAgBJ,GAAwBK,EAGrF,CACF,YAC6BP,IAApBN,EAAUzD,OACnB8D,GAAY,EACRJ,IAAiBD,EAAUzD,QAC7B6D,GAAe,SAEmBE,IAA3BN,EAAU9D,cACnBmE,GAAY,EACgB,iBAAjBJ,GAA6BA,EAAeD,EAAU9D,eAC/DkE,GAAe,SAE+BE,IAAvCN,EAAU5D,0BACnBiE,GAAY,EACgB,iBAAjBJ,GAA6BA,GAAgBD,EAAU5D,2BAChEgE,GAAe,SAEgBE,IAAxBN,EAAU3D,WACnBgE,GAAY,EACgB,iBAAjBJ,GAA6BA,EAAeD,EAAU3D,YAC/D+D,GAAe,SAE4BE,IAApCN,EAAU1D,wBACnB+D,GAAY,EACgB,iBAAjBJ,GAA6BA,GAAgBD,EAAU1D,wBAChE8D,GAAe,IAKnB,IAAKC,IAAcD,EACjB,OAAO,CAEX,CAGA,OAAO,CACT,CAgHA,MA7GkB,CAChBU,sBAAuBjB,EAKvB,UAAAkB,GAEE,IACE,MAAMC,EAAaC,aAAa,CAAEnE,KAAM,SAAUmC,GAEhDW,EADEoB,GAAoC,iBAAfA,EACHA,EAGA,CAAC,CAGzB,CAAE,MAAOE,GAEPtB,EAAoB,CAAC,CACvB,CACF,EAEA,UAAAuB,GAEEvB,EAAoB,CAAC,CAEvB,EAMA,yBAAMwB,CAAoBC,GACxB,GAAKC,EAAL,CAKA1B,EAAoBM,EAAEqB,UAAUF,GAChC,UACQG,oBACJC,IACEA,EAAKxC,GAAyBW,EACvB6B,GAET,CAAE3E,KAAM,QAGZ,CAAE,MAAOoE,GAET,CAdA,CAeF,EAKAQ,iBAAkB,IAAMxB,EAAEqB,UAAU3B,GASpC,qBAAA+B,CACEC,EACAP,EACAQ,GAKA,MAAMC,EAGF,CAAEC,oBAAqB,GAAIC,sBAAuB,IAWtD,IAAK,MAAMlC,KAAW+B,EAAa,CACjC,MAAMI,EAASpC,EAAuBC,EAAS8B,GACzCM,EAAQrC,EAAuBC,EAASuB,IAEzCY,GAAUC,GAC0BpC,EAAQ9C,YAC/C8E,EAAOC,oBAAoBI,KAAKrC,IACvBmC,IAAWC,IACmBpC,EAAQ9C,YAC/C8E,EAAOE,sBAAsBG,KAAKrC,GAEtC,CAKA,OAHagC,EAAOC,oBAAoBK,OAAgBN,EAAOE,sBAAsBI,OAG9EN,CACT,EAKH,EAxMkB,GA6MbO,EAAe,MAOnB,IAAIC,EAAoC,GACpCC,EAAoC,KACpCC,EAAsC,IAAIC,IAC1CC,EAA8B,OAC9BC,EAAwB,GACxBC,EAAmD,UACnDC,GAA+B,EAKnC,SAASC,EAAkCC,EAAiBC,GAC5B,iBAAnBA,GAA+BA,EAAiB,GAC3DD,EAAK7E,cAAc+E,IAAID,EACzB,CA4NA,MAvNkB,CAEhBE,gBAAiB,IAAMR,EACvBS,UAAW,IAAMR,EAEjBS,UAAW,IAAyB,YAAnBR,EACjBS,iBAAkB,IAAMT,EACxBU,mBAAoB,IAAMT,EAO1BU,gBAAiB,IAA6BrD,EAAEqB,UAAUe,EAAqB,IAK/EkB,SAAU,IAAmBtD,EAAEqB,UAAUe,GAGzCmB,2BAA4B,IACnBvD,EAAEqB,UAAU,CACjBjD,aAAcgE,EACd/D,KAAMmE,EACNlE,OAAQmE,EAERS,UAA8B,YAAnBR,EACXc,cAAed,EACfU,mBAAoBT,IAIxBc,+BAA8B,KAarB,CACLrF,aAbmB4B,EAAEqB,UAAUe,GAEIsB,IAAIb,IAGhC,IAFe7C,EAAE2D,KAAKd,EAAM,CAAC,eAAgB,YAAa,oBAK/D7E,cAAe4F,MAAMC,KAAKhB,EAAK7E,kBAMjCK,KAAMmE,EACNlE,OAAQmE,EACRhE,qBAAsB4D,EACtB1D,wBAAyBiF,MAAMC,KAAKvB,KAKxC,UAAArB,GAEEmB,EAAuB,GACvBI,EAAgB,OAChBC,EAAgB,GAChBC,EAAiB,UACjBC,GAAsB,EACtBN,EAAqB,KACrBC,EAAuBwB,OACzB,EAEA,SAAAC,CAAUC,GAERxB,EAAgBwB,EAAY3F,KAC5BoE,EAAgBuB,EAAY1F,OAC5B8D,EAAuB4B,EAAY5F,cAAgB,GACnDiE,EAAqB2B,EAAYvF,sBAAwB,KACzD6D,EAAyB,IAAIC,IAAIyB,EAAYrF,yBAA2B,IAEZ2D,EAAuB2B,KAGhE7B,EAAqBF,MAG1C,EAGAgC,gBAAkB7F,IAChBmE,EAAgBnE,GAElB8F,UAAY7F,IACVmE,EAAgBnE,GAElB8F,iBAAmBC,IAKjB3B,EAAiB2B,GAEnBC,oBAAsBC,IACpB5B,EAAsB4B,GAGxBC,qBAAsB,IAAMnC,EAC5BoC,qBAAuBpH,IACrBgF,EAAqBhF,GAGvBqH,yBAA0B,IAAM,IAAInC,IAAID,GAExCqC,2BAA6B7G,IAE3BwE,EAAuBS,IAAIjF,IAG7B8G,2BAA4B,KAE1BtC,EAAuBwB,SAQzB,WAAAe,CAAYC,GACsDA,EAAS5C,OAEzEE,EAAuBpC,EAAEqB,UAAUyD,GAAUC,KAAK,CAACC,EAAGC,IAAMA,EAAElI,SAAWiI,EAAEjI,UAEvEqF,EAAqBF,OAAS,IAEhBE,EAAqB,GAAGtE,WAAqBsE,EAAqB,GAAGrF,SAKzF,EAGA,eAAAmI,CAAgBC,GACd,MAAMC,EAAchD,EAAqB,GACrCgD,IACFxC,EAAkCwC,EAAaA,EAAYrH,cAC3DqH,EAAYrH,aAAeoH,EAE/B,EAEA,oBAAAE,CAAqBC,GACnB,MAAMF,EAAchD,EAAqB,GACzC,GAAKgD,EAAL,CAIA,GAFAxC,EAAkCwC,EAAaA,EAAYrH,cAErC,WAAlByE,GAA8B4C,EAAYG,aAAc,CAC1D,MAAMC,EAAeJ,EAAYG,aAAaE,QAAQH,IAChC,IAAlBE,IACFJ,EAAYM,UAAYF,EAE5B,CACAJ,EAAYrH,aAAeuH,CAVH,CAW1B,EAEA,0BAAAK,GACE,MAAMP,EAAchD,EAAqB,GACrCgD,GAAaA,EAAYpH,cAAc8F,OAC7C,EAEA,uBAAA8B,GACE,MAAMR,EAAchD,EAAqB,GACrCgD,IACFA,EAAYpH,cAAc8F,QAC1BsB,EAAYrH,aAAe,EAE/B,EAEA,kBAAA8H,CAAmBC,EAAyBC,EAA2BP,GACrE,MAAMJ,EAAchD,EAAqB,GACrCgD,IACFA,EAAYrH,aAAe+H,EAC3BV,EAAYG,aAAeQ,EAC3BX,EAAYM,UAAYF,EAE5B,EAEA,iBAAAQ,CAAkBC,GAChB,MAAMb,EAAchD,EAAqB,GACzC,GAAKgD,GAAea,IAAeb,EAAYrH,eAE/C6E,EAAkCwC,EAAaA,EAAYrH,cAC3DqH,EAAYrH,aAAekI,EAEI,WAA3BC,KAAKlD,mBAAkCoC,EAAYG,cAAc,CACnE,MAAMC,EAAeJ,EAAYG,aAAaE,QAAQQ,IAChC,IAAlBT,IAAqBJ,EAAYM,UAAYF,EACnD,CACF,EAEA,mBAAAW,GACE,MAAMf,EAAchD,EAAqB,GACrCgD,IACFA,EAAYG,kBAAenF,EAC3BgF,EAAYM,eAAYtF,EAE5B,EAEA,oBAAAgG,CAAqBC,EAAgBX,GACnC,MAAMN,EAAchD,EAAqB,GACrCgD,IACFA,EAAYG,aAAec,EAC3BjB,EAAYM,UAAYA,EAE5B,EAKH,EAlPoB,GAuPfY,EAAiB,MAErB,IAAIC,EAAoC,KACpCC,EAAoC,KACpCC,EAAyC,KACzCC,EAA0C,KAC1CC,EAA+B,KAQnC,SAASC,EAAiBC,EAAiCC,EAAsBC,GAC/E,OAAO,IAAIC,QAAQC,IAMjB,GALIN,IACFO,cAAcP,GACdA,EAAgB,OAGbE,EAAQ,OAAOI,IAEpB,MAAME,EAAcN,EAAOvI,OAErB8I,EAAQL,EADG,GAEjB,GAAIK,GAAS,EAEX,OADAP,EAAOvI,OAASwI,EACTG,IAET,MAAMI,GAAcP,EAAeK,GAAeC,EAClD,IAAIE,EAAc,EAElBX,EAAgBY,OAAOC,YAAY,KACjCF,IACIA,GAAeF,GACbT,GAAeO,cAAcP,GACjCA,EAAgB,KAChBE,EAAOvI,OAASwI,EAChBG,KAEAJ,EAAOvI,QAAU+I,GAjBJ,KAqBrB,CA0IA,MAvIkB,CAChB,UAAAxG,GACE,GAAI0F,GAAYC,EAAU,OAE1B,MAAMiB,EAAe,KACnB,MAAMC,EAAQ,IAAIC,MAUlB,OATAD,EAAME,QAAU,OAChBF,EAAMG,YAAc,YACpBH,EAAMI,iBAAiB,QAAS,KAC1BJ,IAAUjB,GAwlDxBsB,iBAEE,GAAI5F,EAAaiB,qBAGf,OAGF,MAAMgC,EAAcjD,EAAakB,kBACjC,IAAK+B,EAGH,OAGF,IACEjD,EAAamC,qBAAoB,GACjC0D,IAEA,MAAMC,EAAWC,EAAgBC,qBAAqBC,WAAWhD,GAC3DiD,QAAkBC,EAAyBL,GAE7CI,EAAUE,kBAAqD,iBAA1BF,EAAUG,mBAC3CC,EAAmBJ,EAAUG,YAEvC,CAAE,MAAOxH,SAGD0H,GACR,C,cACQC,UACAC,EAAW,aAEnB,CACF,CA1nD4CC,KAEpCnB,EAAMI,iBAAiB,QAAS,QAGhCJ,EAAMI,iBAAiB,aAAcgB,GAC9BpB,GAETnB,EAAWkB,IACXjB,EAAWiB,IACXhB,EAAgBF,EAChBG,EAAiBF,CAEnB,EAEAuC,gBAAiB,IAAMtC,EACvBuC,iBAAkB,IAAMtC,EAExB,uBAAMuC,CAAkBC,EAAwBpC,GAG9C,GAFiCoC,EAAeC,MAAM,EAAG,KAEpDzC,IAAmBD,EAGtB,MAAM,IAAI2C,MAAM,cAGlB,MAAMC,EAAgB3C,EAChB4C,EAAe7C,EAErB4C,EAAcE,IAAML,EACpBG,EAAcG,OAEd,UACQ,IAAIxC,QAAc,CAACC,EAASwC,KAChC,MAAMC,EAAY,KAChBL,EAAcM,oBAAoB,iBAAkBD,GACpDL,EAAcM,oBAAoB,QAASC,GAE3C3C,KAGI2C,EAAWC,IACfR,EAAcM,oBAAoB,iBAAkBD,GACpDL,EAAcM,oBAAoB,QAASC,GAE3C,MACM5I,EADS6I,EAAEC,OACI9I,MACrByI,EAAO,IAAIL,MAAM,WAAWpI,GAAOpF,SAAW,YAEhDyN,EAAcvB,iBAAiB,iBAAkB4B,GACjDL,EAAcvB,iBAAiB,QAAS8B,IAE5C,CAAE,MAAO5I,GAEP,MAAMA,CACR,OAEM4F,EAAiB0C,EAAc,EAAG,KACxCA,EAAaS,SAzGdtD,EAAeC,GAAkB,CAACA,EAAgBD,GA6GjD,MAAMuD,EAAkB9D,KAAK6C,kBAC7B,IAAKiB,EAAiB,MAAM,IAAIZ,MAAM,eAEtC,MAAMa,EAAcD,EAAgBE,OAChCD,SACIA,QAEFrD,EAAiBoD,EAAiBlD,EAAc,IAGxD,EAEA,qBAAMqD,SAEEvD,EAAiBH,EAAe,EA/HpB,KAgIlBA,GAAesD,OACjB,EAEA,oBAAMK,CAAelB,EAAwBpC,GACAoC,EAAeC,MAAM,EAAG,IACnE,MAAMG,EAAepD,KAAK6C,kBAC1B,IAAKO,EAGH,MAAM,IAAIF,MAAM,4CAGQE,EAAaC,IAAIJ,OAAO,IAElDG,EAAaS,QACbT,EAAaC,IAAML,EACnBI,EAAahL,OAASwI,EAEIwC,EAAaC,IAAIJ,OAAO,IAElD,IACE,MAAMc,EAAcX,EAAaY,OAC7BD,SACIA,EAGR9H,EAAaiC,iBAAiB,UAEhC,CAAE,MAAOpD,GAKP,MAFAmB,EAAaiC,iBAAiB,WAExBpD,CACR,CAGF,EAEA,qBAAMqJ,CAAgBvD,GAEpB,MAAMmD,EAAcxD,GAAeyD,OAC/BD,SAAmBA,QACjBrD,EAAiBH,EAAeK,EA3KpB,IA4KpB,EAKH,EAxLsB,GA8LvB,MAAMwD,EACG,cAAAC,CAAeC,GAA4C,CAE3D,OAAAC,CAAQrF,EAAwBsF,GAKrC,GAHyEtF,EAAYtH,WAAuBsH,EAAYrH,aAAwBqH,EAAY9H,aAG1I,SAAdoN,EAEF,OAAOxE,KAAKkC,WAAWhD,GAGzB,MAAM,aAAErH,EAAY,aAAET,EAAY,gBAAEqN,GAAoBvF,EAClDwF,EAAcD,EAAgBzI,OAEpC,GAAInE,EAAe,EAAG,CACpB,MAAM8M,EAAY9M,EAAe,EAEjC,MAAO,CAAE+M,OAAQ,OAAQD,YAC3B,CAAO,GAAqB,SAAjBvN,EAAyB,CAClC,MAAMyN,EAAYH,EAAc,EAAIA,EAAc,EAAI,EAEtD,MAAO,CAAEE,OAAQ,OAAQD,UAAWE,EACtC,CAEE,MAAO,CAAED,OAAQ,UAErB,CAEO,UAAA1C,CAAWhD,GAE0CA,EAAYtH,WAAuBsH,EAAYrH,aAAwBqH,EAAY9H,aAG7I,MAAM,aAAES,EAAY,aAAET,EAAY,gBAAEqN,EAAe,cAAE3M,GAAkBoH,EAEjEyF,EAAY9M,EAAe,EAEjC,GAAI8M,EAHgBF,EAAgBzI,OAKlC,MAAO,CAAE4I,OAAQ,OAAQD,aACpB,GAAqB,QAAjBvN,EAET,MAAO,CAAEwN,OAAQ,uBACZ,CACL,MAAME,EAAmBL,EAAgBzI,OAGzC,OAFkClE,EAAciG,KAAO,GAEtB+G,EAExB,CAAEF,OAAQ,aAGV,CAAEA,OAAQ,OAAQD,UAAW,EAExC,CACF,CAEO,eAAAI,CAAgB7F,GAErB,OAAOc,KAAKuE,QAAQrF,EAAa,OACnC,EAGF,MAAM8F,EACG,cAAAX,CAAeC,GAA4C,CAE3D,OAAAC,CAAQD,EAAyBE,GAEtC,MAAO,CAAEI,OAAQ,UACnB,CAEO,UAAA1C,CAAWoC,GAEhB,MAAO,CAAEM,OAAQ,UACnB,CAEO,eAAAG,CAAgBT,GAErB,MAAO,CAAEM,OAAQ,OACnB,EAGF,MAAMK,EACI,2BAAAC,CACNC,EACArN,EACAD,GAI2BsN,EAAgBnJ,OAA8BlE,EAAciG,KAGvF,MAAMqH,EAAmBD,EAAgBE,OAAOC,IAAMxN,EAAcyN,IAAID,IAAMA,IAAMzN,GAC3CuN,EAAiBpJ,OAE1D,IAAK,IAAIsJ,EAAIF,EAAiBpJ,OAAS,EAAGsJ,EAAI,EAAGA,IAAK,CACpD,MAAME,EAAIC,KAAKC,MAAMD,KAAKE,UAAYL,EAAI,KACzCF,EAAiBE,GAAIF,EAAiBI,IAAM,CAACJ,EAAiBI,GAAIJ,EAAiBE,GACtF,CAIA,OAFiDF,EAAiBQ,KAAK,MAEhER,CACT,CAEQ,qBAAAS,CACN/N,EACAD,EACAiO,GAI4BhO,EAAciG,KAA8D+H,EAAgB9J,OAGxH,MAAM+J,EAAgBrI,MAAMC,KAAK,IAAItB,IAAI,IAAIvE,EAAeD,KACtD2H,EAAYuG,EAAcxG,QAAQ1H,GAClCwH,EAAe,IAAI0G,KAAkBD,GAO3C,OALwDC,EAAcH,KAAK,MACvCvG,EAAauG,KAAK,MAI/C,CAAEvG,eAAcG,YACzB,CAEQ,cAAAwG,CAAe9G,GAIrB,OAFyBA,EAAYtH,WAAuBsH,EAAY9H,aAEvC,QAA7B8H,EAAY9H,aAGP,CAAEwN,OAAQ,uBAIV,CAAEA,OAAQ,YAErB,CAEO,cAAAP,CAAenF,GACpB,IAAKA,EAEH,OAIsDA,EAAYtH,WAGpE,MAAMqO,EAAa/G,EAAYuF,gBAAgBjH,IAAI,CAAC1D,EAAGwL,IAAMA,GACvDY,EAAWlG,KAAKkF,4BAA4Be,EAAY/G,EAAYpH,cAAeoH,EAAYrH,eAC/F,aAAEwH,EAAY,UAAEG,GAAcQ,KAAK6F,sBACvC3G,EAAYpH,cACZoH,EAAYrH,aACZqO,GAGFjK,EAAaiE,qBAAqBb,EAAcG,EAClD,CAEO,cAAA2G,CAAejH,GAKpB,IAAKA,IAAgBA,EAAYuF,gBAE/B,OAAO,KAKT,MAAMwB,EAAa/G,EAAYuF,gBAAgBjH,IAAI,CAAC1D,EAAGwL,IAAMA,GAC7D,IAAK,IAAIA,EAAIW,EAAWjK,OAAS,EAAGsJ,EAAI,EAAGA,IAAK,CAC9C,MAAME,EAAIC,KAAKC,MAAMD,KAAKE,UAAYL,EAAI,KACzCW,EAAWX,GAAIW,EAAWT,IAAM,CAACS,EAAWT,GAAIS,EAAWX,GAC9D,CAEA,MAAMzF,EAAkBoG,EAElBrG,EAAkBC,EADH,GAMrB,MAAO,CAAED,kBAAiBC,kBAAiBP,aANtB,EAOvB,CAEO,OAAAiF,CAAQrF,EAAwBsF,GAGrC,MAAM,aAAEnF,EAAY,UAAEG,GAAcN,EAEpC,IAAKG,QAA8BnF,IAAdsF,EAGnB,MAAO,CAAEoF,OAAQ,aAMnB,GAFuCvF,EAAauG,KAAK,MAEvC,SAAdpB,EAAsB,CACxB,MAAM4B,EAAgB5G,EAAY,EAElC,GAAI4G,EAAgB/G,EAAarD,OAAQ,CACvC,MAAMqK,EAAmBhH,EAAa+G,GAKtC,MAAO,CAAExB,OAAQ,OAAQD,UAAW0B,EACtC,CAGE,OAAOrG,KAAKgG,eAAe9G,EAE/B,CAAO,CAEL,MAAMoH,EAAgB9G,EAAY,EAElC,GAAI8G,GAAiB,EAAG,CACtB,MAAMD,EAAmBhH,EAAaiH,GAKtC,MAAO,CAAE1B,OAAQ,OAAQD,UAAW0B,EACtC,CAGE,MAAO,CAAEzB,OAAQ,YAErB,CACF,CAEO,UAAA1C,CAAWhD,GAGhB,MAAM,aAAEG,EAAY,UAAEG,GAAcN,EAEpC,IAAKG,QAA8BnF,IAAdsF,EAGnB,MAAO,CAAEoF,OAAQ,QAIoBvF,EAAauG,KAAK,MAEzD,MAAMQ,EAAgB5G,EAAY,EAElC,GAAI4G,EAAgB/G,EAAarD,OAAQ,CACvC,MAAMqK,EAAmBhH,EAAa+G,GAKtC,MAAO,CAAExB,OAAQ,OAAQD,UAAW0B,EACtC,CAGE,OAAOrG,KAAKgG,eAAe9G,EAE/B,CAEO,eAAA6F,CAAgB7F,GAErB,OAAOc,KAAKuE,QAAQrF,EAAa,OACnC,EAMF,MAAM8C,EAAkB,MAGtB,MAAMuE,EAAuD,CAC3DC,KAAM,IAAIpC,EACVqC,OAAQ,IAAIzB,EACZW,OAAQ,IAAIV,GAEd,IAAIyB,EAAsCH,EAAYC,KAiCtD,MA/BkB,CAIhB,OAAAG,CAAQxO,GAENuO,EAAmBH,EAAYpO,EACjC,EAKA8J,mBAAoB,IAAMyE,EAO1B,kBAAAE,GAEiEF,EAAiBG,YAAYC,KAG5F,MAAM5H,EAAcjD,EAAakB,kBACjCuJ,EAAiBrC,eAAenF,EAElC,EAKH,EA1CuB,GAgDlB6H,EAAY,aAElB,IAAIC,GAA2B,EAC3BC,GAAgB,EAChBC,EAAiG,KAEjGC,EAA+C,KAC/CjM,GAAiB,EACjBkM,EAA+C,CAAC,EAChD1P,EAA+C,GAC/C2P,EAAwC,GAExCC,GAAyB,EACzBC,GAA0B,EAC1BC,EAAyC,KAE7C,MAAMC,EAAoE,GACpEC,EAAgE,GAQtE7F,eAAe8F,EAAwBC,EAAoBC,GAEzD,IAAIZ,EAAJ,CAIAA,GAAgB,EAGhB,IACEhL,EAAamC,qBAAoB,GAEjC0D,IAGA,IACE,MAAMgG,EAAa7L,EAAakB,kBAG1BlC,EAAmB2M,GAAcG,UACnCH,EAAaG,iBACLC,MAAqCC,SAASF,WAAa,CAAC,EAKlEvM,EAAoBjC,EAAW+B,mBAC/B4M,EAAe3O,EAAWgC,sBAAsBC,EAAmBP,EAAkBvD,GAGrFkH,EAAW3C,EAAamB,WAW9B,GATI8K,EAAatM,sBAAsBI,OAAS,IAC9ClC,EAAEqO,OAAOvJ,EAAUjC,GACjBuL,EAAatM,sBAAsBwM,KAAKC,GACtCC,EAA6B3L,EAAK3E,cAAeqQ,KAGfH,EAAatM,sBAAsBI,QAGvEkM,EAAavM,oBAAoBK,OAAS,EAC5C,IAAK,MAAMuM,KAAiBL,EAAavM,oBAAqB,CAC5D,GACEiD,EAASwJ,KAAKzL,GAAQA,EAAK3E,eAAiBsQ,EAA6B3L,EAAK3E,cAAeuQ,IAC7F,CAC2CA,EAAc3R,YACzD,QACF,CACA,MAAM4R,EAAUC,EAAgB,CAC9B/R,KAAM,MACNkB,WAAY2Q,EAAc3R,YAC1B8C,QAAS6O,IAEPC,IACF5J,EAAS7C,KAAKyM,GAC8BA,EAAQ5Q,WAExD,CAGFqE,EAAa0C,YAAYC,GAGzB,MAAM8J,EAAazM,EAAakB,kBAEhC,GAAIuL,GAAY9Q,aAAekQ,GAAYlQ,WAKzC,GAAI8Q,EAAY,CAEd1G,EAAgB4E,qBAEhB8B,EAAW3Q,eAAgB,EAC3B,MAAMuK,EAAcoG,EAAW3Q,cAAgB2Q,EAAW7Q,aAAe,EAEzE,GAAIoE,EAAae,YAEmB,SAA9B6K,GAASc,uBACLvI,EAAe8D,eACnBwE,EAAWjE,gBAAgBnC,GAAa7M,IACxCwG,EAAac,mBAGTwF,EAAmBD,QAEtB,QACUpI,IAAf4N,GACoC,YAApC7L,EAAagB,yBAMP2L,EAA4BtG,OAC7B,CAEL,MAAMuG,EAAQH,EAAWjE,gBAAgBnC,GACnCc,EAAehD,EAAeyC,kBAChCgG,GAASzF,IACXA,EAAaC,IAAMwF,EAAMpT,IAE7B,CACF,YAGQ2K,EAAe6D,kBAErBhI,EAAaiC,iBAAiB,WAE9B8D,EAAgB4E,2BASdrN,EAAWyB,oBAAoBC,EACvC,CAAE,MAAOH,GAGT,C,cACQ4H,EAAW,iBACnB,CACF,C,QACEuE,GAAgB,QACVxE,GAER,CA/HA,CAgIF,CAMA,SAASX,IACP,MAAM5C,EAAcjD,EAAakB,kBAC3B2L,EAAkB5J,GAAauF,iBAAmB,GAClD5M,EAAeqH,GAAarH,cAAgB,EAE5CkR,EAA4B,CAChC7J,YAAa4J,EAAgBjR,GACzB,CACEmR,MAAOF,EAAgBjR,GAAc,GACrCoR,OAAQH,EAAgBjR,GAAc,GACtCqR,MAAOJ,EAAgBjR,GAAc,IAEvC,KACJmF,UAAWf,EAAae,YACxBM,cAAerB,EAAagB,mBAC5BkM,aAAclN,EAAaa,kBAC3BsM,aAAcnN,EAAac,YAC3BsM,SAAUP,EAAgBtL,IAAIb,IAAQ,CAAGqM,MAAOrM,EAAK,GAAIsM,OAAQtM,EAAK,GAAIuM,MAAOvM,EAAK,MACtF2M,gBAAiBrN,EAAaiB,sBAShCuK,EAAyB8B,QAAQC,IAC/B,IACEA,EAAST,EACX,CAAE,MAAOpF,GAET,GAEJ,CAEA,SAASf,IACP,MAAMQ,EAAehD,EAAeyC,kBACpC,IAAK5G,EAAae,cAAgBoG,EAAc,OAChD,MAAM2F,EAA6B,CACjCU,YAAarG,EAAaqG,YAC1B5I,SAAUuC,EAAavC,UAAY,GAErC6G,EAAoB6B,QAAQC,GAAYA,EAAST,GACnD,CAyCAlH,eAAea,EAAWgH,GACxB,GAAKxO,EAIL,IAEE,MAAMyO,EAAa1N,EAAasB,uCAE1BnC,oBACJC,IACEA,EAAK0L,GAAa4C,EACXtO,GAET,CAAE3E,KAAM,QAIZ,CAAE,MAAOiN,GAET,CACF,CASA,SAASiG,EAAyB9O,GAChC,MAAM+O,EAAQ/O,EAAMgP,OAAO,GACrBC,EAAOF,EAAME,KAAKnE,KAAK,QACvBlQ,EAAUmU,EAAMnU,QAGhBsU,EAAgB,OAAOD,WAAcrU,IAK3CuU,OAAOnP,MAAMkP,EANO,qBAMqB,CAAEE,QAAS,MACtD,CAaA,SAAS5B,EACPxJ,EACAC,GAEA,IAAKD,IAAMC,EAAG,OAAOD,IAAMC,EAE3B,GAAID,EAAElI,cAAgBmI,EAAEnI,YAAa,OAAO,EAI5C,MAAMuT,EAAsBvQ,GAClBwQ,OAAOC,KAAKzQ,GACjBiF,OACArB,IAAI8M,GAAO,GAAGA,KAAOC,OAAO3Q,EAAU0Q,OACtC1E,KAAK,KAGJ4E,EAAc1L,EAAE/H,WAAWyG,IAAI2M,GAAoBtL,OACnD4L,EAAc1L,EAAEhI,WAAWyG,IAAI2M,GAAoBtL,OAEzD,OAAO2L,EAAYxO,SAAWyO,EAAYzO,QAAUwO,EAAYE,MAAM,CAACC,EAAK1L,IAAU0L,IAAQF,EAAYxL,GAC5G,CAOA4C,eAAemG,EAAiC4C,GAK9C,GAAIA,GAAiC,IAAtBA,EAAQC,WAA8C,iBAApBD,EAAQE,QAAsB,CAElCF,EAAQC,UAAuBD,EAAQE,QAGlF,IACE,MAAMC,QAA8BC,IAAIC,WAAW,CAAEvU,KAAM,UAAWwU,WAAY,IAE5EC,EAAoBJ,GAAkBK,cAAcR,EAAQE,SAElE,GAAIK,GAAmBpD,UAIrB,MAAO,CAAEE,QAASkD,EAAmBN,UAAW,GAC3C,GAAIE,GAAkBhD,UAI3B,MAAO,CAAEE,QAAS8C,EAAkBF,UAAW,EAInD,CAAE,MAAO/P,GAET,CAGF,CAIA,IACE,MAAMuQ,EAAcC,iBAAiB,EAAG,CAAEC,gBAAgB,IAC1D,IAAK,IAAIjG,EAAI+F,EAAYrP,OAAS,EAAGsJ,GAAK,EAAGA,IAAK,CAChD,MAEMkG,EAFUH,EAAY/F,GAEK4F,WAGjC,GAAgC,iBAArBM,EAKX,IAEE,MAAMvD,QAAgB+C,IAAIC,WAAW,CAAEvU,KAAM,UAAWwU,WAAYM,IAEpE,GAAIvD,GAASF,UAGX,MAAO,CAAEE,UAAS4C,UAAWW,EAEjC,CAAE,MAAO1Q,GAET,CACF,CAEA,OAAO,IACT,CAAE,MAAOA,GAEP,OAAO,IACT,CAGF,CAQA+G,eAAe4J,IAKb,MAAMC,UAA2BxI,MAC/B,WAAA2D,CAAYnR,GACViW,MAAMjW,GACNsK,KAAK8G,KAAO,oBACd,EAMF,MAAM8E,EAKF,CACFnU,UAAW,GACXC,SAAU,GACV2P,uBAAmBnN,EACnB2R,6BAA8B,MAGhC,IAEE,MAAMC,EAAiBC,sBAAsB,WACvCC,EAAc,CAACF,EAAeG,WAAYH,EAAeI,YAAY7G,OAAO8G,SAGlF,GAA2B,IAAvBH,EAAYhQ,OACd,MAAM,IAAI0P,EAAmB,gBAG/B,IAAIU,GAAsB,EAE1B,IAAK,MAAMC,KAAYL,EAAa,CAClC,IAAKK,EAAU,SACf,MACMC,SADgBC,aAAaF,IACLhH,OAAO1B,GAAKA,EAAEmD,KAAK3M,SAAS,kBAEtDmS,EAActQ,OAAS,IACzBoQ,GAAsB,GAGxB,IAAK,MAAMI,KAASF,EAAe,CACGE,EAAM1F,KAC1C,IACE,MAAM2F,EAAYC,KAAKC,MAAMH,EAAMI,SAC7BC,EAAmBtV,EAAmBuV,UAAUL,GAEtD,IAAKI,EAAiBE,QAAS,CACDP,EAAM1F,KAClC8C,EAAyBiD,EAAiB/R,OAC1C,QACF,CAEA,MAAMkS,EAAOH,EAAiBG,KAQ9B,GANIA,EAAKvV,WACPmU,EAAiBnU,UAAUsE,QAAQiR,EAAKvV,UAAU+F,IAAIyP,IAAK,IAAMA,EAAGC,YAAaV,EAAM1F,SAErFkG,EAAKtV,UACPkU,EAAiBlU,SAASqE,QAAQiR,EAAKtV,SAAS8F,IAAI2P,IAAK,IAAMA,EAAGD,YAAaV,EAAM1F,SAEnFkG,EAAKxV,oBAAqB,CAC5B,GAAIoU,EAAiBvE,mBAAqBuE,EAAiBvE,oBAAsB2F,EAAKxV,oBAAqB,CACzG,MAAM4V,EAAa,QAAQZ,EAAM1F,oCAAoCkG,EAAKxV,kCAAkCoU,EAAiBC,8BAAgC,eAAeD,EAAiBvE,0CAE7L4C,OAAOoD,QAAQD,EAAY,OAAQ,CAAElD,QAAS,IAAOoD,aAAa,GACpE,CACA1B,EAAiBvE,kBAAoB2F,EAAKxV,oBAC1CoU,EAAiBC,6BAA+BW,EAAM1F,IACxD,CACF,CAAE,MAAOnD,GACuB6I,EAAM1F,KAAsBnD,EAAEjO,QAC5DuU,OAAOnP,MAAM,qBAAqB0R,EAAM1F,yBAA0B,OAAQ,CACxEoD,QAAS,KAEb,CACF,CACF,CAGA,IAAKkC,EACH,MAAM,IAAIV,EAAmB,wCAK/B,IAAI6B,GAAkB,EACtB,MAAMC,EAAgB1T,EAAE2T,QAAQ7B,EAAiBnU,UAAW,MAC5D,IAAK,MAAMN,KAAMqW,EACf,GAAIA,EAAcrW,GAAI6E,OAAS,EAAG,CAChC,MACM0R,EAAW,8BAA8BvW,qBAD/BqW,EAAcrW,GAAIqG,IAAIyP,GAAKA,EAAEC,aAAatH,KAAK,mBAG/DqE,OAAOnP,MAAM4S,EAAU,OAAQ,CAAExD,QAAS,OAC1CqD,GAAkB,CACpB,CAEF,MAAMI,EAAiB,IAAItR,IAAIuP,EAAiBnU,UAAU+F,IAAIyP,GAAKA,EAAE9V,KACrE,GAAIyU,EAAiBvE,oBAAsBsG,EAAepI,IAAIqG,EAAiBvE,mBAAoB,CACjG,MAAMqG,EAAW,iDAAiD9B,EAAiBvE,6BAA6BuE,EAAiBC,8BAAgC,sBAEjK5B,OAAOnP,MAAM4S,EAAU,OAAQ,CAAExD,QAAS,OAC1C0B,EAAiBvE,uBAAoBnN,CACvC,CACA,MAAM0T,EAAgBhC,EAAiBlU,SAAS2N,OAAO3L,IACrD,GAAIiU,EAAepI,IAAI7L,EAAQ9C,aAC7B,OAAO,EAET,MAAM8W,EAAW,6BAA6BhU,EAAQwT,iCAAiCxT,EAAQ9C,yBAG/F,OADAqT,OAAOnP,MAAM4S,EAAU,OAAQ,CAAExD,QAAS,OACnC,IAGT,IAAKqD,EAIH,OAAO,KAKT,GAA0C,IAAtC3B,EAAiBnU,UAAUuE,OAC7B,MAAM,IAAI0P,EAAmB,oCAI/B,MAAMmC,EAAiD,CAAC,EACxD,IAAK,MAAMC,KAAMlC,EAAiBnU,UAAW,CAC3C,MAAMsW,EAAmBD,EAAGxW,OAAOkG,IAAIqL,IAAS,CAC9CpT,IAAKoT,EAAMpT,IACX,GACEoT,EAAM,IAA0B,KAApBA,EAAM,GAAG5P,OACjB4P,EAAM,GACNmF,mBAAmBnF,EAAMpT,IAAI8E,MAAM,KAAK0T,OAAO1T,MAAM,KAAK,IAAM,QACtE,GAAIsO,EAAM,GACV,GAAIA,EAAM,MAGZgF,EAAeC,EAAG3W,IAAM,IAAK2C,EAAE2D,KAAKqQ,EAAI,eAAgBxW,OAAQyW,EAClE,CAUA,MARoB,CAClBtW,UAAWoW,EACXK,UAAWtC,EAAiBvE,kBAC5B3P,SAAUkW,EAAcpQ,IAAI2P,GAAKrT,EAAE2D,KAAK0P,EAAG,gBAM/C,CAAE,MAAOrS,GA0BP,OAxBIA,aAAiB4Q,GAEkB5Q,EAAMpF,QAI3CuU,OAAOnP,MAAMA,EAAMpF,QAAS,eAAgB,CAC1CwU,QAAS,IACToD,aAAa,KAMfrD,OAAOnP,MACL,2CACA,oBACA,CACEoP,QAAS,IACToD,aAAa,IAKZ,IACT,CACF,CAQA,SAASa,EACPC,EACAC,GAEA,MAAO,CACLzW,WAAYwW,EAAcxW,WAC1Bf,SAAUuX,EAAcpW,eAAenB,WAAayX,IACpD7J,gBAAiB3K,EAAEqB,UAAUkT,EAAe/W,QAC5CF,aAAciX,EAAejX,aAC7BS,aAAcuW,EAAcvW,aAC5BC,cAAe,IAAIuE,IAAI+R,EAActW,eACrCC,cAAeqW,EAAcrW,cAC7BwW,YAAaH,EAAcpW,cAAgB,MAAQ,OACnDA,cAAeoW,EAAcpW,cAEjC,CAWA,SAASyQ,EAAgB+F,GACvB,MAAM,WAAE5W,GAAe4W,EAEvB,IAAK5W,IAAewP,EAAaxP,GAE/B,OAAO,KAGT,MAAMyW,EAAiBjH,EAAaxP,GAE9B6W,EAA2F,CAC/F7W,WAAYA,EACZ6M,gBAAiB3K,EAAEqB,UAAUkT,EAAe/W,QAC5CO,aAAc,EACdC,cAAe,IAAIuE,IACnBtE,eAAe,GAGjB,MAAoB,SAAhByW,EAAO9X,KACF,IACF+X,EACH5X,UAAWyX,IACXC,YAAa,OACbnX,aAAciX,EAAejX,cAAgB,QAGxC,IACFqX,EACH5X,SAAU2X,EAAO9U,QAAQ7C,SACzB0X,YAAa,MACbnX,aAAciX,EAAejX,aAC7BY,cAAewW,EAAO9U,QAG5B,CAMAmI,eAAe6M,EACbF,EACAG,EACA9G,GAGA,IAEEN,GAA0B,EAE1B,MAAM3M,EAtcV,WAEE,MAAMgU,EAAY/T,aAAa,CAAEnE,KAAM,SAAUqQ,GAEjD,IAAK6H,GAAkC,iBAAdA,EAEvB,OAAO,KAIT,MAAM/B,EAAmB5U,EAAkB6U,UAAU8B,GAErD,OAAI/B,EAAiBE,QAEZF,EAAiBG,KAGjB,IAEX,CAmbuB6B,GACnB5S,EAAalB,aAETH,GAEFqB,EAAa4B,UAAUjD,GAGzBrB,EAAWwB,aACXxB,EAAWoB,aACX,MAAMyI,EAAehD,EAAeyC,kBAMpC,GALIO,GAAcA,EAAaS,QAC/BnM,EAAW,GACX0P,EAAe,CAAC,EAChBC,EAAoB,IAEfmH,EAGH,MADA1M,IACM,IAAIoB,MAAM,sBAGlBkE,EAAeoH,EAAO/W,UACtB4P,EAAoBmH,EAAON,UAC3BxW,EAAW8W,EAAO9W,SAElB,MAAMoX,EAAkBH,GAAoB1G,SAASF,WAAa,KAC5DgH,EAAyBJ,GAAoB9D,UAEnD,IAAImE,EAA0B,GAG1BC,EAAwB5H,EAE5B,MAAM6H,EAAU5D,gBAAgB,EAAG,CAAEC,gBAAgB,IAAQ,GACvD4D,EAAiBD,GAASE,UAAY,EAE5C,GAAIF,EAAS,CACX,MAAMG,EAAkBH,EAAQI,SAASJ,EAAQE,UAC3CG,EAAWF,GAAiBlW,MAAM,sBACxC,GAAIoW,GAAYA,EAAS,GAAI,CAC3B,MAAMC,EAAgBD,EAAS,GAC/B,GAAInI,EAAaoI,GAEfP,EAAwBO,MACnB,CACL,MAAM9B,EAAW,uCAAuC8B,6BAExDvF,OAAOoD,QAAQK,EAAU,OAAQ,CAAExD,QAAS,MAC9C,CACF,CAGF,CAEA,MAAMuF,EAAcxT,EAAaqC,uBAajC,GAXoB,OAAhBmR,GAAwBA,IAAgBN,GAG1ClT,EAAayC,6BAKfzC,EAAasC,qBAAqB4Q,GAG9BF,EAAuB,CAEzB,GADyB,IAAI5S,IAAI3E,EAAS8F,IAAI2P,GAAKA,EAAEvW,cAChC2O,IAAI0J,GAAwB,CAC/C,MAAMS,EAAgB,6BAA6BT,uDAGnD,MADAhF,OAAOnP,MAAM4U,EAAe,OAAQ,CAAExF,QAAS,IAAOoD,aAAa,IAC7D,IAAIpK,MAAM,mBAClB,CACF,CAGA,GAAItI,EAAY,CAEd,MAAM+U,EAA2B,GAEjC,IAAK,MAAMvB,KAAiBxT,EAAW1C,aAAc,CACnD,IAAKkS,OAAOwF,UAAUC,eAAeC,KAAK1I,EAAcgH,EAAcxW,YAAa,CACvDwW,EAAcxW,WACxC,QACF,CAEA,MAAMyW,EAAiBjH,EAAagH,EAAcxW,YAGlD,IAFoBwW,EAAcpW,cAG5BoW,EAAcxW,aAAeqX,GACLb,EAAcxW,WACxC+X,EAAY5T,KAAKoS,EAAsBC,EAAeC,KAGnCD,EAAcxW,eAI9B,CACL,MAAMmY,EAAiBrY,EAASsY,KAAK7C,GAAKA,EAAEvW,cAAgBwX,EAAcxW,YAG1E,GAFkCwW,EAAcxW,WAEZ,QAAhCyW,EAAejX,aAEjB,SAGF,IAAK2Y,EAEH,SAGF,IAAKxW,EAAWmB,sBAAsBqV,EAAgBjB,GAEpD,SAIFa,EAAY5T,KAAKoS,EAAsBC,EAAeC,GACxD,CACF,CACAW,EAAaW,CAEf,CAGA,GAAIb,GAAmBpX,EAASsE,OAAS,EAEvC,IAAK,MAAMtC,KAAWhC,EAAU,CAK9B,IAJsBsX,EAAW5G,KAC/BzL,GAAQA,EAAK3E,eAAiBsQ,EAA6B3L,EAAK3E,cAAe0B,KAG3DH,EAAWmB,sBAAsBhB,EAASoV,GAAkB,CAChF,MAAMT,EAAiBjH,EAAa1N,EAAQ9C,aAC5C,GAAIyX,GAAkD,QAAhCA,EAAejX,aACnC,GAA+B,IAA3B2X,EAA8B,CACArV,EAAQ9C,YACxC,MAAM4R,EAAUC,EAAgB,CAAE/R,KAAM,MAAOkB,WAAY8B,EAAQ9C,YAAa8C,QAASA,IACrF8O,GAASwG,EAAWjT,KAAKyM,EAC/B,MAEqB9O,EAAQ9C,gBAIxB,CACL,MAAM4R,EAAUC,EAAgB,CAAE/R,KAAM,MAAOkB,WAAY8B,EAAQ9C,YAAa8C,QAASA,IACrF8O,GAASwG,EAAWjT,KAAKyM,EAC/B,CACF,CACF,CAMF,IAD2BwG,EAAW5G,KAAKzL,GAA6B,SAArBA,EAAK4R,cAC7BU,GAAyB7H,EAAa6H,GAAwB,CAGvF,GAFehT,EAAauC,2BAA2B+G,IAAI0J,QAMpD,CAEL,MAAMR,EAAWhG,EAAgB,CAAE/R,KAAM,OAAQkB,WAAYqX,IACzDR,GAAUO,EAAWjT,KAAK0S,EAChC,CACF,CAIAxS,EAAa0C,YAAYqQ,GAKzB,MAAM7W,EAAO8D,EAAaa,kBAC1BkF,EAAgB2E,QAAQxO,GAExB6J,EAAgB4E,qBAEhBxG,EAAezF,aAEf,MAAMvC,EAAS6D,EAAac,YACxBqD,EAAeyC,oBAAmBzC,EAAeyC,kBAAmBzK,OAASA,GAC7EgI,EAAe0C,qBAAoB1C,EAAe0C,mBAAoB1K,OAAS,GAEnF,MAAM6X,EAAiBhU,EAAakB,kBACpC,GAAI8S,EAAgB,CAClB,MAAMpH,EAAQoH,EAAexL,gBAAgBwL,EAAepY,cACxDgR,GAASzI,EAAeyC,oBAC1BzC,EAAeyC,kBAAmBQ,IAAMwF,EAAMpT,IAElD,CAeA,GAXIqZ,QACIvV,EAAWyB,oBAAoB8T,SAG/BvV,EAAWyB,oBAAoB,CAAC,SAIlC0H,IACNZ,IAEI+F,GAASqI,qBAAsB,CAEbjU,EAAakB,yBA4WvC0E,iBACE,GAAI5F,EAAaiB,qBAEf,OAGF,MAAMgC,EAAcjD,EAAakB,kBACjC,IAAK+B,EAEH,OAGF,IACEjD,EAAamC,qBAAoB,GACsBc,EAAYrH,mBAE7D+Q,EAA4B1J,EAAYrH,aAChD,CAAE,MAAOiD,GAEPmB,EAAaiC,iBAAiB,WAC9B4D,GACF,C,cACQW,UACAC,GAER,CACF,CAnYcyN,EAIV,CACF,CAAE,MAAOrV,GAGP,MAAMA,CACR,CAGF,CAQA+G,eAAeU,EAAmBD,GAGhC,MAAM8N,EAAYnU,EAAakB,kBAC/B,IAAKiT,EAGH,OAAOtP,QAAQC,UAGjB,MAAMsP,EAAcD,EAAU3L,gBAAgBnC,GAC9C,IAAK+N,GAAa5a,IAGhB,MAAM,IAAIyN,MAAM,0BAA0BZ,KAG5C,UACQlC,EAAe2C,kBAAkBsN,EAAY5a,IAAKwG,EAAac,aAErEd,EAAaiC,iBAAiB,WA3tBlC,WACE,MAAMgB,EAAcjD,EAAakB,kBAC3BgG,EAAgB/C,EAAe0C,mBACrC,IAAKK,IAAkBjE,EAAa,OACpC,MAAMyF,EAAYzF,EAAYrH,aAAe,EAC7C,GAAI8M,EAAYzF,EAAYuF,gBAAgBzI,OAAQ,CAClD,MAAMsU,EAAYpR,EAAYuF,gBAAgBE,GAC1C2L,GAAanN,EAAcE,MAAQiN,EAAU7a,MAC/C0N,EAAcE,IAAMiN,EAAU7a,IAC9B0N,EAAcG,OAElB,CACF,CAgtBIiN,EAEF,CAAE,MAAOzV,GAEP,MAAMA,CACR,CAGF,CAMA+G,eAAeW,IAGb,IAAIgO,EAAsB,EAC1B,MAAMC,EAA0BxU,EAAakB,kBACvCuT,EAAYD,GAAyBhM,gBAAgBzI,QAAU,EAQrE,IANIyU,GACFxG,OAAOnP,MACL,MAAM2V,EAAwBhM,gBAAgBgM,EAAwB5Y,eAAe,IAAM,6BAIlF,CACX,GAAI6Y,EAAY,GAAKF,GAAuBE,EAU1C,OALID,GACFxG,OAAOnP,MAAM,MAAM2V,EAAwB7Y,gCAE7CqE,EAAaiC,iBAAiB,gBAC9B4D,IAIF,MAAM5C,EAAcjD,EAAakB,kBACjC,IAAK+B,EAIH,OAFAjD,EAAaiC,iBAAiB,gBAC9B4D,IAIF,MAAM6O,EAAgB3O,EAAgBC,qBAAqB8C,gBAAgB7F,GAErD8C,EAAgBC,qBAAqB4E,YAAYC,KAA2B6J,EAAc/L,OAGhH,MAAMzC,QAAkBC,EAAyBuO,GAEjD,IAAKxO,EAAUE,iBAGb,OAIF,GAAqC,iBAA1BF,EAAUG,YAInB,OAFArG,EAAaiC,iBAAiB,gBAC9B4D,IAKF,IAKE,aAJMS,EAAmBJ,EAAUG,kBAGnCR,GAEF,CAAE,MAAO8O,GACPJ,IACA,MAAMK,EAAc5U,EAAakB,kBAC3B2T,EAAiBD,GAAapM,gBAAgBoM,EAAYhZ,eAAe,IAAM,OAGrFoS,OAAOnP,MAAM,OAAOgW,YACtB,CACF,CACF,CAEAjP,eAAeO,EACbL,GAG2CA,EAAS6C,OAAuB7C,EAAS4C,UAIpF,IACIrC,EADAD,GAAmB,EAGvB,MAAMnD,EAAcjD,EAAakB,kBAEjC,OAAQ4E,EAAS6C,QACf,IAAK,OAC+B,iBAAvB7C,EAAS4C,WAElB1I,EAAakD,qBAAqB4C,EAAS4C,WAC3CtC,GAAmB,EACnBC,EAAcP,EAAS4C,WAKvBtC,GAAmB,EAErB,MAGF,IAAK,UAECnD,IAEFmD,GAAmB,EACnBC,EAAcpD,EAAYrH,cAE5B,MAGF,IAAK,sBAAuB,CAE1B,MAAMkZ,EAAe9U,EAAakB,kBAC9B4T,GAA6C,SAA7BA,EAAaxC,aAAwD,QAA9BwC,EAAa3Z,eAC5B2Z,EAAanZ,WACvDqE,EAAawC,2BAA2BsS,EAAanZ,aAEvD,MAAMoZ,EAAe/U,EAAamB,WAEf4T,EAAaC,QAGhChV,EAAa0C,YAAYqS,GAGzBhP,EAAgB4E,qBAEhB,MAAM8B,EAAazM,EAAakB,kBAC5BuL,GACqBA,EAAW9Q,WAA2B8Q,EAAW7Q,aACxEwK,GAAmB,EACnBC,EAAcoG,EAAW7Q,qBAInBuI,EAAe6D,kBACrBhI,EAAaiC,iBAAiB,WAC9BmE,GAAmB,GAGrB,KACF,CAEA,IAAK,YAAa,CAEhBpG,EAAayD,0BAEb,GAAoB,WADAzD,EAAaa,kBACH,CAE5B,MAAMoU,EAAelP,EAAgBC,qBAAwCkE,eAC3ElK,EAAakB,mBAEX+T,GACFjV,EAAa0D,mBACXuR,EAAYtR,gBACZsR,EAAYrR,gBACZqR,EAAY5R,aAGlB,CACA,MAAM6R,EAAkBlV,EAAakB,mBAAmBtF,cAAgB,EAExEwK,GAAmB,EACnBC,EAAc6O,EACd,KACF,CAEA,IAAK,OAEHlV,EAAaiC,iBAAiB,WAUV,wBAApB6D,EAAS6C,QACX9C,IAGF,MAAMK,EAAY,CAAEE,mBAAkBC,eAKtC,OAAOH,CACT,CAMAN,eAAeY,IAIbxG,EAAamC,qBAAoB,GACjC0D,GACF,CA0CAD,eAAeuP,EAAkB5M,GAE/B,GAAIvI,EAAaiB,qBAGf,OAGF,MAAMgC,EAAcjD,EAAakB,kBACjC,GAAK+B,EAML,IACEjD,EAAamC,qBAAoB,GACjC0D,IAEA,MAAMC,EAAWC,EAAgBC,qBAAqBsC,QAAQrF,EAAasF,GACrErC,QAAkBC,EAAyBL,GAMjD,GAHiCA,EAAS6C,OAAkCzC,EAAUE,iBAG9D,YAApBN,EAAS6C,OAAsB,CAEjC,MAAMxB,EAAehD,EAAeyC,kBAChCO,IAAcA,EAAaqG,YAAc,GACN,WAAnCxN,EAAaa,mBACfmN,OAAOoH,KAAK,QAEhB,MAAWlP,EAAUE,kBAAqD,iBAA1BF,EAAUG,kBAClDC,EAAmBJ,EAAUG,aACN,cAApBP,EAAS6C,QAClBqF,OAAOoH,KAAmB,SAAd7M,EAAuB,YAAc,WAErD,CAAE,MAAO1J,SAGD0H,GACR,C,cACQC,UACAC,GAER,CACF,CAMAb,eAAe+G,EAA4BtG,GAEzCrG,EAAaiC,iBAAiB,WAC9B4D,UACMS,EAAmBD,EAC3B,CAiJA,SAASgP,IACPjQ,OAAOkQ,eAAiB,CACtBC,sBAAuB,IACjBxK,GAEFlF,IACOhB,QAAQC,YAGZoG,IAEHA,EAAyB,IAAIrG,QAAQ,CAACC,EAASwC,KAC7C2D,EAAiC,CAAEnG,UAASwC,aAMzC4D,GAGTsK,gBAAiB,IAjGrB5P,iBAIE,GAAI5F,EAAaiB,qBAGf,OAIF,MAAMgC,EAAcjD,EAAakB,kBACjC,GAAK+B,EAOL,IAEEjD,EAAamC,qBAAoB,GACjC0D,IAKA,OAHqB7F,EAAagB,oBAIhC,IAAK,UAIHhB,EAAaiC,iBAAiB,WAC9B4D,UAIMS,EAAmBrD,EAAYrH,cACrC,MAGF,IAAK,UAEHoE,EAAaiC,iBAAiB,UAC9B4D,UACM1B,EAAe6D,kBACrB,MAGF,IAAK,SAEHhI,EAAaiC,iBAAiB,WAC9B4D,UACM1B,EAAe+D,gBAAgBlI,EAAac,aAIxD,CAAE,MAAOjC,SAGD0H,GACR,C,cACQC,UACAC,GAER,MAnDEuH,OAAOoH,KAAK,SAoDhB,CA+B2BI,GACvBC,SAAU,KA7BPN,EAAkB,SA8BrBO,SAAU,KA1BPP,EAAkB,SA2BrBQ,UAAY3S,IACV,MAAMC,EAAcjD,EAAakB,kBAC7B+B,GAAeD,GAAS,GAAKA,EAAQC,EAAYuF,gBAAgBzI,QA7I3E6F,eAAgC5C,GAE9B,IAAIhD,EAAaiB,qBAMjB,IACEjB,EAAamC,qBAAoB,GACjC0D,IAEA,MAAM5C,EAAcjD,EAAakB,kBAC3B0U,EAAc5V,EAAaa,kBAEjC,GAAIoC,GAAeD,IAAUC,EAAYrH,aAAc,CAErD,MAAMuL,EAAehD,EAAeyC,kBAChCO,IAAcA,EAAaqG,YAAc,EAC/C,KAA2B,SAAhBoI,GAA0C,WAAhBA,GAEnC5V,EAAa+C,gBAAgBC,SACvBsD,EAAmBtD,IACA,WAAhB4S,IAET5V,EAAa6D,kBAAkBb,SACzBsD,EAAmBtD,GAE7B,CAAE,MAAOnE,SAGD0H,GACR,C,cACQC,UACAC,GAER,CACF,CAyGaoP,CAAiB7S,IAG1B8S,0BAA4B3Z,IAC1B,MAAM4Z,EAAcvM,KAAKnN,IAAI,EAAGmN,KAAKpN,IAAI,EAAGD,IACtCgL,EAAehD,EAAeyC,kBACpC5G,EAAagC,UAAU+T,GACnB5O,IAAiBnH,EAAaiB,uBAAsBkG,EAAahL,OAAS4Z,GACzEtP,IACLZ,KAEFmQ,cAAgB7Z,IACd,MAAMgL,EAAehD,EAAeyC,kBAChCO,IAAiBnH,EAAaiB,uBAAsBkG,EAAahL,OAASqN,KAAKnN,IAAI,EAAGmN,KAAKpN,IAAI,EAAGD,MAGxG4F,gBAAkB7F,IAEhB,MAAM+Z,EAAUjW,EAAaa,kBACzB3E,IAAS+Z,IAMbjW,EAAa+B,gBAAgB7F,GAC7B6J,EAAgB2E,QAAQxO,GAES6J,EAAgBC,qBAAqB4E,YAAYC,KAElE,WAAZoL,GAEFjW,EAAagE,sBAEF,WAAT9H,GAEF6J,EAAgB4E,qBAGblE,IACLZ,MAGFqQ,OAASC,IACP,MAAMhP,EAAehD,EAAeyC,kBAChCO,GAAcvC,WAAUuC,EAAaqG,YAAcrG,EAAavC,SAAWuR,IAEjFC,gBAAiB,KACf,MAAM/M,EAAIrJ,EAAakB,kBACjBmV,EAAIhN,GAAGb,iBAAmB,GAC1B8N,EAAIjN,GAAGzN,cAAgB,EAY7B,MAXwC,CACtCqH,YAAaoT,EAAEC,GAAK,CAAEvJ,MAAOsJ,EAAEC,GAAG,GAAItJ,OAAQqJ,EAAEC,GAAG,GAAIrJ,MAAOoJ,EAAEC,GAAG,IAAO,KAC1EvV,UAAWf,EAAae,YACxBM,cAAerB,EAAagB,mBAC5BkM,aAAclN,EAAaa,kBAC3BsM,aAAcnN,EAAac,YAC3BsM,SAAUiJ,EAAE9U,IAAI2P,IAAK,CAAGnE,MAAOmE,EAAE,GAAIlE,OAAQkE,EAAE,GAAIjE,MAAOiE,EAAE,MAC5D7D,gBAAiBrN,EAAaiB,uBAOlCsV,kBAAoBF,GACD,mBAANA,GACT7K,EAAyB1L,KAAKuW,GACqB7K,EAAyBzL,OAErE,KACL,MAAMiD,EAAQwI,EAAyBlI,QAAQ+S,GAC3CrT,GAAS,IACXwI,EAAyBgL,OAAOxT,EAAO,GACYwI,EAAyBzL,UAK3E,OAGT0W,aAAeJ,GACI,mBAANA,GACT5K,EAAoB3L,KAAKuW,GAElB,KACL,MAAMrT,EAAQyI,EAAoBnI,QAAQ+S,GACtCrT,GAAS,GACXyI,EAAoB+K,OAAOxT,EAAO,KAIjC,QAGX0T,iBAAiB,iBAAkBtR,OAAOkQ,eAC5C,CAkBA1P,eAAe+Q,IACb,GAAI5L,EAA0B,OAE9B,MAAM6L,EAAgBC,YAAYC,iBAAmBD,YAAYC,mBAAqB,KAEtF,GAAID,YAAYE,KAAKhX,OAAS,GAAuB,OAAlB6W,EAAwB,CAEzD7L,GAA2B,EAC3BQ,EAAiBqL,EAIjB,IAGE,MAAMrE,QAAe/C,IACrB,IAAK+C,EACH,MAAM,IAAItL,MAAM,oBAGlB,MAAM+P,EAAYzE,EAAO9W,UAAYgG,MAAMwV,QAAQ1E,EAAO9W,WAAa8W,EAAO9W,SAASsE,OAAS,EAIhG,GAAIiX,EAAW,CAIb,UAyRRpR,iBAGE,UAEQsR,sBAAsB,MAE9B,CAAE,MAAOxP,GAGP,OAAO,CACT,CAGA,MAAMyP,EAAkB,IAClBC,EAAmB,IACnBC,EAAYC,KAAKne,MACvB,IAAIoe,GAAoB,EAGxB,KAAOD,KAAKne,MAAQke,EAAYF,GAAiB,CAC/C,IACE,MAAMnL,QAAqB+C,IAAIC,WAAW,CAAEvU,KAAM,UAAWwU,WAAY,IACzE,GAAIjD,IAAYA,EAAQmD,aAAenD,EAAQF,WAAY,CAEzDyL,GAAoB,EACpB,KACF,CACF,CAAE,MAAO1Y,GAET,OACM,IAAIgG,QAAQC,GAAW0S,WAAW1S,EAASsS,GACnD,CAEA,IAAKG,EAGH,OAAO,EAKT,IAKE,OA/RJ,WAGE,MAAME,EAA0BC,GACtB/L,IACDN,GAA2BC,GAM3BI,EAAwBC,IAIjCgM,QAAQ5I,IAAI6I,OAAOC,sBAAuBJ,EAAuB,0BAEjEE,QAAQG,cAAcC,gBAAkBC,IAEjCC,EAA0B,oBAInC,CAoQIC,GACA7M,GAAyB,GAGlB,CACT,CAAE,MAAOxM,GAIP,OAFAwM,GAAyB,GAElB,CACT,CACF,CAhViC8M,GAEvB,MAAM,IAAIlR,MAAM,0BAGpB,CAOA,IAAIyL,EAAqB,KACrBsE,IAEFtE,QAA2B3G,WAKvB0G,EAAwBF,EAAQG,GA2O1CiF,QAAQG,cAAcM,2BAA6Bld,KAtJrD0K,eAA0CgJ,GAGxC,GAAkB,IAAdA,GAKiB5O,EAAakB,kBAMlC,IACE,MAAMzH,EAAU4V,gBAAgBT,KAAa,GAEzCnV,GAA4B,SAAjBA,EAAQ4e,OAAoB5e,EAAQA,QAAQyE,SAAS,+BAG5Doa,gBAAgB,CAAC,CAAErJ,WAAYL,EAAWnV,QAAS,GAAGA,EAAQA,kCAMxE,CAAE,MAAOoF,GAGT,CACF,CAyHS0Z,CAA2Brd,KAGlCyc,QAAQG,cAAcU,eAAiBtd,IAErC,GAAKoQ,EAEL,GAAW,IAAPpQ,EAAU,CAEZ,MAAMud,EAAazY,EAAae,aA5BtC6E,eAAiCgG,GAE/B,IACE,MAAM2G,QAAe/C,IAGfkD,QAA2B3G,UAE3B0G,EAAwBF,EAAQG,EAAoB9G,EAC5D,CAAE,MAAO/M,GAGT,CACF,CAiBW6Z,CAAkB,CAAEzE,qBAAsBwE,GACjD,MAEOR,EAA0B,iBAAkB,CAAEvL,iBAAkB,WAtPjEzB,GAEFA,EAA+BnG,SAEnC,CAAE,MAAOjG,GAGP,GAAIoM,EAAgC,CAClC,MAAM0N,EAAe9Z,aAAiBoI,MAAQpI,EAAMpF,QAAU6U,OAAOzP,GACrEoM,EAA+B3D,OAAOqR,EACxC,CACF,C,QACE1N,EAAiC,IAEnC,CACF,CACF,CAgCArF,eAAeqS,EAA0BP,EAAmB9L,GAE1D,IAAKN,EAAyB,OAE9B,GAAwB,IAApB7P,EAASsE,OAGX,kBADM6Y,KAKR,MAAMlG,QAA2B3G,IAE5B2G,GAAoB1G,gBASnBN,EAAwBgH,GAAoB1G,QAASJ,SAErDgN,KACR,CA6CAhT,eAAegT,KAIb,GADqB5Y,EAAakB,kBAOlC,IAGE,MAAM2X,EAAcxJ,iBAAiB,GAErC,IAAKwJ,GAAsC,IAAvBA,EAAY9Y,OAG9B,OAKF,MAAM+Y,EAASD,EAAY,GAAG5J,WAGxB8J,EAAc,GADJvP,KAAKnN,IAAI,EAAGyc,EAAS,MACHA,IAM5BE,EAAiB3J,gBAAgB0J,GAEvC,IAAKC,GAA4C,IAA1BA,EAAejZ,OAGpC,OAGF,IAAIkZ,GAAc,EAGlB,IAAK,IAAI5P,EAAI2P,EAAejZ,OAAS,EAAGsJ,GAAK,EAAGA,IAAK,CACnD,MAAM6P,EAAMF,EAAe3P,GAG3B,GAAiB,SAAb6P,EAAIb,KACN,SAIF,GAAuB,IAAnBa,EAAIjK,WAEN,MAIF,GAAIiK,EAAIzf,SAAWyf,EAAIzf,QAAQyE,SAAS,wBAAyB,CAC3Bgb,EAAIjK,WACxCgK,GAAc,EACd,KACF,CAG0CC,EAAIjK,WAAeiK,EAAIb,KACjE,MAAMc,EAAa,GAAGD,EAAIzf,sCAEpB6e,gBAAgB,CACpB,CACErJ,WAAYiK,EAAIjK,WAChBxV,QAAS0f,KAKbF,GAAc,EACd,KACF,CAKF,CAAE,MAAOpa,GAET,CAGF,CA4GAua,EAAE,KAEAjV,EAAezF,aACf2W,IAEAsC,QAAQG,cAAcuB,aAAc,KA3XpCpa,GAAiB,EAEjBkF,EAAeyC,mBAAmBgB,QAIlC0R,iBA0XA,MAAMC,EAAmBlU,YAAY,KAC9BsR,IACD5L,GACFhG,cAAcwU,IAGf,KAEH/B,WAAW,KACJzM,IACHhG,cAAcwU,GAGVtO,IACFA,EAA+B3D,OAAO,8CACtC2D,EAAiC,QAGpC,KAEHmO,EAAEhU,QAAQoU,GAAG,WAAY,KAGvBrV,EAAeyC,mBAAmBgB,mB","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/musicplayer/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","console.log('音乐播放器脚本8.3.4版本');\n\n// =================================================================\n// 0. 诊断工具 (Diagnostic Tools)\n// =================================================================\nimport { z, ZodError } from 'zod';\ndeclare global {\n  interface Window {\n    musicPlayerAPI: any;\n  }\n}\nconst SCRIPT_LOAD_TIME = performance.now();\n\nfunction logProbe(message: string, type: 'log' | 'warn' | 'error' | 'group' | 'groupCollapsed' | 'groupEnd' = 'log') {\n  const timestamp = `(T+${(performance.now() - SCRIPT_LOAD_TIME).toFixed(0)}ms)`;\n  const finalMessage = `${timestamp} ${message}`;\n\n  switch (type) {\n    case 'warn':\n      console.warn(finalMessage);\n      break;\n    case 'error':\n      console.error(finalMessage);\n      break;\n    case 'group':\n      console.group(finalMessage);\n      break;\n    case 'groupCollapsed':\n      console.groupCollapsed(finalMessage);\n      break;\n    case 'groupEnd':\n      console.groupEnd();\n      break;\n    default:\n      console.log(finalMessage);\n  }\n}\n\n// =================================================================\n// 1. 类型定义 (Type Definitions)\n// =================================================================\n\ntype PlaylistItem = {\n  url: string;\n  歌名: string;\n  歌手?: string;\n  封面?: string;\n};\n\ntype PlaylistConfig = {\n  id: string;\n  tracks: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n};\n\ntype QueueItem = {\n  // --- 核心标识与排序依据 ---\n  playlistId: string;\n  priority: number;\n\n  // --- 内容与规则 ---\n  playlistContent: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n\n  // --- 状态记忆 ---\n  currentIndex: number;\n  playedIndices: Set<number>;\n  playbackPlan?: number[];\n  planIndex?: number;\n  wasEverPlayed: boolean;\n\n  // --- 溯源信息 ---\n  triggeredBy: 'base' | 'mvu';\n  triggerSource?: z.infer<typeof ZodTriggerConfig>;\n};\n\ntype PlaybackMode = 'list' | 'single' | 'random';\n\ntype FullStatePayload = {\n  currentItem: { title: string; artist?: string; cover?: string } | null;\n  isPlaying: boolean;\n  playbackState: 'STOPPED' | 'PLAYING' | 'PAUSED';\n  playbackMode: PlaybackMode;\n  masterVolume: number;\n  playlist: { title: string; artist?: string; cover?: string }[];\n  isTransitioning: boolean;\n};\n\ntype TimeUpdatePayload = {\n  currentTime: number;\n  duration: number;\n};\n\ntype StrategyDecision = {\n  action: 'GoTo' | 'RemoveTopAndAdvance' | 'Restart' | 'DoNothing' | 'LoopReset' | 'Stop';\n  nextIndex?: number;\n};\n\ninterface IPlaybackStrategy {\n  onQueueChanged(currentItem: QueueItem | undefined): void;\n  advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision;\n  onTrackEnd(currentItem: QueueItem): StrategyDecision;\n  onPlaybackError(currentItem: QueueItem): StrategyDecision;\n}\n\n// =================================================================\n// 1.1. Zod 边界防御 Schemas (Zod Border Defense Schemas)\n// -----------------------------------------------------------------\n// 探针: 这些 schemas 不仅仅是类型，它们是主动的验证器，是我们系统的第一道防线。\n//       每一个 `required_error` 和 `message` 都是一个内置的探针，当外部数据\n//       不符合我们的“法律”时，它们会自动报告错误。\n// 原则: 单一事实来源 (SSoT) - 关于外部数据应该长什么样的“真相”，只由这里定义。\n// =================================================================\n\n// 世界书音轨配置 Schema\nexport const ZodTrackConfig = z\n  .object({\n    歌名: z.string().optional(),\n    歌手: z.string().optional(),\n    封面: z.string().url({ message: '封面URL格式无效' }).optional(),\n    url: z.string().url({ message: '音轨URL格式无效' }),\n  })\n  .strict();\n\n// 定义一个“单一条件”\nexport const ZodSingleCondition = z\n  .object({\n    variable_path: z.string(),\n    greater_than: z.number().optional(),\n    greater_than_or_equal_to: z.number().optional(),\n    less_than: z.number().optional(),\n    less_than_or_equal_to: z.number().optional(),\n    value: z.union([z.string(), z.number(), z.boolean()]).optional(),\n    value_contains: z.string().optional(),\n    time_in_range: z\n      .string()\n      .regex(/^\\d{2}:\\d{2}-\\d{2}:\\d{2}$/, {\n        message: '时间范围格式必须是 \"HH:MM-HH:MM\"',\n      })\n      .optional(),\n  })\n  .strict();\n\n// 主触发器 Schema 引用“单一条件”的数组\nexport const ZodTriggerConfig = z\n  .object({\n    type: z.literal('mvu_variable'),\n    playlist_id: z.string(),\n    priority: z.number().default(0),\n    conditions: z.array(ZodSingleCondition).nonempty({ message: '触发器必须至少包含一个条件' }),\n  })\n  .strict();\n\n// 世界书歌单配置 Schema\nexport const ZodPlaylistConfig = z.object({\n  id: z.string(),\n  onFinishRule: z.enum(['loop', 'pop'], { message: \"onFinishRule 必须是 'loop' 或 'pop'\" }).default('loop'),\n  tracks: z.array(ZodTrackConfig).nonempty({ message: \"歌单的 'tracks' 列表不能为空\" }),\n});\n\n// 世界书总配置 Schema (这是我们将使用的顶级验证器)\nexport const ZodWorldbookConfig = z\n  .object({\n    default_playlist_id: z.string().optional(),\n    playlists: z.array(ZodPlaylistConfig).optional(),\n    triggers: z.array(ZodTriggerConfig).optional(),\n  })\n  .strict();\n\n// 持久化状态 - 队列项 Schema\nexport const ZodQueueItemState = z.object({\n  playlistId: z.string(),\n  currentIndex: z.number().default(0),\n  playedIndices: z.array(z.number()).default([]),\n  wasEverPlayed: z.boolean().default(false),\n  triggerSource: ZodTriggerConfig.optional(),\n});\n\n// 持久化状态 - 总 Schema\nexport const ZodPersistedState = z.object({\n  active_queue: z.array(ZodQueueItemState),\n  mode: z.enum(['list', 'single', 'random']).default('list'),\n  volume: z.number().min(0).max(1).default(0.5),\n  last_active_swipe_id: z.number().nullable().default(null),\n  finished_base_playlists: z.array(z.string()).default([]),\n  previousMvuState: z.record(z.string(), z.any()).optional(),\n});\n\nconst STATE_KEY_MVU_HISTORY = '灰烬双星_MVU状态记忆';\n\n/**\n * [工具函数] 将多种格式的时间字符串解析为从午夜开始的分钟数。\n * 它的职责单一，且对输入格式有很强的容错能力。\n * @param timeStr - 例如 \"14:30\", \"8时5分\", \"22 : 00\"\n * @returns {number | null} 转换后的分钟数，或在无法解析时返回 null。\n */\nfunction _parseTimeToMinutes(timeStr: string): number | null {\n  // 探针: 记录传入的原始值，便于调试\n  if (!timeStr || typeof timeStr !== 'string') return null;\n\n  // 步骤1: 归一化输入，处理常见变体 (已修正 let -> const 和 replace 语法)\n  const cleanStr: string = timeStr.trim().replace('：', ':');\n\n  let match;\n\n  // 步骤2: 尝试匹配 \"HH:MM\" 格式 (最常见)\n  match = cleanStr.match(/^(\\d{1,2})\\s*:\\s*(\\d{1,2})$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    // 严格校验数值范围\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 步骤3: 尝试匹配 \"H时M分\" 格式\n  match = cleanStr.match(/^(\\d{1,2})\\s*时\\s*(\\d{1,2})\\s*分?$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 探针: 如果所有格式都匹配失败，记录下来\n  logProbe(`[TimeParser] 无法解析时间字符串: \"${timeStr}\"`, 'warn');\n\n  // [新增] 修复“缺少 return”的逻辑漏洞\n  return null;\n}\n\n// =================================================================\n// 2. MVU 管理器 (The MvuManager - \"The Analyst\")\n// =================================================================\nconst MvuManager = (() => {\n  logProbe('[MvuManager] 模块正在初始化...');\n\n  let _previousMvuState: Record<string, any> = {};\n\n  /**\n   * [核心算法 V2.1] 检查一个给定的 stat_data 是否满足一个触发器的所有条件。\n   * 新版已加固，支持多种匹配模式和 AND 条件组合，且代码风格已优化。\n   */\n  function _checkTriggerCondition(\n    trigger: z.infer<typeof ZodTriggerConfig>,\n    statData: Record<string, any> | null,\n  ): boolean {\n    if (!statData) return false;\n\n    // 遍历所有 AND 条件。只要有一个不满足，整个触发器就失败。\n    for (const condition of trigger.conditions) {\n      const currentValue = _.get(statData, condition.variable_path);\n\n      let conditionMet = false; // 当前条件是否满足\n      let isHandled = false; // 当前条件是否被任何一个匹配模式处理过\n\n      // 使用 if / else if 链条，确保每个条件项只采用一种匹配模式\n      if (condition.value_contains !== undefined) {\n        isHandled = true;\n        // [安全加固] 必须检查 currentValue 是字符串，否则 .includes() 会导致崩溃\n        if (typeof currentValue === 'string' && currentValue.includes(condition.value_contains)) {\n          conditionMet = true;\n        }\n      } else if (condition.time_in_range !== undefined) {\n        isHandled = true;\n        // [安全加固] 同样检查类型\n        if (typeof currentValue === 'string') {\n          const currentTimeInMinutes = _parseTimeToMinutes(currentValue);\n\n          if (currentTimeInMinutes !== null) {\n            const [startStr, endStr] = condition.time_in_range.split('-');\n            const startMinutes = _parseTimeToMinutes(startStr);\n            const endMinutes = _parseTimeToMinutes(endStr);\n\n            if (startMinutes !== null && endMinutes !== null) {\n              // [代码风格修正] 移除不必要的嵌套 if，使代码更简洁\n              if (startMinutes <= endMinutes) {\n                // 普通范围\n                conditionMet = currentTimeInMinutes >= startMinutes && currentTimeInMinutes <= endMinutes;\n              } else {\n                // 跨天范围\n                conditionMet = currentTimeInMinutes >= startMinutes || currentTimeInMinutes <= endMinutes;\n              }\n            }\n          }\n        }\n      } else if (condition.value !== undefined) {\n        isHandled = true;\n        if (currentValue === condition.value) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue > condition.greater_than) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue >= condition.greater_than_or_equal_to) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue < condition.less_than) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue <= condition.less_than_or_equal_to) {\n          conditionMet = true;\n        }\n      }\n\n      // [最终裁决] 如果这是一个空条件 (isHandled=false)，或条件不满足，则立即失败\n      if (!isHandled || !conditionMet) {\n        return false;\n      }\n    }\n\n    // 如果循环正常结束，说明所有 AND 条件都满足\n    return true;\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    checkTriggerCondition: _checkTriggerCondition,\n\n    /**\n     * [生命周期] 从酒馆变量中读取并恢复上一次的 MVU 状态。\n     */\n    initialize() {\n      logProbe('[MvuManager] (Lifecycle) 执行 initialize...');\n      try {\n        const savedState = getVariables({ type: 'chat' })[STATE_KEY_MVU_HISTORY];\n        if (savedState && typeof savedState === 'object') {\n          _previousMvuState = savedState;\n          logProbe('[MvuManager] 成功从存档中恢复了 MVU 历史状态。');\n        } else {\n          _previousMvuState = {};\n          logProbe('[MvuManager] 未发现有效的 MVU 历史存档，已初始化为空状态。', 'warn');\n        }\n      } catch (error) {\n        logProbe(`[MvuManager] 初始化时读取存档失败: ${error}`, 'error');\n        _previousMvuState = {};\n      }\n    },\n\n    resetState() {\n      logProbe('[MvuManager] (Lifecycle) 正在重置模块内部状态...');\n      _previousMvuState = {};\n      logProbe('[MvuManager] 模块状态已重置。');\n    },\n\n    /**\n     * [命令] 将当前的 MVU 状态持久化到酒馆变量中。\n     * @param currentStateData - 最新的 stat_data 对象。\n     */\n    async persistCurrentState(currentStateData: Record<string, any>) {\n      if (!isScriptActive) {\n        logProbe('[MvuManager] 持久化操作被阻止，因为脚本正在停机。', 'warn');\n        return;\n      }\n      logProbe('[MvuManager] (Command) 执行 persistCurrentState...');\n      _previousMvuState = _.cloneDeep(currentStateData);\n      try {\n        await updateVariablesWith(\n          vars => {\n            vars[STATE_KEY_MVU_HISTORY] = _previousMvuState;\n            return vars;\n          },\n          { type: 'chat' },\n        );\n        logProbe('[MvuManager] 已成功将当前 MVU 状态持久化。');\n      } catch (error) {\n        logProbe(`[MvuManager] 持久化 MVU 状态时发生严重错误: ${error}`, 'error');\n      }\n    },\n\n    /**\n     * [查询] 获取内存中存储的上一次的 MVU 状态。\n     */\n    getPreviousState: () => _.cloneDeep(_previousMvuState),\n\n    /**\n     * [核心查询] 计算新旧状态之间的“边沿变化”。\n     * @param previousStateData - 上一次的 stat_data。\n     * @param currentStateData - 最新的 stat_data。\n     * @param allTriggers - 从世界书解析出的所有有效触发器。\n     * @returns 报告对象，包含新激活和新失效的触发器列表。\n     */\n    calculateChangeReport(\n      previousStateData: Record<string, any>,\n      currentStateData: Record<string, any>,\n      allTriggers: z.infer<typeof ZodTriggerConfig>[],\n    ): {\n      newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n    } {\n      const report: {\n        newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n        newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      } = { newlyActiveTriggers: [], newlyInactiveTriggers: [] };\n\n      logProbe('[MvuManager] (Query) 正在计算状态变化报告 (\"边沿检测\")...', 'group');\n\n      logProbe('[Probe] 正在审查用于对比的新旧状态数据:');\n      console.log('上一份历史记忆 (previousStateData):');\n      console.dir(_.cloneDeep(previousStateData));\n      console.log('当前权威状态 (currentStateData):');\n      console.dir(_.cloneDeep(currentStateData));\n      // =======================================================\n\n      for (const trigger of allTriggers) {\n        const wasMet = _checkTriggerCondition(trigger, previousStateData);\n        const isMet = _checkTriggerCondition(trigger, currentStateData);\n\n        if (!wasMet && isMet) {\n          logProbe(`(探針) 新激活的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyActiveTriggers.push(trigger);\n        } else if (wasMet && !isMet) {\n          logProbe(`(探針) 新失效的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyInactiveTriggers.push(trigger);\n        }\n      }\n      logProbe(\n        `报告生成完毕: ${report.newlyActiveTriggers.length} 个新激活, ${report.newlyInactiveTriggers.length} 个新失效。`,\n      );\n      logProbe('', 'groupEnd');\n      return report;\n    },\n  };\n\n  logProbe('[MvuManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2. 状态管理器 (The State Manager) - [V2.0 重构版]\n// =================================================================\nconst StateManager = (() => {\n  logProbe('[StateManager] 模块正在初始化 (优先级队列内核)...');\n\n  // -------------------\n  // 2.1. 私有状态 (Private State)\n  // -------------------\n  // [重构] 核心数据结构变更为优先级队列\n  let _activePlaylistQueue: QueueItem[] = [];\n  let _lastActiveSwipeId: number | null = null;\n  let _finishedBasePlaylists: Set<string> = new Set();\n  let _playbackMode: PlaybackMode = 'list';\n  let _masterVolume: number = 0.5;\n  let _playbackState: 'STOPPED' | 'PLAYING' | 'PAUSED' = 'STOPPED';\n  let _isPerformingEffect: boolean = false;\n\n  // -------------------\n  // 2.2. 私有核心算法 (Private Core Algorithms)\n  // -------------------\n  function _applyDepartureIsHistoryPrinciple(item: QueueItem, departingIndex: number) {\n    if (typeof departingIndex !== 'number' || departingIndex < 0) return;\n    item.playedIndices.add(departingIndex);\n  }\n\n  // -------------------\n  // 2.3. 公共接口 (Public API)\n  // -------------------\n  const publicAPI = {\n    // --- 基础状态查询 ---\n    getPlaybackMode: () => _playbackMode,\n    getVolume: () => _masterVolume,\n    // [兼容性] 旧接口，仅当状态明确为 PLAYING 时返回 true\n    isPlaying: () => _playbackState === 'PLAYING',\n    getPlaybackState: () => _playbackState,\n    isPerformingEffect: () => _isPerformingEffect,\n\n    // --- [重构] 队列核心查询 ---\n    /**\n     * 获取当前优先级最高的歌单项（队首）。\n     * 这是系统唯一的事实来源：当前应该播放什么。\n     */\n    getTopQueueItem: (): QueueItem | undefined => _.cloneDeep(_activePlaylistQueue[0]),\n\n    /**\n     * 获取整个队列的副本（用于调试或决策分析）。\n     */\n    getQueue: (): QueueItem[] => _.cloneDeep(_activePlaylistQueue),\n\n    // --- 状态快照 ---\n    getStateSnapshotForRuntime: () => {\n      return _.cloneDeep({\n        active_queue: _activePlaylistQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        // [兼容性] 同时提供布尔值和枚举值\n        isPlaying: _playbackState === 'PLAYING',\n        playbackState: _playbackState,\n        isPerformingEffect: _isPerformingEffect,\n      });\n    },\n\n    getStateSnapshotForPersistence() {\n      const runtimeQueue = _.cloneDeep(_activePlaylistQueue);\n\n      const persistentQueue = runtimeQueue.map(item => {\n        const persistedItem = _.omit(item, ['playbackPlan', 'planIndex', 'playlistContent']);\n\n        return {\n          ...persistedItem,\n          // 将 Set 转换为 Array 以便 JSON 序列化\n          playedIndices: Array.from(item.playedIndices),\n        };\n      });\n\n      return {\n        active_queue: persistentQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        last_active_swipe_id: _lastActiveSwipeId,\n        finished_base_playlists: Array.from(_finishedBasePlaylists),\n      };\n    },\n\n    // --- 生命周期管理 ---\n    resetState() {\n      logProbe('[StateManager] 正在硬性重置所有状态...', 'warn');\n      _activePlaylistQueue = [];\n      _playbackMode = 'list';\n      _masterVolume = 0.5;\n      _playbackState = 'STOPPED';\n      _isPerformingEffect = false;\n      _lastActiveSwipeId = null;\n      _finishedBasePlaylists.clear();\n    },\n\n    loadState(stateToLoad: any) {\n      logProbe('[StateManager] 正在加载状态...', 'group');\n      _playbackMode = stateToLoad.mode;\n      _masterVolume = stateToLoad.volume;\n      _activePlaylistQueue = stateToLoad.active_queue || [];\n      _lastActiveSwipeId = stateToLoad.last_active_swipe_id ?? null;\n      _finishedBasePlaylists = new Set(stateToLoad.finished_base_playlists || []);\n      logProbe(\n        `(探针) 记忆加载完成: 上次SwipeID=${_lastActiveSwipeId}, 已完结基础歌单数=${_finishedBasePlaylists.size}`,\n      );\n      logProbe(\n        `状态加载完成. 队列深度: ${_activePlaylistQueue.length}, 模式: ${_playbackMode}, 音量: ${_masterVolume}`,\n      );\n      logProbe('', 'groupEnd');\n    },\n\n    // --- 基础状态设置 ---\n    setPlaybackMode: (mode: PlaybackMode) => {\n      _playbackMode = mode;\n    },\n    setVolume: (volume: number) => {\n      _masterVolume = volume;\n    },\n    setPlaybackState: (newState: 'STOPPED' | 'PLAYING' | 'PAUSED') => {\n      // [探针] 状态变更日志，帮助我们追踪每一次状态跳变\n      if (_playbackState !== newState) {\n        logProbe(`[StateManager] 状态流转: ${_playbackState} -> ${newState}`);\n      }\n      _playbackState = newState;\n    },\n    setPerformingEffect: (isPerforming: boolean) => {\n      _isPerformingEffect = isPerforming;\n    },\n\n    getLastActiveSwipeId: () => _lastActiveSwipeId,\n    setLastActiveSwipeId: (id: number | null) => {\n      _lastActiveSwipeId = id;\n    },\n\n    getFinishedBasePlaylists: () => new Set(_finishedBasePlaylists),\n\n    addToFinishedBasePlaylists: (playlistId: string) => {\n      logProbe(`[StateManager]将基础歌单 \"${playlistId}\" 刻入已完成列表。`);\n      _finishedBasePlaylists.add(playlistId);\n    },\n\n    clearFinishedBasePlaylists: () => {\n      logProbe(`[StateManager]清空记录。`);\n      _finishedBasePlaylists.clear();\n    },\n\n    // --- [重构] 队列核心操作 ---\n    /**\n     * [核心] 更新整个队列。\n     * 此方法会自动按优先级降序排列队列，确保 _activePlaylistQueue[0] 永远是优先级最高的。\n     */\n    updateQueue(newQueue: QueueItem[]) {\n      logProbe(`[StateManager] (Command) updateQueue: 正在更新并重排序队列 (共 ${newQueue.length} 项)...`);\n\n      _activePlaylistQueue = _.cloneDeep(newQueue).sort((a, b) => b.priority - a.priority);\n\n      if (_activePlaylistQueue.length > 0) {\n        logProbe(\n          `(探针) 新队首: \"${_activePlaylistQueue[0].playlistId}\" (优先级: ${_activePlaylistQueue[0].priority})`,\n        );\n      } else {\n        logProbe(`(探针) 队列现已为空。`);\n      }\n    },\n\n    // --- 当前项操作 (作用于队首) ---\n    setCurrentIndex(index: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n        currentItem.currentIndex = index;\n      }\n    },\n\n    commitNavigationStep(newTrackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n\n      if (_playbackMode === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(newTrackIndex);\n        if (newPlanIndex !== -1) {\n          currentItem.planIndex = newPlanIndex;\n        }\n      }\n      currentItem.currentIndex = newTrackIndex;\n    },\n\n    clearHistoryForCurrentItem() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) currentItem.playedIndices.clear();\n    },\n\n    resetCurrentItemForLoop() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playedIndices.clear();\n        currentItem.currentIndex = 0;\n      }\n    },\n\n    commitGenesisState(newCurrentIndex: number, newPlaybackPlan: number[], newPlanIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.currentIndex = newCurrentIndex;\n        currentItem.playbackPlan = newPlaybackPlan;\n        currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    userInitiatedJump(trackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem || trackIndex === currentItem.currentIndex) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n      currentItem.currentIndex = trackIndex;\n\n      if (this.getPlaybackMode() === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(trackIndex);\n        if (newPlanIndex !== -1) currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    clearRandomModePlan() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = undefined;\n        currentItem.planIndex = undefined;\n      }\n    },\n\n    applyNewPlaybackPlan(plan: number[], planIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = plan;\n        currentItem.planIndex = planIndex;\n      }\n    },\n  };\n\n  logProbe('[StateManager] 模块初始化完成 (V2.0 内核)。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.1. 播放引擎 (The Playback Engine)\n// =================================================================\nconst PlaybackEngine = (() => {\n  logProbe('[PlaybackEngine] 模块正在初始化...');\n  let _playerA: HTMLAudioElement | null = null;\n  let _playerB: HTMLAudioElement | null = null;\n  let _activePlayer: HTMLAudioElement | null = null;\n  let _standbyPlayer: HTMLAudioElement | null = null;\n  let _fadeInterval: number | null = null;\n  const FADE_DURATION = 400;\n\n  // --- 私有函数 ---\n  function _swapPlayers() {\n    [_activePlayer, _standbyPlayer] = [_standbyPlayer, _activePlayer];\n  }\n\n  function _fadeVolumeAsync(player: HTMLAudioElement | null, targetVolume: number, duration: number): Promise<void> {\n    return new Promise(resolve => {\n      if (_fadeInterval) {\n        clearInterval(_fadeInterval);\n        _fadeInterval = null;\n      }\n\n      if (!player) return resolve();\n\n      const startVolume = player.volume;\n      const stepTime = 50;\n      const steps = duration / stepTime;\n      if (steps <= 0) {\n        player.volume = targetVolume;\n        return resolve();\n      }\n      const volumeStep = (targetVolume - startVolume) / steps;\n      let currentStep = 0;\n\n      _fadeInterval = window.setInterval(() => {\n        currentStep++;\n        if (currentStep >= steps) {\n          if (_fadeInterval) clearInterval(_fadeInterval);\n          _fadeInterval = null;\n          player.volume = targetVolume;\n          resolve();\n        } else {\n          player.volume += volumeStep;\n        }\n      }, stepTime);\n    });\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    initialize() {\n      if (_playerA && _playerB) return;\n      logProbe('[Engine] 正在创建和配置 HTML5 Audio 元素...');\n      const createPlayer = (): HTMLAudioElement => {\n        const audio = new Audio();\n        audio.preload = 'auto';\n        audio.crossOrigin = 'anonymous';\n        audio.addEventListener('ended', () => {\n          if (audio === _activePlayer) void _handleTrackEnded();\n        });\n        audio.addEventListener('error', () => {\n          /* 错误由 Promise reject 处理 */\n        });\n        audio.addEventListener('timeupdate', broadcastTimeUpdate);\n        return audio;\n      };\n      _playerA = createPlayer();\n      _playerB = createPlayer();\n      _activePlayer = _playerA;\n      _standbyPlayer = _playerB;\n      logProbe('[Engine] Audio 元素已就绪。');\n    },\n\n    getActivePlayer: () => _activePlayer,\n    getStandbyPlayer: () => _standbyPlayer,\n\n    async transitionToTrack(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine] 收到过渡请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n\n      if (!_standbyPlayer || !_activePlayer) {\n        logProbe('[Engine] 过渡中止：播放器实例尚未初始化。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('播放器实例尚未初始化');\n      }\n\n      const standbyPlayer = _standbyPlayer;\n      const activePlayer = _activePlayer;\n\n      standbyPlayer.src = targetTrackUrl;\n      standbyPlayer.load();\n\n      try {\n        await new Promise<void>((resolve, reject) => {\n          const onCanPlay = () => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe('[Engine] 备用播放器加载成功 (canplaythrough)。', 'log');\n            resolve();\n          };\n\n          const onError = (e: Event) => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe(`[Engine] 备用播放器加载失败!`, 'error');\n            const target = e.target as HTMLAudioElement;\n            const error = target.error;\n            reject(new Error(`音频加载失败: ${error?.message || '未知错误'}`));\n          };\n          standbyPlayer.addEventListener('canplaythrough', onCanPlay);\n          standbyPlayer.addEventListener('error', onError);\n        });\n      } catch (error) {\n        logProbe('[Engine] 过渡因加载失败而中止。', 'groupEnd');\n        throw error;\n      }\n\n      await _fadeVolumeAsync(activePlayer, 0, 500);\n      activePlayer.pause();\n\n      _swapPlayers();\n\n      const newActivePlayer = this.getActivePlayer();\n      if (!newActivePlayer) throw new Error('播放器实例在交换后丢失');\n\n      const playPromise = newActivePlayer.play();\n      if (playPromise) {\n        await playPromise;\n      }\n      await _fadeVolumeAsync(newActivePlayer, targetVolume, 500);\n\n      logProbe('[Engine] 过渡成功完成。', 'groupEnd');\n    },\n\n    async fadeOutAndPause(): Promise<void> {\n      logProbe('[Engine] 命令: FadeOutAndPause');\n      await _fadeVolumeAsync(_activePlayer, 0, FADE_DURATION);\n      _activePlayer?.pause();\n    },\n\n    async executeHardCut(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine:HardCut] 收到“瞬击”请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n      const activePlayer = this.getActivePlayer();\n      if (!activePlayer) {\n        logProbe('[Engine:HardCut] 致命错误：无可用播放器实例。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('No active player available for hard cut.');\n      }\n\n      logProbe(`(探针) 切换前 src: ${activePlayer.src.slice(-50)}`);\n\n      activePlayer.pause();\n      activePlayer.src = targetTrackUrl;\n      activePlayer.volume = targetVolume;\n\n      logProbe(`(探针) 切换后 src: ${activePlayer.src.slice(-50)}`);\n\n      try {\n        const playPromise = activePlayer.play();\n        if (playPromise) {\n          await playPromise;\n        }\n\n        StateManager.setPlaybackState('PLAYING');\n        logProbe('[Engine:HardCut] “瞬击”播放成功。');\n      } catch (error) {\n        logProbe(`[Engine:HardCut] “瞬击”播放失败! 这通常是因为用户未与页面交互。`, 'error');\n\n        StateManager.setPlaybackState('STOPPED');\n\n        throw error;\n      } finally {\n        logProbe('', 'groupEnd');\n      }\n    },\n\n    async resumeAndFadeIn(targetVolume: number): Promise<void> {\n      logProbe('[Engine] 命令: ResumeAndFadeIn');\n      const playPromise = _activePlayer?.play();\n      if (playPromise) await playPromise;\n      await _fadeVolumeAsync(_activePlayer, targetVolume, FADE_DURATION);\n    },\n  };\n\n  logProbe('[PlaybackEngine] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.2. 播放策略实现 (Playback Strategies)\n// =================================================================\n\nclass ListStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 advance 请求. 方向: ${direction}, 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    if (direction === 'next') {\n      logProbe('[Strategy:List] 决策: advance(next) -> 委托给 onTrackEnd');\n      return this.onTrackEnd(currentItem);\n    }\n\n    const { currentIndex, onFinishRule, playlistContent } = currentItem;\n    const totalTracks = playlistContent.length;\n\n    if (currentIndex > 0) {\n      const nextIndex = currentIndex - 1;\n      logProbe(`[Strategy:List] 决策: advance(prev) -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'loop') {\n      const lastIndex = totalTracks > 0 ? totalTracks - 1 : 0;\n      logProbe(`[Strategy:List] 决策: advance(prev) at start -> Loop to end (index: ${lastIndex})`);\n      return { action: 'GoTo', nextIndex: lastIndex };\n    } else {\n      logProbe('[Strategy:List] 决策: advance(prev) at start -> Restart');\n      return { action: 'Restart' };\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 onTrackEnd 请求. 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    const { currentIndex, onFinishRule, playlistContent, playedIndices } = currentItem;\n    const totalTracks = playlistContent.length;\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex < totalTracks) {\n      logProbe(`[Strategy:List] 决策: onTrackEnd -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'pop') {\n      logProbe('[Strategy:List] 决策: onTrackEnd at end -> PopStack');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      const totalValidTracks = playlistContent.length;\n      const historySizeAfterThisTrack = playedIndices.size + 1;\n\n      if (historySizeAfterThisTrack >= totalValidTracks) {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> LoopReset (一个完整的循环已结束)`, 'warn');\n        return { action: 'LoopReset' };\n      } else {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> GoTo (普通循环，继续播放未听过的歌曲)`);\n        return { action: 'GoTo', nextIndex: 0 };\n      }\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:List] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\nclass SingleStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(_currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 advance 请求. 方向: ${direction}. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onTrackEnd(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onTrackEnd 请求. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onPlaybackError(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onPlaybackError 请求。决策: Stop (单曲循环下无法自动前进)`);\n    return { action: 'Stop' };\n  }\n}\n\nclass RandomStrategy implements IPlaybackStrategy {\n  private _generateIntelligentShuffle(\n    allTrackIndices: number[],\n    playedIndices: Set<number>,\n    currentIndex: number,\n  ): number[] {\n    logProbe(`[Strategy:Random] (Algo) _generateIntelligentShuffle 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: allIndices.length=${allTrackIndices.length}, playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}`,\n    );\n\n    const sourceForShuffle = allTrackIndices.filter(i => !playedIndices.has(i) && i !== currentIndex);\n    logProbe(`计算待选池 (sourceForShuffle) 大小: ${sourceForShuffle.length}`);\n\n    for (let i = sourceForShuffle.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [sourceForShuffle[i], sourceForShuffle[j]] = [sourceForShuffle[j], sourceForShuffle[i]];\n    }\n\n    logProbe(`洗牌完成. 输出 shuffledIndices (纯粹的未来队列): [${sourceForShuffle.join(', ')}]`);\n    logProbe('', 'groupEnd');\n    return sourceForShuffle;\n  }\n\n  private _generatePlaybackPlan(\n    playedIndices: Set<number>,\n    currentIndex: number,\n    shuffledIndices: number[],\n  ): { playbackPlan: number[]; planIndex: number } {\n    logProbe(`[Strategy:Random] (Algo) _generatePlaybackPlan 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}, shuffledIndices.length=${shuffledIndices.length}`,\n    );\n\n    const knownSequence = Array.from(new Set([...playedIndices, currentIndex]));\n    const planIndex = knownSequence.indexOf(currentIndex);\n    const playbackPlan = [...knownSequence, ...shuffledIndices];\n\n    logProbe(`(守护者探针) \"已知序列\" (unique history + current): [${knownSequence.join(', ')}]`);\n    logProbe(`生成导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n    logProbe(`定位导航指针 (planIndex): ${planIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { playbackPlan, planIndex };\n  }\n\n  private _handlePlanEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] (Helper) _handlePlanEnd: 已到达计划终点，开始进行边界决策...`, 'groupCollapsed');\n    logProbe(`(探针) 待决策歌单: \"${currentItem.playlistId}\", 结束规则: \"${currentItem.onFinishRule}\"`);\n\n    if (currentItem.onFinishRule === 'pop') {\n      logProbe(`(边界决策) onFinishRule 为 'pop'，决策 -> PopStack`);\n      logProbe('', 'groupEnd');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      logProbe(`(边界决策) onFinishRule 为 'loop'，决策 -> LoopReset`);\n      logProbe('', 'groupEnd');\n      return { action: 'LoopReset' };\n    }\n  }\n\n  public onQueueChanged(currentItem: QueueItem | undefined): void {\n    if (!currentItem) {\n      logProbe('[Strategy:Random] onQueueChanged 中止：无有效的当前项。');\n      return;\n    }\n\n    logProbe(\n      `[Strategy:Random] onQueueChanged 已触发 (连续性恢复)，将为歌单 \"${currentItem.playlistId}\" 生成播放计划...`,\n    );\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    const shuffled = this._generateIntelligentShuffle(allIndices, currentItem.playedIndices, currentItem.currentIndex);\n    const { playbackPlan, planIndex } = this._generatePlaybackPlan(\n      currentItem.playedIndices,\n      currentItem.currentIndex,\n      shuffled,\n    );\n\n    StateManager.applyNewPlaybackPlan(playbackPlan, planIndex);\n  }\n\n  public prepareGenesis(currentItem: QueueItem | undefined): {\n    newCurrentIndex: number;\n    newPlaybackPlan: number[];\n    newPlanIndex: number;\n  } | null {\n    if (!currentItem || !currentItem.playlistContent) {\n      logProbe('[Strategy:Random] prepareGenesis 中止：传入的队列项无效。', 'error');\n      return null;\n    }\n\n    logProbe('[Strategy:Random] (Query) prepareGenesis: 收到“创世乐谱”谱写请求...', 'group');\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    for (let i = allIndices.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];\n    }\n\n    const newPlaybackPlan = allIndices;\n    const newPlanIndex = 0;\n    const newCurrentIndex = newPlaybackPlan[newPlanIndex];\n\n    logProbe(`(乐谱) 谱写完成。New CurrentIndex: ${newCurrentIndex}, New PlanIndex: ${newPlanIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { newCurrentIndex, newPlaybackPlan, newPlanIndex };\n  }\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 advance 请求. 方向: ${direction}`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'DoNothing' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    if (direction === 'next') {\n      const nextPlanIndex = planIndex + 1;\n\n      if (nextPlanIndex < playbackPlan.length) {\n        const targetTrackIndex = playbackPlan[nextPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(next) -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe('[Strategy:Random] advance(next) 已到达计划终点，委托给 _handlePlanEnd...');\n        logProbe('', 'groupEnd');\n        return this._handlePlanEnd(currentItem);\n      }\n    } else {\n      // direction === 'prev'\n      const prevPlanIndex = planIndex - 1;\n\n      if (prevPlanIndex >= 0) {\n        const targetTrackIndex = playbackPlan[prevPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(prev) -> GoTo (新 planIndex: ${prevPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe(`[Strategy:Random] 决策: advance(prev) 已在计划起点。返回 DoNothing。`);\n        logProbe('', 'groupEnd');\n        return { action: 'DoNothing' };\n      }\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onTrackEnd 请求.`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。返回 Stop 以策安全。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'Stop' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    const nextPlanIndex = planIndex + 1;\n\n    if (nextPlanIndex < playbackPlan.length) {\n      const targetTrackIndex = playbackPlan[nextPlanIndex];\n      logProbe(\n        `[Strategy:Random] 决策: onTrackEnd -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n      );\n      logProbe('', 'groupEnd');\n      return { action: 'GoTo', nextIndex: targetTrackIndex };\n    } else {\n      logProbe('[Strategy:Random] onTrackEnd 已到达计划终点，委托给 _handlePlanEnd...');\n      logProbe('', 'groupEnd');\n      return this._handlePlanEnd(currentItem);\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\n// =================================================================\n// 2.3. 策略管理器 (The StrategyManager - \"The Conductor\")\n// =================================================================\nconst StrategyManager = (() => {\n  logProbe('[StrategyManager] 模块正在初始化...');\n\n  const _strategies: Record<PlaybackMode, IPlaybackStrategy> = {\n    list: new ListStrategy(),\n    single: new SingleStrategy(),\n    random: new RandomStrategy(),\n  };\n  let _currentStrategy: IPlaybackStrategy = _strategies.list;\n\n  const publicAPI = {\n    /**\n     * [命令] 设置新的播放模式，并自动切换到对应的策略实例。\n     */\n    setMode(mode: PlaybackMode) {\n      logProbe(`[StrategyManager] (Command) setMode: 切换策略模式为 -> ${mode}`);\n      _currentStrategy = _strategies[mode];\n    },\n\n    /**\n     * [查询] 获取当前激活的策略实例。这是我们遵循CQS原则的体现。\n     */\n    getCurrentStrategy: () => _currentStrategy,\n\n    /**\n     * [命令] 通知当前策略：核心状态（如队列）已发生重大变化。\n     * 这是修复BUG的核心，它为策略提供了一个统一的生命周期钩子。\n     */\n\n    notifyQueueChanged() {\n      logProbe(\n        `[StrategyManager] (Command) notifyQueueChanged: 正在通知当前策略 (${_currentStrategy.constructor.name}) 队列已变更...`,\n        'groupCollapsed',\n      );\n      const currentItem = StateManager.getTopQueueItem();\n      _currentStrategy.onQueueChanged(currentItem);\n      logProbe('[StrategyManager] 通知完成。', 'groupEnd');\n    },\n  };\n\n  logProbe('[StrategyManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 3. 全局变量与常量 (Global Variables & Constants)\n// =================================================================\n\nconst STATE_KEY = '余烬双星_播放器状态';\n\nlet isInitializedForThisChat = false;\nlet isReconciling = false;\nlet _initializationPromiseControls: { resolve: () => void; reject: (reason?: any) => void } | null = null;\n\nlet _initializationPromise: Promise<void> | null = null;\nlet isScriptActive = true;\nlet allPlaylists: Record<string, PlaylistConfig> = {};\nlet triggers: z.infer<typeof ZodTriggerConfig>[] = [];\nlet defaultPlaylistId: string | undefined = '';\n\nlet isMvuIntegrationActive = false;\nlet isCorePlayerInitialized = false;\nlet _currentChatId: string | number | null = null;\n\nconst fullStateUpdateCallbacks: ((payload: FullStatePayload) => void)[] = [];\nconst timeUpdateCallbacks: ((payload: TimeUpdatePayload) => void)[] = [];\n\n/**\n * [V9.0 统一校准官] 新架构的“运行时大脑”。\n * 它的单一职责是：响应“运行时”的增量事件，通过“边沿检测”模型，\n * 精确地、最小化地修改当前队列，并决策是否需要变更播放。\n * @param eventPayload - 可选的、来自 MVU 事件的最新状态数据。\n */\nasync function _reconcilePlaylistQueue(eventPayload?: any, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  // --- 1. 【前置检查】: 防止并发的事件风暴 ---\n  if (isReconciling) {\n    logProbe('[Reconciler] 请求被合并：前一个校准任务仍在进行中。', 'warn');\n    return;\n  }\n  isReconciling = true;\n  logProbe('=== [Reconciler] “统一校准官”已接管运行时事件 ===', 'group');\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe('[Reconciler] (事务) 已上效果锁并广播“过渡中”状态，UI应进入等待。');\n    broadcastFullState();\n\n    // --- 核心逻辑 (原有的 try...finally 块) ---\n    try {\n      const oldTopItem = StateManager.getTopQueueItem();\n\n      // --- 2. 【获取事实】: 遵循“时序悖论”定律 ---\n      const currentStateData = eventPayload?.stat_data\n        ? eventPayload.stat_data\n        : ((await _findLatestAuthoritativeMvuState())?.mvuData?.stat_data ?? {});\n\n      logProbe(`[Reconciler] (探针) 已确定本次校准的权威 MVU 状态 (来源: ${eventPayload ? '事件载荷' : '主动查询'})。`);\n\n      // --- 3. 【生成报告】: 委托 MvuManager 进行边沿检测 ---\n      const previousStateData = MvuManager.getPreviousState();\n      const changeReport = MvuManager.calculateChangeReport(previousStateData, currentStateData, triggers);\n\n      // --- 4. 【执行队列的增量修改】: 先减后加 ---\n      const newQueue = StateManager.getQueue();\n\n      if (changeReport.newlyInactiveTriggers.length > 0) {\n        _.remove(newQueue, item =>\n          changeReport.newlyInactiveTriggers.some(inactiveTrigger =>\n            areTriggersFunctionallyEqual(item.triggerSource, inactiveTrigger),\n          ),\n        );\n        logProbe(`[Reconciler] (修改) 根据报告移除了 ${changeReport.newlyInactiveTriggers.length} 个失效项。`);\n      }\n\n      if (changeReport.newlyActiveTriggers.length > 0) {\n        for (const activeTrigger of changeReport.newlyActiveTriggers) {\n          if (\n            newQueue.some(item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, activeTrigger))\n          ) {\n            logProbe(`[Reconciler] (防御) 拒绝添加重复的激活项: \"${activeTrigger.playlist_id}\"`, 'warn');\n            continue;\n          }\n          const newItem = createQueueItem({\n            type: 'mvu',\n            playlistId: activeTrigger.playlist_id,\n            trigger: activeTrigger,\n          });\n          if (newItem) {\n            newQueue.push(newItem);\n            logProbe(`[Reconciler] (修改) 根据报告添加了新激活项: \"${newItem.playlistId}\"`);\n          }\n        }\n      }\n\n      StateManager.updateQueue(newQueue);\n\n      // --- 5. 【决策与执行】: 对比新旧队首 ---\n      const newTopItem = StateManager.getTopQueueItem();\n\n      if (newTopItem?.playlistId !== oldTopItem?.playlistId) {\n        logProbe(\n          `[Reconciler] (决策) 队首发生变更！ 从 \"${oldTopItem?.playlistId ?? '无'}\" 变为 \"${newTopItem?.playlistId ?? '无'}\"。`,\n        );\n\n        if (newTopItem) {\n          logProbe('[Reconciler] (握手) 正在通知 StrategyManager 队列已变更...');\n          StrategyManager.notifyQueueChanged();\n\n          newTopItem.wasEverPlayed = true;\n          const targetIndex = newTopItem.wasEverPlayed ? newTopItem.currentIndex : 0;\n\n          if (StateManager.isPlaying()) {\n            logProbe('[Reconciler] (效果) 用户正在播放，将执行过渡效果...');\n            if (options?.transitionEffect === 'hard') {\n              await PlaybackEngine.executeHardCut(\n                newTopItem.playlistContent[targetIndex].url,\n                StateManager.getVolume(),\n              );\n            } else {\n              await _executeTransition(targetIndex);\n            }\n          } else if (\n            oldTopItem === undefined && // 1. 队列发生“从无到有”的跃迁\n            StateManager.getPlaybackState() === 'STOPPED' // 2. 关键：只要不是 PAUSED (用户主动暂停)，就允许场景触发播放\n          ) {\n            logProbe(\n              '[Reconciler] 自动播放契约满足 (Queue 0->1 + Not Paused)，将调用 _executeGenesisPlayInternal。',\n              'warn',\n            );\n            await _executeGenesisPlayInternal(targetIndex);\n          } else {\n            logProbe('[Reconciler] (效果) 用户已暂停或未授权，仅在后台静默更新轨道，不播放。');\n            const track = newTopItem.playlistContent[targetIndex];\n            const activePlayer = PlaybackEngine.getActivePlayer();\n            if (track && activePlayer) {\n              activePlayer.src = track.url;\n            }\n          }\n        } else {\n          logProbe('[Reconciler] (决策) 监测到队列已完全清空。正在执行“物理静音”协议...', 'warn');\n\n          await PlaybackEngine.fadeOutAndPause();\n\n          StateManager.setPlaybackState('STOPPED');\n\n          StrategyManager.notifyQueueChanged();\n\n          logProbe('[Reconciler] (执行) “物理静音”完成，播放状态已置为 STOPPED。');\n        }\n      } else {\n        logProbe('[Reconciler] (决策) 队首未发生变更，保持当前播放稳定。');\n      }\n\n      // --- 6. 【更新记忆】: 为下一次边沿检测做准备 ---\n      await MvuManager.persistCurrentState(currentStateData);\n    } catch (error) {\n      logProbe(`[Reconciler] 核心逻辑执行期间发生严重错误: ${error}`, 'error');\n      console.error(error);\n    } finally {\n      await writeState('reconciliation');\n    }\n  } finally {\n    isReconciling = false;\n    await _releaseEffectLock();\n    logProbe('=== [Reconciler] “统一校准官”任务完成 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 4. 核心工具与广播系统 (Core Utilities & Broadcast System)\n// =================================================================\n\nfunction broadcastFullState() {\n  const currentItem = StateManager.getTopQueueItem();\n  const currentPlaylist = currentItem?.playlistContent ?? [];\n  const currentIndex = currentItem?.currentIndex ?? 0;\n\n  const payload: FullStatePayload = {\n    currentItem: currentPlaylist[currentIndex]\n      ? {\n          title: currentPlaylist[currentIndex].歌名,\n          artist: currentPlaylist[currentIndex].歌手,\n          cover: currentPlaylist[currentIndex].封面,\n        }\n      : null,\n    isPlaying: StateManager.isPlaying(),\n    playbackState: StateManager.getPlaybackState(),\n    playbackMode: StateManager.getPlaybackMode(),\n    masterVolume: StateManager.getVolume(),\n    playlist: currentPlaylist.map(item => ({ title: item.歌名, artist: item.歌手, cover: item.封面 })),\n    isTransitioning: StateManager.isPerformingEffect(),\n  };\n  logProbe(\n    `[Broadcast] 正在广播完整状态... [旧兼容: isPlaying=${payload.isPlaying}] [新内核: state=${payload.playbackState}] mode: ${payload.playbackMode}, currentItem: ${payload.currentItem?.title ?? '无'}`,\n    'groupCollapsed',\n  );\n  logProbe(`详细: isTransitioning=${payload.isTransitioning}`);\n  logProbe('', 'groupEnd');\n\n  fullStateUpdateCallbacks.forEach(callback => {\n    try {\n      callback(payload);\n    } catch (e) {\n      console.error('[音乐脚本] 完整状态回调执行出错:', e);\n    }\n  });\n}\n\nfunction broadcastTimeUpdate() {\n  const activePlayer = PlaybackEngine.getActivePlayer();\n  if (!StateManager.isPlaying() || !activePlayer) return;\n  const payload: TimeUpdatePayload = {\n    currentTime: activePlayer.currentTime,\n    duration: activePlayer.duration || 0,\n  };\n  timeUpdateCallbacks.forEach(callback => callback(payload));\n}\n\nfunction prepareNextTrack() {\n  const currentItem = StateManager.getTopQueueItem();\n  const standbyPlayer = PlaybackEngine.getStandbyPlayer();\n  if (!standbyPlayer || !currentItem) return;\n  const nextIndex = currentItem.currentIndex + 1;\n  if (nextIndex < currentItem.playlistContent.length) {\n    const nextTrack = currentItem.playlistContent[nextIndex];\n    if (nextTrack && standbyPlayer.src !== nextTrack.url) {\n      standbyPlayer.src = nextTrack.url;\n      standbyPlayer.load();\n    }\n  }\n}\n\n// =================================================================\n// 5. 状态管理 (State Management)\n// =================================================================\n\nfunction readState() {\n  logProbe('[StateReader] 正在尝试从酒馆变量读取持久化状态...');\n  const savedData = getVariables({ type: 'chat' })[STATE_KEY];\n\n  if (!savedData || typeof savedData !== 'object') {\n    logProbe('[StateReader] 未发现有效存档。');\n    return null;\n  }\n\n  logProbe('[StateReader] 发现原始状态数据，正在提交给 Zod 进行安全验证...');\n  const validationResult = ZodPersistedState.safeParse(savedData);\n\n  if (validationResult.success) {\n    logProbe('[StateReader] Zod 验证成功，状态数据安全。');\n    return validationResult.data;\n  } else {\n    console.warn('[StateReader] 持久化状态验证失败:', validationResult.error);\n    return null;\n  }\n}\n\nasync function writeState(source: string) {\n  if (!isScriptActive) {\n    logProbe(`[State] 写入操作被阻止，因为脚本正在停机。(来源: ${source})`, 'warn');\n    return;\n  }\n  try {\n    logProbe(`[State] 由 \"${source}\" 触发状态写入...`);\n    const dataToSave = StateManager.getStateSnapshotForPersistence();\n\n    await updateVariablesWith(\n      vars => {\n        vars[STATE_KEY] = dataToSave;\n        return vars;\n      },\n      { type: 'chat' },\n    );\n\n    logProbe(`[State] 状态已成功写入酒馆变量`);\n  } catch (e: any) {\n    logProbe(`[State] 写入状态时发生严重错误: ${e}`, 'error');\n  }\n}\n\n// =================================================================\n// 6. 世界书配置解析与队列操作 (Worldbook Parsing & Stack Operations)\n// =================================================================\n\n/**\n * @description 格式化 Zod 验证错误，以便在 toastr 中为角色卡作者显示清晰、可操作的反馈。\n */\nfunction _formatZodErrorForToastr(error: ZodError): void {\n  const issue = error.issues[0];\n  const path = issue.path.join(' -> ');\n  const message = issue.message;\n\n  const toastrTitle = `[MusicConfig] 内容错误`;\n  const toastrMessage = `路径: ${path} | 问题: ${message}`;\n\n  const fullLogMessage = `[MusicConfig] 内容错误:\\n路径: ${path}\\n问题: ${message}`;\n  logProbe(`[ZodValidator] 世界书配置验证失败: ${fullLogMessage}`, 'error');\n\n  toastr.error(toastrMessage, toastrTitle, { timeOut: 15000 });\n}\n\n// =================================================================\n// 核心算法 V9.5 (Core Algorithms for \"Concerto\")\n// 原则: 这些函数都必须是纯粹的查询 (CQS)，严禁产生任何副作用。\n// =================================================================\n\n/**\n * [核心算法] 判断两个触发器对象是否代表同一个“功能身份”。\n * @param a - 第一个触发器对象。\n * @param b - 第二个触发器对象。\n * @returns {boolean} 如果功能上相等，则返回 true。\n */\nfunction areTriggersFunctionallyEqual(\n  a: z.infer<typeof ZodTriggerConfig> | undefined,\n  b: z.infer<typeof ZodTriggerConfig> | undefined,\n): boolean {\n  if (!a || !b) return a === b;\n\n  if (a.playlist_id !== b.playlist_id) return false;\n\n  type ConditionKey = keyof z.infer<typeof ZodSingleCondition>;\n\n  const getCanonicalString = (condition: z.infer<typeof ZodSingleCondition>): string => {\n    return (Object.keys(condition) as ConditionKey[])\n      .sort()\n      .map(key => `${key}:${String(condition[key])}`) // 使用 String() 来确保所有值都能被正确处理\n      .join(',');\n  };\n\n  const conditionsA = a.conditions.map(getCanonicalString).sort();\n  const conditionsB = b.conditions.map(getCanonicalString).sort();\n\n  return conditionsA.length === conditionsB.length && conditionsA.every((val, index) => val === conditionsB[index]);\n}\n\n/**\n * @description [V9.7 核心强化] 查找权威MVU状态。现在能够识别“创世”和“运行时”两种数据结构。\n * @param context - 可选的上下文，用于指导查找方式。\n * @returns {Promise<{ mvuData: any, messageId: number } | null>} 权威状态或 null。\n */\nasync function _findLatestAuthoritativeMvuState(context?: {\n  messageId: number;\n  swipeId: number;\n}): Promise<{ mvuData: any; messageId: number } | null> {\n  // --- 模式一: 精确制导 (通常用于开场白) ---\n  if (context && context.messageId === 0 && typeof context.swipeId === 'number') {\n    logProbe(\n      `[StateFinder] (精确制导模式) 目标: message_id=${context.messageId}, swipe_id=${context.swipeId}`,\n      'groupCollapsed',\n    );\n    try {\n      const mvuDataContainer: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n\n      const swipeSpecificData = mvuDataContainer?.swipes_data?.[context.swipeId];\n\n      if (swipeSpecificData?.stat_data) {\n        // 成功在 \"创世\" 结构中找到特定 swipe 的数据\n        logProbe('[StateFinder] (探针) 检测到“创世”结构 (swipes_data)，成功命中！');\n        logProbe('', 'groupEnd');\n        return { mvuData: swipeSpecificData, messageId: 0 };\n      } else if (mvuDataContainer?.stat_data) {\n        // 在顶层找到了 \"运行时\" 结构的数据 (可能只有一个开场白)\n        logProbe('[StateFinder] (探针) 检测到“运行时”结构 (顶层 stat_data)，直接采用。');\n        logProbe('', 'groupEnd');\n        return { mvuData: mvuDataContainer, messageId: 0 };\n      } else {\n        logProbe('[StateFinder] (精确制导模式) 查找失败：在两种已知结构中均未找到 stat_data。', 'warn');\n      }\n    } catch (error) {\n      logProbe(`[StateFinder] (精确制导模式) 查询时出错: ${error}`, 'error');\n    } finally {\n      logProbe('', 'groupEnd');\n    }\n  }\n\n  // --- 模式二: 回溯扫描 (找不到精确目标时的标准流程) ---\n  logProbe('[StateFinder] (回溯扫描模式) 开始执行...', 'groupCollapsed');\n  try {\n    const allMessages = getChatMessages(-1, { include_swipes: true });\n    for (let i = allMessages.length - 1; i >= 0; i--) {\n      const message = allMessages[i];\n      // [V9.7 核心修正] 修复致命拼写错误：message.id -> message.message_id\n      const currentMessageId = message.message_id;\n\n      // 防御性编程：如果 message_id 无效，直接跳过，防止意外\n      if (typeof currentMessageId !== 'number') {\n        logProbe(`(探针) 跳过无效楼层 (索引 ${i})，因其 message_id 为 ${currentMessageId}。`, 'warn');\n        continue;\n      }\n\n      try {\n        logProbe(`(探针) 正在查询 message_id: ${currentMessageId}...`);\n        const mvuData = await Mvu.getMvuData({ type: 'message', message_id: currentMessageId });\n\n        if (mvuData?.stat_data) {\n          logProbe(`[StateFinder] 查找成功！在 message_id: ${currentMessageId} 处找到权威状态。`);\n          logProbe('', 'groupEnd');\n          return { mvuData, messageId: currentMessageId };\n        }\n      } catch (error) {\n        logProbe(`(探针) 查询 message_id: ${currentMessageId} 时接口失败，将继续向前查找。错误: ${error}`, 'warn');\n      }\n    }\n    logProbe('[StateFinder] 查找失败：遍历完所有消息楼层，均未找到有效的 stat_data。', 'warn');\n    return null;\n  } catch (error) {\n    logProbe(`[StateFinder] 在获取聊天记录时发生严重错误: ${error}`, 'error');\n    return null;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description [职责单一] 找到、解析、验证并准备好【可供运行时直接使用】的音乐配置。\n * @returns {Promise<{ playlists: Record<string, PlaylistConfig>, defaultId: string, triggers: Trigger[] } | null>}\n *          一个包含了【 playlists 映射 】的、完全准备就绪的配置对象，或在失败时返回 null。\n */\n\nasync function parseWorldbookConfig() {\n  logProbe('[WorldbookParser V4-健壮模式] 开始解析...', 'group');\n\n  // [修改点] 自定义错误类，用于清晰地区分“配置缺失”和“未知错误”\n  // 这让我们的错误处理逻辑更符合 SRP 原则\n  class ConfigMissingError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'ConfigMissingError';\n    }\n  }\n\n  type AggregatedPlaylist = z.infer<typeof ZodPlaylistConfig> & { _sourceFile: string };\n  type AggregatedTrigger = z.infer<typeof ZodTriggerConfig> & { _sourceFile: string };\n\n  const aggregatedConfig: {\n    playlists: AggregatedPlaylist[];\n    triggers: AggregatedTrigger[];\n    defaultPlaylistId?: string;\n    _defaultPlaylistIdSourceFile: string | null;\n  } = {\n    playlists: [],\n    triggers: [],\n    defaultPlaylistId: undefined,\n    _defaultPlaylistIdSourceFile: null,\n  };\n\n  try {\n    // 前置检查：在执行任何复杂逻辑前，首先确认世界书数据是否可访问。\n    const worldbookNames = getCharWorldbookNames('current');\n    const searchOrder = [worldbookNames.primary, ...worldbookNames.additional].filter(Boolean);\n\n    // 如果角色卡没有关联任何世界书，直接抛出我们自定义的错误\n    if (searchOrder.length === 0) {\n      throw new ConfigMissingError('角色卡未关联任何世界书。');\n    }\n\n    let foundAnyConfigEntry = false;\n\n    for (const bookName of searchOrder) {\n      if (!bookName) continue;\n      const entries = await getWorldbook(bookName);\n      const configEntries = entries.filter(e => e.name.includes('[MusicConfig]'));\n\n      if (configEntries.length > 0) {\n        foundAnyConfigEntry = true;\n      }\n\n      for (const entry of configEntries) {\n        logProbe(`[Parser V4] 发现并处理配置文件: \"${entry.name}\"`);\n        try {\n          const rawConfig = YAML.parse(entry.content);\n          const validationResult = ZodWorldbookConfig.safeParse(rawConfig);\n\n          if (!validationResult.success) {\n            logProbe(`[Parser V4] 条目 \"${entry.name}\" Zod验证失败，已跳过。`, 'error');\n            _formatZodErrorForToastr(validationResult.error);\n            continue;\n          }\n\n          const data = validationResult.data;\n\n          if (data.playlists) {\n            aggregatedConfig.playlists.push(...data.playlists.map(p => ({ ...p, _sourceFile: entry.name })));\n          }\n          if (data.triggers) {\n            aggregatedConfig.triggers.push(...data.triggers.map(t => ({ ...t, _sourceFile: entry.name })));\n          }\n          if (data.default_playlist_id) {\n            if (aggregatedConfig.defaultPlaylistId && aggregatedConfig.defaultPlaylistId !== data.default_playlist_id) {\n              const warningMsg = `在文件 \"${entry.name}\" 中发现的 default_playlist_id (\"${data.default_playlist_id}\") 覆盖了来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\" 的定义 (\"${aggregatedConfig.defaultPlaylistId}\")。为确保行为可预测，建议只保留一个定义。`;\n              logProbe(`[Parser V4] ${warningMsg}`, 'warn');\n              toastr.warning(warningMsg, '配置警告', { timeOut: 20000, closeButton: true });\n            }\n            aggregatedConfig.defaultPlaylistId = data.default_playlist_id;\n            aggregatedConfig._defaultPlaylistIdSourceFile = entry.name;\n          }\n        } catch (e: any) {\n          logProbe(`[Parser V4] 解析条目 \"${entry.name}\" 时发生YAML语法错误: ${e.message}`, 'error');\n          toastr.error(`[MusicConfig] 文件 \"${entry.name}\" 格式错误：YAML 语法不正确。`, '配置错误', {\n            timeOut: 10000,\n          });\n        }\n      }\n    }\n\n    // 在所有文件都检查完之后，再判断是否找到了任何 [MusicConfig] 条目\n    if (!foundAnyConfigEntry) {\n      throw new ConfigMissingError('在已关联的世界书中，未找到任何包含 [MusicConfig] 的条目。');\n    }\n\n    // --- 全局健全性检查 (逻辑保持不变) ---\n    logProbe('[Parser V4] 所有文件聚合完毕，开始执行全局健全性检查...', 'groupCollapsed');\n    let isGloballyValid = true;\n    const playlistsById = _.groupBy(aggregatedConfig.playlists, 'id');\n    for (const id in playlistsById) {\n      if (playlistsById[id].length > 1) {\n        const sources = playlistsById[id].map(p => p._sourceFile).join(', ');\n        const errorMsg = `[MusicConfig] 致命错误: 歌单 ID \"${id}\" 在多个文件中重复定义。来源: ${sources}。ID 必须是唯一的。`;\n        logProbe(errorMsg, 'error');\n        toastr.error(errorMsg, '配置冲突', { timeOut: 15000 });\n        isGloballyValid = false;\n      }\n    }\n    const allPlaylistIds = new Set(aggregatedConfig.playlists.map(p => p.id));\n    if (aggregatedConfig.defaultPlaylistId && !allPlaylistIds.has(aggregatedConfig.defaultPlaylistId)) {\n      const errorMsg = `[MusicConfig] 配置错误: 最终的 default_playlist_id (\"${aggregatedConfig.defaultPlaylistId}\", 来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\") 指向了一个不存在的歌单。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 15000 });\n      aggregatedConfig.defaultPlaylistId = undefined;\n    }\n    const finalTriggers = aggregatedConfig.triggers.filter(trigger => {\n      if (allPlaylistIds.has(trigger.playlist_id)) {\n        return true;\n      }\n      const errorMsg = `[MusicConfig] 校验失败: 来自文件 \"${trigger._sourceFile}\" 的触发器指向了不存在的歌单ID \"${trigger.playlist_id}\"。该触发器将被忽略。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 10000 });\n      return false;\n    });\n\n    if (!isGloballyValid) {\n      logProbe('[Parser V4] 全局健全性检查失败，配置被拒绝。', 'error');\n      logProbe('', 'groupEnd');\n      logProbe('', 'groupEnd');\n      return null;\n    }\n    logProbe('[Parser V4] 全局健全性检查通过。');\n    logProbe('', 'groupEnd');\n\n    if (aggregatedConfig.playlists.length === 0) {\n      throw new ConfigMissingError('所有配置文件中都未能找到任何有效的歌单 (playlists)。');\n    }\n\n    // --- 数据归一化并返回 ---\n    const playlistsAsMap: Record<string, PlaylistConfig> = {};\n    for (const pl of aggregatedConfig.playlists) {\n      const normalizedTracks = pl.tracks.map(track => ({\n        url: track.url,\n        歌名:\n          track.歌名 && track.歌名.trim() !== ''\n            ? track.歌名\n            : decodeURIComponent(track.url.split('/').pop()?.split('?')[0] || '未知歌曲'),\n        歌手: track.歌手,\n        封面: track.封面,\n      }));\n\n      playlistsAsMap[pl.id] = { ..._.omit(pl, '_sourceFile'), tracks: normalizedTracks };\n    }\n\n    const finalConfig = {\n      playlists: playlistsAsMap,\n      defaultId: aggregatedConfig.defaultPlaylistId,\n      triggers: finalTriggers.map(t => _.omit(t, '_sourceFile')),\n    };\n\n    logProbe('[Parser V4] 数据归一化完成，运行时配置已就绪。', 'log');\n    logProbe('', 'groupEnd');\n    return finalConfig;\n  } catch (error) {\n    // 这是新的、更智能的错误处理中心\n    if (error instanceof ConfigMissingError) {\n      // 判断这个错误是不是我们自己抛出的“配置缺失”错误\n      logProbe(`[Parser V4] 捕获到可预见的配置错误: ${error.message}`, 'error');\n\n      // [核心修改] 直接使用 error.message 作为 toastr 的提示内容\n      // 这确保了我们抛出的具体错误信息能够直接呈现给用户\n      toastr.error(error.message, '[音乐播放器] 配置缺失', {\n        timeOut: 20000,\n        closeButton: true,\n      });\n    } else {\n      // 如果是其他所有无法预料的错误，比如酒馆环境问题\n      logProbe(`[Parser V4] 解析过程中发生意外顶层错误: ${error}`, 'error');\n      // 显示通用的、建议用户刷新的提示\n      toastr.error(\n        '播放器在加载设置时遇到一个临时问题。这通常可以通过按 F5 刷新酒馆页面来解决。',\n        '[音乐播放器] 加载时遇到临时问题',\n        {\n          timeOut: 20000,\n          closeButton: true,\n        },\n      );\n    }\n    logProbe('', 'groupEnd');\n    return null;\n  }\n}\n\n/**\n * [工厂 V3.0] 从持久化对象重建一个完整的、可供运行时使用的 QueueItem。\n * @param persistedItem - 从酒馆变量读取的、经过 Zod 验证的item。\n * @param playlistConfig - 从当前世界书解析出的对应歌单配置。\n * @returns {QueueItem} 一个完整的运行时 QueueItem。\n */\nfunction reconstituteQueueItem(\n  persistedItem: z.infer<typeof ZodQueueItemState>,\n  playlistConfig: PlaylistConfig,\n): QueueItem {\n  return {\n    playlistId: persistedItem.playlistId,\n    priority: persistedItem.triggerSource?.priority ?? -Infinity,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    onFinishRule: playlistConfig.onFinishRule,\n    currentIndex: persistedItem.currentIndex,\n    playedIndices: new Set(persistedItem.playedIndices),\n    wasEverPlayed: persistedItem.wasEverPlayed,\n    triggeredBy: persistedItem.triggerSource ? 'mvu' : 'base',\n    triggerSource: persistedItem.triggerSource,\n  };\n}\n\ntype CreateQueueItemConfig =\n  | { type: 'base'; playlistId: string }\n  | { type: 'mvu'; playlistId: string; trigger: z.infer<typeof ZodTriggerConfig> };\n\n/**\n * [工厂 V3.0] 创建一个全新的、状态初始化的 QueueItem。\n * @param config - 一个包含所有必要信息的配置对象。\n * @returns {QueueItem | null} 一个完整的队列项，或在失败时返回 null。\n */\nfunction createQueueItem(config: CreateQueueItemConfig): QueueItem | null {\n  const { playlistId } = config;\n\n  if (!playlistId || !allPlaylists[playlistId]) {\n    logProbe(`[Factory] 创建队列项失败：请求的歌单ID \"${playlistId}\" 不存在。`, 'error');\n    return null;\n  }\n\n  const playlistConfig = allPlaylists[playlistId];\n\n  const baseItem: Omit<QueueItem, 'triggeredBy' | 'triggerSource' | 'onFinishRule' | 'priority'> = {\n    playlistId: playlistId,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    currentIndex: 0,\n    playedIndices: new Set(),\n    wasEverPlayed: false,\n  };\n\n  if (config.type === 'base') {\n    return {\n      ...baseItem,\n      priority: -Infinity,\n      triggeredBy: 'base',\n      onFinishRule: playlistConfig.onFinishRule ?? 'loop',\n    };\n  } else {\n    return {\n      ...baseItem,\n      priority: config.trigger.priority,\n      triggeredBy: 'mvu',\n      onFinishRule: playlistConfig.onFinishRule,\n      triggerSource: config.trigger,\n    };\n  }\n}\n\n// =================================================================\n// 7. 运行时初始化与播放器控制 (Runtime & Player Controls)\n// =================================================================\n\nasync function initializePlayerForChat(\n  config: any,\n  authoritativeState: any,\n  options?: { autoPlayIfWasPlaying?: boolean },\n) {\n  logProbe('=== 开始执行【核心·自愈式初始化】 V9.0 ===', 'group');\n  try {\n    // --- 【准备阶段】 清理与重置 ---\n    isCorePlayerInitialized = true;\n    // 注意：StateReset 会重置内存，所以我们需要先读档，再根据读档结果恢复必要的记忆\n    const savedState = readState();\n    StateManager.resetState();\n\n    if (savedState) {\n      // 恢复基础状态（此时 active_queue 还是空的，将在后面重建）\n      StateManager.loadState(savedState);\n    }\n\n    MvuManager.resetState();\n    MvuManager.initialize();\n    const activePlayer = PlaybackEngine.getActivePlayer();\n    if (activePlayer) activePlayer.pause();\n    triggers = [];\n    allPlaylists = {};\n    defaultPlaylistId = '';\n\n    if (!config) {\n      logProbe('[Initializer] 配置无效，初始化中止。', 'error');\n      broadcastFullState();\n      throw new Error('世界书音乐配置解析失败，请检查配置。');\n    }\n\n    allPlaylists = config.playlists;\n    defaultPlaylistId = config.defaultId;\n    triggers = config.triggers;\n\n    const currentStatData = authoritativeState?.mvuData?.stat_data ?? null;\n    const authoritativeMessageId = authoritativeState?.messageId;\n\n    let finalQueue: QueueItem[] = [];\n\n    // --- 【第一步】 确定并验证权威的基础歌单 ID ---\n    let correctBasePlaylistId = defaultPlaylistId;\n\n    const msgZero = getChatMessages(0, { include_swipes: true })[0];\n    const currentSwipeId = msgZero?.swipe_id ?? 0;\n\n    if (msgZero) {\n      const currentGreeting = msgZero.swipes?.[msgZero.swipe_id];\n      const tagMatch = currentGreeting?.match(/<playlist:([^>]+)>/);\n      if (tagMatch && tagMatch[1]) {\n        const tagPlaylistId = tagMatch[1];\n        if (allPlaylists[tagPlaylistId]) {\n          logProbe(`[Initializer-Heal] (基准) 从开场白标签确定权威基础歌单: \"${tagPlaylistId}\"`);\n          correctBasePlaylistId = tagPlaylistId;\n        } else {\n          const errorMsg = `[MusicConfig] 配置警告: 开场白标签 <playlist:${tagPlaylistId}> 指向了一个不存在的歌单ID。将回退至默认歌单。`;\n          logProbe(errorMsg, 'warn');\n          toastr.warning(errorMsg, '配置警告', { timeOut: 15000 });\n        }\n      } else {\n        logProbe(`[Initializer-Heal] (基准) 开场白无标签，使用世界书默认歌单: \"${defaultPlaylistId ?? '无'}\"`);\n      }\n    }\n\n    const lastSwipeId = StateManager.getLastActiveSwipeId();\n\n    if (lastSwipeId !== null && lastSwipeId !== currentSwipeId) {\n      logProbe(`[Initializer] (上下文切换) 检测到平行宇宙跃迁: Swipe ${lastSwipeId} -> ${currentSwipeId}。`, 'warn');\n      logProbe(`[Initializer] (决策) 旧时间线的墓志铭已失效，正在清空...`);\n      StateManager.clearFinishedBasePlaylists();\n    } else {\n      logProbe(`[Initializer] (上下文保持) 同一时间线 (Swipe ${currentSwipeId})，保持墓志铭记录。`);\n    }\n    // 更新当前锚点\n    StateManager.setLastActiveSwipeId(currentSwipeId);\n\n    // [新增] 检查 4: 基础歌单与场景歌单冲突检查\n    if (correctBasePlaylistId) {\n      const scenePlaylistIds = new Set(triggers.map(t => t.playlist_id));\n      if (scenePlaylistIds.has(correctBasePlaylistId)) {\n        const fatalErrorMsg = `[MusicConfig] 致命配置错误: 歌单 \"${correctBasePlaylistId}\" 不能同时被用作基础歌单（在开场白或默认设置中）和场景歌单（被触发器关联）。请为它们使用不同的歌单。`;\n        logProbe(fatalErrorMsg, 'error');\n        toastr.error(fatalErrorMsg, '配置冲突', { timeOut: 20000, closeButton: true });\n        throw new Error('基础歌单与场景歌单存在致命冲突。');\n      }\n    }\n\n    // --- 【第二步】 队列净化与重建 (Heal the Past) ---\n    if (savedState) {\n      logProbe('[Initializer-Heal] (净化) 开始审查存档...', 'groupCollapsed');\n      const healedQueue: QueueItem[] = [];\n      // 注意：此时我们使用的是 savedState.active_queue，而不是 StateManager 中的（因为 resetState 会清空）\n      for (const persistedItem of savedState.active_queue) {\n        if (!Object.prototype.hasOwnProperty.call(allPlaylists, persistedItem.playlistId)) {\n          logProbe(`(净化-丢弃) 存档歌单 \"${persistedItem.playlistId}\" 已不存在。`, 'warn');\n          continue;\n        }\n\n        const playlistConfig = allPlaylists[persistedItem.playlistId];\n        const isBaseItem = !persistedItem.triggerSource;\n\n        if (isBaseItem) {\n          if (persistedItem.playlistId === correctBasePlaylistId) {\n            logProbe(`(净化-保留) 基础歌单 \"${persistedItem.playlistId}\" 仍然有效。`);\n            healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n          } else {\n            logProbe(\n              `(净化-丢弃) 基础歌单 \"${persistedItem.playlistId}\" 已被新的权威歌单 \"${correctBasePlaylistId ?? '无'}\" 替代。`,\n              'warn',\n            );\n          }\n        } else {\n          const currentTrigger = triggers.find(t => t.playlist_id === persistedItem.playlistId);\n          logProbe(`(探针-净化) 正在审查存档的MVU歌单 \"${persistedItem.playlistId}\"...`);\n\n          if (playlistConfig.onFinishRule === 'pop') {\n            logProbe(`(净化-丢弃) 原因：规则为 'pop' (场景歌单不应跨会话保留)。`);\n            continue;\n          }\n\n          if (!currentTrigger) {\n            logProbe(`(净化-丢弃) 原因：在最新的世界书配置中已找不到对应的触发器。`, 'warn');\n            continue;\n          }\n\n          if (!MvuManager.checkTriggerCondition(currentTrigger, currentStatData)) {\n            logProbe(`(净化-丢弃) 原因：最新的触发器条件在当前状态下不满足。`);\n            continue;\n          }\n\n          logProbe(`(净化-保留) 验证通过。`);\n          healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n        }\n      }\n      finalQueue = healedQueue;\n      logProbe('[Initializer-Heal] (净化) 审查完成。', 'groupEnd');\n    }\n\n    // --- 【第三步】 队列补充 ---\n    if (currentStatData && triggers.length > 0) {\n      logProbe('[Initializer-Heal] (补充) 正在检查是否有新激活的场景歌单...', 'groupCollapsed');\n      for (const trigger of triggers) {\n        const alreadyExists = finalQueue.some(\n          item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, trigger),\n        );\n\n        if (!alreadyExists && MvuManager.checkTriggerCondition(trigger, currentStatData)) {\n          const playlistConfig = allPlaylists[trigger.playlist_id];\n          if (playlistConfig && playlistConfig.onFinishRule === 'pop') {\n            if (authoritativeMessageId === 0) {\n              logProbe(`(补充) 允许添加 'pop' 歌单 \"${trigger.playlist_id}\"，因为上下文是开场白。`);\n              const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n              if (newItem) finalQueue.push(newItem);\n            } else {\n              logProbe(\n                `(补充-阻止) 场景歌单 \"${trigger.playlist_id}\" 因规则为 'pop' 且上下文非开场白而被忽略。`,\n                'warn',\n              );\n            }\n          } else {\n            const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n            if (newItem) finalQueue.push(newItem);\n          }\n        }\n      }\n      logProbe('[Initializer-Heal] (补充) 检查完成。', 'groupEnd');\n    }\n\n    // --- 【第四步】 基础歌单最终注入 (Final Guarantee V2.0) ---\n    const basePlaylistExists = finalQueue.some(item => item.triggeredBy === 'base');\n    if (!basePlaylistExists && correctBasePlaylistId && allPlaylists[correctBasePlaylistId]) {\n      const isDead = StateManager.getFinishedBasePlaylists().has(correctBasePlaylistId);\n\n      if (isDead) {\n        logProbe(\n          `[Initializer-Heal] (注入-阻止) 基础歌单 \"${correctBasePlaylistId}\" 在此上下文(Swipe ${currentSwipeId})中已完结(墓志铭在册)。尊重历史，拒绝复活。`,\n        );\n      } else {\n        logProbe(`[Initializer-Heal] (注入) 最终注入权威基础歌单 \"${correctBasePlaylistId}\"。`);\n        const baseItem = createQueueItem({ type: 'base', playlistId: correctBasePlaylistId });\n        if (baseItem) finalQueue.push(baseItem);\n      }\n    }\n\n    // --- 【第五步】 最终加载与后续设置 ---\n    logProbe('[Initializer-Finalize] 正在提交最终队列并完成设置...');\n    StateManager.updateQueue(finalQueue);\n\n    // 注意：如果 resetState 重置了模式，我们需要从 savedState 恢复，或者使用默认\n    // 之前的代码是在 resetState 后直接覆盖，但这里我们利用 loadState 已经恢复了一部分\n    // 我们需要确保 StrategyManager 同步\n    const mode = StateManager.getPlaybackMode();\n    StrategyManager.setMode(mode);\n    logProbe(`(探针) 策略模式已同步为: ${mode}`);\n    StrategyManager.notifyQueueChanged();\n\n    PlaybackEngine.initialize();\n\n    const volume = StateManager.getVolume();\n    if (PlaybackEngine.getActivePlayer()) PlaybackEngine.getActivePlayer()!.volume = volume;\n    if (PlaybackEngine.getStandbyPlayer()) PlaybackEngine.getStandbyPlayer()!.volume = 0;\n\n    const initialTopItem = StateManager.getTopQueueItem();\n    if (initialTopItem) {\n      const track = initialTopItem.playlistContent[initialTopItem.currentIndex];\n      if (track && PlaybackEngine.getActivePlayer()) {\n        PlaybackEngine.getActivePlayer()!.src = track.url;\n      }\n    } else {\n      logProbe(`[Initializer] (探针) 最终队列为空（可能因基础歌单已完结），不执行音频预加载。`);\n    }\n\n    if (currentStatData) {\n      await MvuManager.persistCurrentState(currentStatData);\n      logProbe('[Initializer-Finalize]  已将本次创世的权威MVU状态持久化为历史基准。');\n    } else {\n      await MvuManager.persistCurrentState({});\n      logProbe('[Initializer-Finalize] 当前无MVU状态，已将空状态持久化为历史基准。');\n    }\n\n    await writeState('initialization');\n    broadcastFullState();\n\n    if (options?.autoPlayIfWasPlaying) {\n      logProbe('[Initializer] (探针) 检测到来自开场白滑动的“自动播放”意图。', 'warn');\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem) {\n        logProbe('[Initializer] 新的开场白已配置歌单，将执行“创世播放”...');\n        await _handleGenesisPlay();\n      } else {\n        logProbe('[Initializer] 新的开场白未配置歌单，自动播放已取消。');\n      }\n    }\n  } catch (error) {\n    logProbe(`[Initializer] 核心初始化过程中发生严重错误: ${error}`, 'error');\n    console.error(error);\n    throw error;\n  } finally {\n    logProbe('=== 【核心·自愈式初始化】执行完毕 ===', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】播放执行器。\n *              它的单一职责是：接收一个目标索引，并尝试播放它。\n *              它会返回一个 Promise，成功时 resolve，失败时 reject，将错误冒泡给调用者处理。\n *              它自身不包含任何重试或自愈逻辑。\n */\nasync function _executeTransition(targetIndex: number): Promise<void> {\n  logProbe(`[Executor] 收到播放指令，目标索引: ${targetIndex}`, 'group');\n\n  const freshItem = StateManager.getTopQueueItem();\n  if (!freshItem) {\n    logProbe(`[Executor] 执行中止：无有效队列项`, 'warn');\n    logProbe('', 'groupEnd');\n    return Promise.resolve();\n  }\n\n  const targetTrack = freshItem.playlistContent[targetIndex];\n  if (!targetTrack?.url) {\n    logProbe(`[Executor] 执行失败：在索引 ${targetIndex} 处找不到音轨或音轨URL无效。`, 'error');\n    logProbe('', 'groupEnd');\n    throw new Error(`Invalid track at index ${targetIndex}`);\n  }\n\n  try {\n    await PlaybackEngine.transitionToTrack(targetTrack.url, StateManager.getVolume());\n\n    StateManager.setPlaybackState('PLAYING');\n    prepareNextTrack();\n    logProbe(`[Executor] 索引 ${targetIndex} 播放成功。`);\n  } catch (error) {\n    logProbe(`[Executor] PlaybackEngine报告播放失败。原因: ${error}`, 'error');\n    throw error;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】迭代式自愈循环。\n *              此最终版严格遵守 SRP 原则，将决策应用逻辑完全委托给 _applyNavigationDecision。\n */\nasync function _executeSelfHealingLoop(): Promise<void> {\n  logProbe('[SelfHeal] 启动“迭代式自愈循环”... 播放器进入紧急自愈模式。', 'warn');\n\n  let consecutiveFailures = 1;\n  const currentItemForThreshold = StateManager.getTopQueueItem();\n  const threshold = currentItemForThreshold?.playlistContent.length ?? 0;\n\n  if (currentItemForThreshold) {\n    toastr.error(\n      `歌曲《${currentItemForThreshold.playlistContent[currentItemForThreshold.currentIndex]?.歌名 ?? '未知歌曲'}》加载失败，正在尝试自动处理...`,\n    );\n  }\n\n  while (true) {\n    if (threshold > 0 && consecutiveFailures >= threshold) {\n      logProbe(\n        `[SelfHeal] (熔断器) 连续失败 ${consecutiveFailures} 次，已达到或超过阈值 ${threshold}。自愈中止。`,\n        'error',\n      );\n      if (currentItemForThreshold) {\n        toastr.error(`歌单《${currentItemForThreshold.playlistId}》中所有歌曲均无法加载，播放已停止。`);\n      }\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    const currentItem = StateManager.getTopQueueItem();\n    if (!currentItem) {\n      logProbe('[SelfHeal] 自愈中止：中途队列变空。', 'warn');\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    const errorDecision = StrategyManager.getCurrentStrategy().onPlaybackError(currentItem);\n    logProbe(\n      `[SelfHeal] 收到策略 (${StrategyManager.getCurrentStrategy().constructor.name}) 的错误决策: { action: '${errorDecision.action}' }`,\n    );\n\n    const directive = await _applyNavigationDecision(errorDecision);\n\n    if (!directive.needsAsyncEffect) {\n      logProbe('[SelfHeal] 决策应用后无需播放，自愈中止。');\n      // 注意：applyNavigationDecision 内部已经处理了 setPlaying(false) 和广播\n      return;\n    }\n\n    // 防御性编程：确保 targetIndex 存在\n    if (typeof directive.targetIndex !== 'number') {\n      logProbe('[SelfHeal] 决策应用后需要播放，但没有有效的 targetIndex。自愈中止。', 'error');\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    // 步骤 4: 再次尝试播放\n    try {\n      await _executeTransition(directive.targetIndex);\n\n      logProbe('[SelfHeal] 播放成功，自愈循环结束。', 'log');\n      broadcastFullState();\n      return;\n    } catch (nextError) {\n      consecutiveFailures++;\n      const nextTopItem = StateManager.getTopQueueItem();\n      const nextTrackTitle = nextTopItem?.playlistContent[nextTopItem.currentIndex]?.歌名 ?? '未知歌曲';\n      logProbe(`[SelfHeal] 第 ${consecutiveFailures} 次播放失败:`, 'error');\n      console.error(nextError);\n      toastr.error(`下一首《${nextTrackTitle}》加载失败...`);\n    }\n  }\n}\n\nasync function _applyNavigationDecision(\n  decision: StrategyDecision,\n): Promise<{ needsAsyncEffect: boolean; targetIndex?: number }> {\n  logProbe(\n    `[CentralCommand] 正在应用策略决策: { action: '${decision.action}', nextIndex: ${decision.nextIndex ?? 'N/A'} }`,\n    'group',\n  );\n\n  let needsAsyncEffect = false;\n  let targetIndex: number | undefined;\n\n  const currentItem = StateManager.getTopQueueItem();\n\n  switch (decision.action) {\n    case 'GoTo': {\n      if (typeof decision.nextIndex === 'number') {\n        logProbe('[CentralCommand] 指令: GoTo。提交导航步骤...');\n        StateManager.commitNavigationStep(decision.nextIndex);\n        needsAsyncEffect = true;\n        targetIndex = decision.nextIndex;\n      } else {\n        logProbe('[CentralCommand] 致命逻辑错误: GoTo 指令缺少 nextIndex！这是一个策略模块的BUG。', 'error');\n        console.error('探针捕获：错误的决策对象:', decision);\n        console.error('探针捕获：发生错误时的播放器状态:', StateManager.getStateSnapshotForRuntime());\n        needsAsyncEffect = false;\n      }\n      break;\n    }\n\n    case 'Restart': {\n      logProbe('[CentralCommand] 指令: Restart。请求从头重播当前轨道。');\n      if (currentItem) {\n        logProbe('[CentralCommand] (探针) 此决策不改变状态索引，仅生成一个效果指令。');\n        needsAsyncEffect = true;\n        targetIndex = currentItem.currentIndex;\n      }\n      break;\n    }\n\n    case 'RemoveTopAndAdvance': {\n      logProbe('[CentralCommand] 指令: RemoveTopAndAdvance。正在执行【自洽式】队列修改与过渡...');\n      const itemToRemove = StateManager.getTopQueueItem();\n      if (itemToRemove && itemToRemove.triggeredBy === 'base' && itemToRemove.onFinishRule === 'pop') {\n        logProbe(`[CentralCommand] (死亡登记) 基础歌单 \"${itemToRemove.playlistId}\" 即将离场`, 'warn');\n        StateManager.addToFinishedBasePlaylists(itemToRemove.playlistId);\n      }\n      const currentQueue = StateManager.getQueue();\n\n      const poppedItem = currentQueue.shift();\n      logProbe(`(探针) 已从队列中移除: \"${poppedItem?.playlistId}\"`);\n\n      StateManager.updateQueue(currentQueue);\n\n      logProbe('[CentralCommand] (握手) 正在通知 StrategyManager 队列已变更...');\n      StrategyManager.notifyQueueChanged();\n\n      const newTopItem = StateManager.getTopQueueItem();\n      if (newTopItem) {\n        logProbe(`(决策) 新队首为 \"${newTopItem.playlistId}\"，准备过渡到其当前索引: ${newTopItem.currentIndex}`);\n        needsAsyncEffect = true;\n        targetIndex = newTopItem.currentIndex;\n      } else {\n        logProbe('(决策) 队列已空，停止播放。');\n        logProbe('[CentralCommand] (修复) 检测到队列清空，正在下达物理静音指令...');\n        await PlaybackEngine.fadeOutAndPause();\n        StateManager.setPlaybackState('STOPPED');\n        needsAsyncEffect = false;\n      }\n\n      break;\n    }\n\n    case 'LoopReset': {\n      logProbe('[CentralCommand] 指令: LoopReset。执行“指挥家模型”...', 'warn');\n      StateManager.resetCurrentItemForLoop();\n      const currentMode = StateManager.getPlaybackMode();\n      if (currentMode === 'random') {\n        logProbe('(指挥) 检测到随机模式，向作曲家索要新乐谱...');\n        const genesisPlan = (StrategyManager.getCurrentStrategy() as RandomStrategy).prepareGenesis(\n          StateManager.getTopQueueItem(),\n        );\n        if (genesisPlan) {\n          StateManager.commitGenesisState(\n            genesisPlan.newCurrentIndex,\n            genesisPlan.newPlaybackPlan,\n            genesisPlan.newPlanIndex,\n          );\n        }\n      }\n      const finalStartIndex = StateManager.getTopQueueItem()?.currentIndex ?? 0;\n      logProbe(`(指挥) 流程完成。最终确定的新起始索引为: ${finalStartIndex}`);\n      needsAsyncEffect = true;\n      targetIndex = finalStartIndex;\n      break;\n    }\n\n    case 'Stop': {\n      logProbe('[CentralCommand] 指令: Stop。停止播放。');\n      StateManager.setPlaybackState('STOPPED');\n      break;\n    }\n\n    case 'DoNothing':\n    default:\n      logProbe(`[CentralCommand] 指令: DoNothing。无状态变更。`);\n      break;\n  }\n\n  if (decision.action !== 'RemoveTopAndAdvance') {\n    broadcastFullState();\n  }\n\n  const directive = { needsAsyncEffect, targetIndex };\n  logProbe(\n    `[CentralCommand] 决策应用完成。返回指令: { needsAsyncEffect: ${directive.needsAsyncEffect}, targetIndex: ${directive.targetIndex ?? 'N/A'} }`,\n  );\n  logProbe('', 'groupEnd');\n  return directive;\n}\n\n/**\n * @description [V9.6 净化] 释放效果锁并广播最终状态。\n *              这是所有异步控制器 finally 块中的标准“谢幕”程序。\n */\nasync function _releaseEffectLock() {\n  // 探针: 记录锁释放的动作，这对于调试UI卡死问题至关重要\n  logProbe('[LockManager] 正在释放效果锁并广播最终状态...');\n\n  StateManager.setPerformingEffect(false);\n  broadcastFullState();\n}\n\nasync function _handleTrackEnded() {\n  logProbe('[Controller:TrackEnd] === 开始处理轨道自然结束事件 ===', 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:TrackEnd] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:TrackEnd] 请求中止：队列为空。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().onTrackEnd(currentItem);\n    const directive = await _applyNavigationDecision(decision);\n\n    if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    }\n  } catch (error) {\n    logProbe(`[Controller:TrackEnd] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('trackEnded');\n    logProbe('[Controller:TrackEnd] === 轨道结束事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 8. 全局API与事件系统 (Global API & Event System)\n// =================================================================\n\nasync function _handleNavigation(direction: 'next' | 'prev') {\n  logProbe(`[Controller:Nav] === 开始处理用户导航事件 (方向: ${direction}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:Nav] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe(`[Controller:Nav] 请求中止：队列为空。`);\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().advance(currentItem, direction);\n    const directive = await _applyNavigationDecision(decision);\n\n    logProbe(\n      `[Controller:Nav] (探针) 原始决策: ${decision.action}, 处理指令: needsAsyncEffect=${directive.needsAsyncEffect}`,\n    );\n\n    if (decision.action === 'Restart') {\n      logProbe(`[Controller:Nav] 检测到 Restart 决策，执行 seek(0) 效果。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n      if (StateManager.getPlaybackMode() !== 'single') {\n        toastr.info('已是第一首');\n      }\n    } else if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    } else if (decision.action === 'DoNothing') {\n      toastr.info(direction === 'next' ? '已是歌单最后一首。' : '已是歌单第一首。');\n    }\n  } catch (error) {\n    logProbe(`[Controller:Nav] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('navigation');\n    logProbe(`[Controller:Nav] === 用户导航事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\n/**\n * [内部核心] 执行创世播放的实际逻辑。\n * 注意：此函数不检查也不设置效果锁，调用者必须确保已持有锁。\n */\nasync function _executeGenesisPlayInternal(targetIndex: number) {\n  logProbe(`[Internal:Genesis] (动作) 执行内部创世播放逻辑 (目标索引: ${targetIndex})...`);\n  StateManager.setPlaybackState('PLAYING');\n  broadcastFullState();\n  await _executeTransition(targetIndex);\n}\n\nasync function _handleGenesisPlay() {\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Genesis] 请求被拒绝，因为效果正在执行。', 'warn');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Genesis] 请求中止：播放列表为空。');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe(`[Controller:Genesis] === “创世播放”效果开始 (目标索引: ${currentItem.currentIndex}) ===`, 'group');\n\n    await _executeGenesisPlayInternal(currentItem.currentIndex);\n  } catch (error) {\n    logProbe(`[Controller:Genesis] “创世播放”效果执行时发生意外顶层错误: ${error}`, 'error');\n    StateManager.setPlaybackState('STOPPED');\n    broadcastFullState();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('genesisPlay');\n    logProbe(`[Controller:Genesis] === “创世播放”效果结束 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function _handlePlayIndex(index: number) {\n  logProbe(`[Controller:PlayIndex] === 开始处理索引播放事件 (目标: ${index}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:PlayIndex] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentItem = StateManager.getTopQueueItem();\n    const currentMode = StateManager.getPlaybackMode();\n\n    if (currentItem && index === currentItem.currentIndex) {\n      logProbe(`[Controller:PlayIndex] (决策) 用户点击了当前歌曲，将从头重播。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n    } else if (currentMode === 'list' || currentMode === 'single') {\n      logProbe(`[Controller:PlayIndex] (决策) ${currentMode} 模式，执行标准跳转...`);\n      StateManager.setCurrentIndex(index);\n      await _executeTransition(index);\n    } else if (currentMode === 'random') {\n      logProbe(`[Controller:PlayIndex] (决策) random 模式，执行“用户跳转”高级逻辑...`);\n      StateManager.userInitiatedJump(index);\n      await _executeTransition(index);\n    }\n  } catch (error) {\n    logProbe(`[Controller:PlayIndex] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('playIndex');\n    logProbe(`[Controller:PlayIndex] === 索引播放事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function togglePlayPause() {\n  logProbe('[Controller:Toggle] === 开始处理播放/暂停切换事件 (三态机版) ===', 'group');\n\n  // 1. 效果锁检查\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Toggle] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  // 2. 空队列检查\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Toggle] 请求中止：播放列表为空。');\n    toastr.info('播放列表为空');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    // 3. 上锁并广播\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentState = StateManager.getPlaybackState();\n    logProbe(`[Controller:Toggle] 当前状态: ${currentState}`);\n\n    switch (currentState) {\n      case 'STOPPED': {\n        // [核心] 这是首次播放意图的关键点\n        logProbe('[Controller:Toggle] 决策: STOPPED -> PLAYING (视为创世播放)');\n\n        StateManager.setPlaybackState('PLAYING');\n        broadcastFullState();\n\n        // 尝试播放当前队首\n        // 如果是刚加载的歌单，currentIndex 应该是 0，或者是记忆中的位置\n        await _executeTransition(currentItem.currentIndex);\n        break;\n      }\n\n      case 'PLAYING': {\n        logProbe('[Controller:Toggle] 决策: PLAYING -> PAUSED');\n        StateManager.setPlaybackState('PAUSED');\n        broadcastFullState();\n        await PlaybackEngine.fadeOutAndPause();\n        break;\n      }\n\n      case 'PAUSED': {\n        logProbe('[Controller:Toggle] 决策: PAUSED -> PLAYING (恢复)');\n        StateManager.setPlaybackState('PLAYING');\n        broadcastFullState();\n        await PlaybackEngine.resumeAndFadeIn(StateManager.getVolume());\n        break;\n      }\n    }\n  } catch (error) {\n    logProbe(`[Controller:Toggle] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('togglePlayPause');\n    logProbe('[Controller:Toggle] === 播放/暂停切换事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\nfunction playNext() {\n  void _handleNavigation('next');\n}\n\nfunction playPrev() {\n  void _handleNavigation('prev');\n}\n\nfunction setupGlobalAPI() {\n  window.musicPlayerAPI = {\n    requestInitialization: (): Promise<void> => {\n      if (isInitializedForThisChat) {\n        logProbe('[API] requestInitialization (已完成): 一个迟到的界面发来请求，立即返回成功契约。');\n        broadcastFullState();\n        return Promise.resolve();\n      }\n\n      if (!_initializationPromise) {\n        logProbe('[API] requestInitialization (首次): 第一个界面请求到达，正在创建【共享的】Promise契约...');\n        _initializationPromise = new Promise((resolve, reject) => {\n          _initializationPromiseControls = { resolve, reject };\n        });\n      } else {\n        logProbe('[API] requestInitialization (后续): 又一个界面请求到达，返回【已存在的】共享契约。');\n      }\n\n      return _initializationPromise;\n    },\n\n    togglePlayPause: () => togglePlayPause(),\n    playNext: () => playNext(),\n    playPrev: () => playPrev(),\n    playIndex: (index: number) => {\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem && index >= 0 && index < currentItem.playlistContent.length) {\n        void _handlePlayIndex(index);\n      }\n    },\n    persistVolumeAndBroadcast: (volume: number) => {\n      const finalVolume = Math.max(0, Math.min(1, volume));\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      StateManager.setVolume(finalVolume);\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = finalVolume;\n      void writeState('persistVolume');\n      broadcastFullState();\n    },\n    setLiveVolume: (volume: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = Math.max(0, Math.min(1, volume));\n    },\n\n    setPlaybackMode: (mode: PlaybackMode) => {\n      logProbe(`=== 开始执行【模式切换】事务 (请求: ${mode}) ===`, 'group');\n      const oldMode = StateManager.getPlaybackMode();\n      if (mode === oldMode) {\n        logProbe(`[ModeSwitch] 模式未变更 (仍为 ${mode})，事务提前中止。`);\n        logProbe('', 'groupEnd');\n        return;\n      }\n\n      StateManager.setPlaybackMode(mode);\n      StrategyManager.setMode(mode);\n\n      logProbe(`[ModeSwitch] 策略已切换为: ${StrategyManager.getCurrentStrategy().constructor.name}`);\n\n      if (oldMode === 'random') {\n        logProbe('[ModeSwitch] 正在为旧模式 \"random\" 执行“离开”生命周期钩子...');\n        StateManager.clearRandomModePlan();\n      }\n      if (mode === 'random') {\n        logProbe('[ModeSwitch] 正在为新模式 \"random\" 执行“进入”生命周期钩子...');\n        StrategyManager.notifyQueueChanged();\n      }\n\n      void writeState('setPlaybackMode');\n      broadcastFullState();\n      logProbe('=== 【模式切换】事务执行完毕 ===', 'groupEnd');\n    },\n    seekTo: (percentage: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer?.duration) activePlayer.currentTime = activePlayer.duration * percentage;\n    },\n    getCurrentState: (): FullStatePayload => {\n      const i = StateManager.getTopQueueItem();\n      const c = i?.playlistContent ?? [];\n      const x = i?.currentIndex ?? 0;\n      const stateToReturn: FullStatePayload = {\n        currentItem: c[x] ? { title: c[x].歌名, artist: c[x].歌手, cover: c[x].封面 } : null,\n        isPlaying: StateManager.isPlaying(),\n        playbackState: StateManager.getPlaybackState(),\n        playbackMode: StateManager.getPlaybackMode(),\n        masterVolume: StateManager.getVolume(),\n        playlist: c.map(t => ({ title: t.歌名, artist: t.歌手, cover: t.封面 })),\n        isTransitioning: StateManager.isPerformingEffect(),\n      };\n      logProbe('[探针 B] 前端主动调用 getCurrentState 获取初始状态，后台返回的数据如下:', 'warn');\n      console.dir(stateToReturn);\n      return stateToReturn;\n    },\n\n    onFullStateUpdate: (c: (payload: FullStatePayload) => void) => {\n      if (typeof c === 'function') {\n        fullStateUpdateCallbacks.push(c);\n        logProbe(`[API] 前端注册了 fullStateUpdate 监听器。当前监听数: ${fullStateUpdateCallbacks.length}`);\n\n        return () => {\n          const index = fullStateUpdateCallbacks.indexOf(c);\n          if (index > -1) {\n            fullStateUpdateCallbacks.splice(index, 1);\n            logProbe(`[API] 前端注销了 fullStateUpdate 监听器。剩余监听数: ${fullStateUpdateCallbacks.length}`);\n          }\n        };\n      }\n\n      return () => {};\n    },\n\n    onTimeUpdate: (c: (payload: TimeUpdatePayload) => void) => {\n      if (typeof c === 'function') {\n        timeUpdateCallbacks.push(c);\n\n        return () => {\n          const index = timeUpdateCallbacks.indexOf(c);\n          if (index > -1) {\n            timeUpdateCallbacks.splice(index, 1);\n          }\n        };\n      }\n      return () => {};\n    },\n  };\n  initializeGlobal('musicPlayerAPI', window.musicPlayerAPI);\n}\n\n// =================================================================\n// 9. 酒馆集成与主执行区 (Tavern Integration & Main Execution)\n// =================================================================\n\nfunction executeHardReset() {\n  logProbe('[HardReset] “优雅停机”协议启动...', 'warn');\n\n  isScriptActive = false;\n\n  PlaybackEngine.getActivePlayer()?.pause();\n  logProbe('[HardReset] 音频已暂停。');\n\n  logProbe('[HardReset] 即将调用 reloadIframe()。');\n  reloadIframe();\n}\n\nasync function tryInitialize() {\n  if (isInitializedForThisChat) return;\n\n  const currentChatId = SillyTavern.getCurrentChatId ? SillyTavern.getCurrentChatId() : null;\n\n  if (SillyTavern.chat.length > 0 && currentChatId !== null) {\n    // [原则: SRP] isInitializedForThisChat 标志现在是这个函数的“守卫”，确保初始化只执行一次。\n    isInitializedForThisChat = true;\n    _currentChatId = currentChatId;\n\n    logProbe(`【初始化指挥官 V9.8】锁定ID: ${_currentChatId}，开始执行“分流-等待-执行”协议...`, 'group');\n\n    try {\n      // --- 步骤一：检测 (Detect) ---\n      // [原则: SSoT] 初始化流程的第一个动作，就是获取“世界书”这个唯一事实来源。\n      const config = await parseWorldbookConfig();\n      if (!config) {\n        throw new Error('无法解析世界书配置，初始化中止。');\n      }\n\n      const isMvuCard = config.triggers && Array.isArray(config.triggers) && config.triggers.length > 0;\n      logProbe(`(探针-决策) 作者意图判断 -> 是MVU卡吗? ${isMvuCard}`);\n\n      // --- 步骤二：分流 (Branch) & 等待 (Wait) ---\n      if (isMvuCard) {\n        logProbe('【指挥官】(路径选择) 检测到MVU卡，进入“安全路径”，开始等待MVU就绪...');\n        // [原则: CQS] _waitForMvuGenesis 是一个“查询”，它询问外部环境状态，直到满足条件。\n        const mvuIsReady = await _waitForMvuGenesis();\n        if (!mvuIsReady) {\n          throw new Error('MVU集成初始化失败或超时，部分功能将不可用。');\n        }\n        logProbe('【指挥官】MVU已完全就绪，可以安全继续。');\n      } else {\n        logProbe('【指挥官】(路径选择) 检测到纯文字卡，进入“快速路径”。');\n      }\n\n      // --- 步骤三：执行 (Execute) ---\n      logProbe('【指挥官】所有前置条件满足，开始执行播放器核心初始化...');\n\n      let authoritativeState = null;\n      if (isMvuCard) {\n        logProbe('【指挥官】(查询) 正在为MVU卡查找权威状态...');\n        authoritativeState = await _findLatestAuthoritativeMvuState();\n      } else {\n        logProbe('【指挥官】(跳过) 纯文字卡，无需查找MVU状态。');\n      }\n\n      await initializePlayerForChat(config, authoritativeState);\n\n      _registerContextualEventListeners();\n\n      if (_initializationPromiseControls) {\n        logProbe('【指挥官】(探针) 后台初始化成功，兑现 Promise 契约，唤醒前端。');\n        _initializationPromiseControls.resolve();\n      }\n    } catch (error) {\n      logProbe(`【指挥官】在初始化主流程中发生严重错误: ${error}`, 'error');\n      // 如果发生任何错误，都要通知前端，让它显示错误信息\n      if (_initializationPromiseControls) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        _initializationPromiseControls.reject(errorMessage);\n      }\n    } finally {\n      _initializationPromiseControls = null;\n      logProbe('【初始化指挥官 V9.8】协议执行完毕。', 'groupEnd');\n    }\n  }\n}\n\nfunction _registerMvuEventListeners() {\n  logProbe('[EventDispatcher] 正在注册【运行时】MVU 事件监听器...');\n\n  const createReconcileHandler = (eventName: string) => {\n    return (eventPayload?: any) => {\n      if (!isMvuIntegrationActive || !isCorePlayerInitialized) {\n        logProbe(`[Gatekeeper] 捕获到MVU事件 (${eventName})，但系统未就绪，已忽略。`, 'warn');\n        return;\n      }\n      logProbe(`[Event] 捕获到MVU事件: ${eventName}，即将唤醒校准官...`);\n      // (SSoT原则) 将事件载荷这个“事实”直接传递给校准官\n      void _reconcilePlaylistQueue(eventPayload);\n    };\n  };\n\n  eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, createReconcileHandler('VARIABLE_UPDATE_ENDED'));\n\n  eventOn(tavern_events.MESSAGE_DELETED, (deletedId: number) => {\n    logProbe(`[EventAdapter] 捕获到删除事件 (原ID: ${deletedId})，正在通过“高级历史通道”触发全量校准...`);\n    void _handleHistoryChangeEvent('MESSAGE_DELETED');\n  });\n\n  logProbe('[EventDispatcher] MVU监听器部署完毕。');\n}\n\n/**\n * [V9.1 核心处理器] 统一处理所有导致“运行时历史”变更的事件。\n * 职责：重新查找权威状态，然后调用校准官进行状态同步。\n * @param eventName - 触发此处理器的事件名，用于日志记录。\n */\nasync function _handleHistoryChangeEvent(eventName: string, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  logProbe(`[HistoryChange] 检测到历史变更事件: ${eventName}。`);\n  if (!isCorePlayerInitialized) return;\n\n  if (triggers.length === 0) {\n    logProbe('[HistoryChange] (分流) 检测到纯文字模式 (无触发器)，跳过MVU状态查询与校准，直接执行 UI 检查。');\n    await _ensureUiVisibility();\n    return;\n  }\n\n  logProbe(`[HistoryChange-Probe] 正在查询最新的权威MVU状态...`);\n  const authoritativeState = await _findLatestAuthoritativeMvuState();\n\n  if (!authoritativeState?.mvuData) {\n    logProbe('[HistoryChange] (守门员) 未找到有效的权威状态。这在AI重新生成期间是正常现象。', 'warn');\n    logProbe('[HistoryChange] (守门员) 采取“静默等待”策略，本次校准已跳过。');\n    return;\n  }\n\n  console.log(`[HistoryChange-Probe] 查询完毕，这是找到的权威状态数据，请您审查：`);\n  console.dir(_.cloneDeep(authoritativeState?.mvuData));\n\n  await _reconcilePlaylistQueue(authoritativeState?.mvuData, options);\n\n  await _ensureUiVisibility();\n}\n\n/**\n * [V9.9 核心修正] 处理新AI消息渲染事件的专用处理器。\n * 它的职责是检查并立即注入 <playmusic/> 标签，以修复刷新竞态条件BUG。\n * (SRP: Single Responsibility Principle)\n * @param messageId - 由事件传来的消息ID。\n */\nasync function _handleNewAssistantMessage(messageId: number): Promise<void> {\n  logProbe(`[Injector] 捕获到 CHARACTER_MESSAGE_RENDERED 事件，message_id: ${messageId}`);\n\n  if (messageId === 0) {\n    logProbe(`[Injector] (探针) 操作中止：message_id 为 0 (开场白)，权限属于作者，无需注入。`);\n    return;\n  }\n\n  const topQueueItem = StateManager.getTopQueueItem();\n  if (!topQueueItem) {\n    logProbe(`[Injector] (守门员) 拒绝注入：当前播放队列为空。`);\n    return;\n  }\n\n  try {\n    const message = getChatMessages(messageId)?.[0];\n\n    if (message && message.role !== 'user' && !message.message.includes('<DarkBramblePlayer/>')) {\n      logProbe(`[Injector] (探针) 条件满足，立即为 message_id: ${messageId} 执行注入...`);\n\n      await setChatMessages([{ message_id: messageId, message: `${message.message}\\n<DarkBramblePlayer/>` }]);\n\n      logProbe(`[Injector] (探针) 注入成功。`);\n    } else {\n      logProbe(`[Injector] (探针) 操作跳过：消息是用户发送的，或已包含标签。Role: ${message?.role}`);\n    }\n  } catch (error) {\n    logProbe(`[Injector] 为 message_id: ${messageId} 注入标签时发生严重错误:`, 'error');\n    console.error(error);\n  }\n}\n\n/**\n * [V9.95 新增] UI 可见性卫士。\n * 职责：在 MVU 延迟加载或消息删除后，确保如果音乐在播放，界面一定存在。\n * 原则：SSoT (以队列状态为准), 鲁棒性 (补救缺失的 UI)\n */\nasync function _ensureUiVisibility() {\n  logProbe('[UiGuard] 正在检查界面一致性 (高性能局部扫描)...', 'groupCollapsed');\n\n  const topQueueItem = StateManager.getTopQueueItem();\n  if (!topQueueItem) {\n    logProbe('[UiGuard] 队列为空，无需 UI。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    // [步骤 1] 获取最后一条消息，作为定位锚点\n    // 参数 -1 表示获取最新的楼层\n    const lastMsgList = getChatMessages(-1);\n\n    if (!lastMsgList || lastMsgList.length === 0) {\n      logProbe('[UiGuard] 无法获取最新楼层锚点，检查中止。', 'warn');\n      logProbe('', 'groupEnd');\n      return;\n    }\n\n    // [步骤 2] 计算最近 10 楼的 ID 范围\n    // 假设最后一条 ID 是 100，我们想要 91-100 (共10条)\n    const lastId = lastMsgList[0].message_id;\n    // 使用 Math.max 确保不会算出负数 ID\n    const startId = Math.max(0, lastId - 9);\n    const rangeString = `${startId}-${lastId}`;\n\n    logProbe(`[UiGuard] 正在获取最近的 10 条消息 (ID范围: ${rangeString})...`);\n\n    // [步骤 3] 仅拉取这 10 条数据\n    // 接口支持 \"StartID-EndID\" 格式的字符串\n    const recentMessages = getChatMessages(rangeString);\n\n    if (!recentMessages || recentMessages.length === 0) {\n      logProbe('[UiGuard] 局部消息拉取为空，检查中止。', 'warn');\n      logProbe('', 'groupEnd');\n      return;\n    }\n\n    let foundTarget = false;\n\n    // [步骤 4] 倒序扫描这 10 条数据\n    for (let i = recentMessages.length - 1; i >= 0; i--) {\n      const msg = recentMessages[i];\n\n      // 1. 跳过用户消息\n      if (msg.role === 'user') {\n        continue;\n      }\n\n      // 2. 遇到开场白停止 (尊重作者排版)\n      if (msg.message_id === 0) {\n        logProbe('[UiGuard] 回溯至开场白，停止。');\n        break;\n      }\n\n      // 3. 检查是否已有标签\n      if (msg.message && msg.message.includes('<DarkBramblePlayer/>')) {\n        logProbe(`[UiGuard] 在 message_id: ${msg.message_id} 处发现已有标签，状态正常。`);\n        foundTarget = true;\n        break;\n      }\n\n      // 4. 执行注入\n      logProbe(`[UiGuard] 发现目标宿主: message_id: ${msg.message_id} (${msg.role})，执行补救注入...`);\n      const newContent = `${msg.message}\\n<DarkBramblePlayer/>`;\n\n      await setChatMessages([\n        {\n          message_id: msg.message_id,\n          message: newContent,\n        },\n      ]);\n\n      logProbe('[UiGuard] 补救注入成功。');\n      foundTarget = true;\n      break;\n    }\n\n    if (!foundTarget) {\n      logProbe('[UiGuard] 在最近 10 条消息中未发现合适的注入点。');\n    }\n  } catch (error) {\n    logProbe(`[UiGuard] 执行补救注入时发生错误: ${error}`, 'error');\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * [V9.0 核心] 执行一次“软重置”。\n * 这将在不刷新整个页面的情况下，重新执行完整的初始化流程。\n * 用于响应“开场白滑动”等根本性的上下文变更。\n */\nasync function _executeSoftReset(options?: { autoPlayIfWasPlaying?: boolean }) {\n  logProbe('[SoftReset] 检测到根本性上下文变更，启动“软重置”协议...', 'warn');\n  try {\n    const config = await parseWorldbookConfig();\n\n    logProbe('[SoftReset] 正在为新的开场白查找权威MVU状态...');\n    const authoritativeState = await _findLatestAuthoritativeMvuState();\n\n    await initializePlayerForChat(config, authoritativeState, options);\n  } catch (error) {\n    logProbe('[SoftReset] 软重置过程中发生严重错误。', 'error');\n    console.error(error);\n  }\n}\n\nfunction _registerContextualEventListeners() {\n  logProbe('[EventDispatcher] 正在注册“上下文专属”事件监听器...');\n\n  eventOn(tavern_events.CHARACTER_MESSAGE_RENDERED, (id: number) => {\n    void _handleNewAssistantMessage(id);\n  });\n\n  eventOn(tavern_events.MESSAGE_SWIPED, (id: number) => {\n    logProbe(`[Event] 捕获到滑动事件 (message_id: ${id})。`);\n    if (!isCorePlayerInitialized) return;\n\n    if (id === 0) {\n      logProbe('[Event-Swipe] 判断为开场白滑动，执行软重置...');\n      const wasPlaying = StateManager.isPlaying();\n      logProbe(`[Event-Swipe] (探针) 软重置前的播放状态: ${wasPlaying}`);\n      void _executeSoftReset({ autoPlayIfWasPlaying: wasPlaying });\n    } else {\n      logProbe('[Event-Swipe] 判断为历史消息滑动，执行历史变更处理...');\n      void _handleHistoryChangeEvent('MESSAGE_SWIPED', { transitionEffect: 'hard' });\n    }\n  });\n\n  logProbe('[EventDispatcher] “上下文专属”事件监听器注册完毕。');\n}\n\n/**\n * [原则: SRP] 这个函数的单一职责是：作为一个返回 Promise 的“观察哨”，\n * 它只负责“等待MVU创世完成”这一件事。成功则 resolve(true)，失败或超时则 resolve(false)。\n * 所有后续操作（如注册事件）都作为成功后的“副作用”在内部执行。\n */\nasync function _waitForMvuGenesis(): Promise<boolean> {\n  logProbe('【安全观察哨】已上岗，开始执行MVU就绪检查...', 'group');\n\n  try {\n    // [探针] 阶段一：等待 MVU 框架本身出现\n    await waitGlobalInitialized('Mvu');\n    logProbe('【观察哨】(探针) 阶段一成功：MVU 框架已加载。');\n  } catch (e) {\n    logProbe(`【观察哨】(探针) 阶段一失败: ${e}。`, 'warn');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段二：轮询观察，等待 MVU 将初始数据写入消息楼层\n  const WATCHER_TIMEOUT = 10000;\n  const WATCHER_INTERVAL = 250;\n  const startTime = Date.now();\n  let isGenesisComplete = false;\n\n  logProbe('【观察哨】(探针) 阶段二开始：正在严密监视 message_id: 0 的创世数据...');\n  while (Date.now() - startTime < WATCHER_TIMEOUT) {\n    try {\n      const mvuData: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n      if (mvuData && (mvuData.swipes_data || mvuData.stat_data)) {\n        logProbe('【观察哨】(探针) 阶段二成功：在消息楼层中确认到创世数据！');\n        isGenesisComplete = true;\n        break;\n      }\n    } catch (error) {\n      /* 在MVU启动初期，查询失败是正常现象，静默处理 */\n    }\n    await new Promise(resolve => setTimeout(resolve, WATCHER_INTERVAL));\n  }\n\n  if (!isGenesisComplete) {\n    logProbe('【观察哨】(探针) 阶段二失败：观察超时！', 'error');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段三：所有条件满足，执行激活序列\n  logProbe('【观察哨】(探针) 阶段三开始：执行MVU集成激活序列...');\n  try {\n    _registerMvuEventListeners();\n    isMvuIntegrationActive = true;\n    logProbe('【观察哨】(探针) 阶段三成功：MVU集成已完全激活。');\n    logProbe('【安全观察哨】任务成功完成！', 'groupEnd');\n    return true;\n  } catch (error) {\n    logProbe(`【观察哨】(探针) 阶段三失败：激活序列发生意外崩溃: ${error}`, 'error');\n    isMvuIntegrationActive = false;\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n}\n\n$(() => {\n  logProbe('音乐播放器脚本 V8.4 “上下文感知” 启动');\n  PlaybackEngine.initialize();\n  setupGlobalAPI();\n\n  eventOn(tavern_events.CHAT_CHANGED, () => {\n    logProbe(`[硬重置] CHAT_CHANGED 事件触发，检测到聊天上下文变更。即将执行“优雅停机”协议。`, 'warn');\n    executeHardReset();\n  });\n\n  const observerInterval = setInterval(() => {\n    void tryInitialize();\n    if (isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化成功，观察者已销毁。');\n    }\n  }, 250);\n\n  setTimeout(() => {\n    if (!isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化超时！', 'error');\n\n      if (_initializationPromiseControls) {\n        _initializationPromiseControls.reject('Initialization timed out after 10 seconds.');\n        _initializationPromiseControls = null;\n      }\n    }\n  }, 10000);\n\n  $(window).on('pagehide', () => {\n    logProbe('PAGEHIDE 事件触发！', 'warn');\n\n    PlaybackEngine.getActivePlayer()?.pause();\n    logProbe('音频已暂停。');\n  });\n});\n"],"names":["z","performance","now","ZodTrackConfig","object","string","optional","url","message","strict","ZodSingleCondition","variable_path","greater_than","number","greater_than_or_equal_to","less_than","less_than_or_equal_to","value","union","boolean","value_contains","time_in_range","regex","ZodTriggerConfig","type","literal","playlist_id","priority","default","conditions","array","nonempty","ZodPlaylistConfig","id","onFinishRule","enum","tracks","ZodWorldbookConfig","default_playlist_id","playlists","triggers","ZodQueueItemState","playlistId","currentIndex","playedIndices","wasEverPlayed","triggerSource","ZodPersistedState","active_queue","mode","volume","min","max","last_active_swipe_id","nullable","finished_base_playlists","previousMvuState","record","any","STATE_KEY_MVU_HISTORY","_parseTimeToMinutes","timeStr","cleanStr","trim","replace","match","hours","parseInt","minutes","MvuManager","_previousMvuState","_checkTriggerCondition","trigger","statData","condition","currentValue","_","get","conditionMet","isHandled","undefined","includes","currentTimeInMinutes","startStr","endStr","split","startMinutes","endMinutes","checkTriggerCondition","initialize","savedState","getVariables","error","resetState","persistCurrentState","currentStateData","isScriptActive","cloneDeep","updateVariablesWith","vars","getPreviousState","calculateChangeReport","previousStateData","allTriggers","report","newlyActiveTriggers","newlyInactiveTriggers","wasMet","isMet","push","length","StateManager","_activePlaylistQueue","_lastActiveSwipeId","_finishedBasePlaylists","Set","_playbackMode","_masterVolume","_playbackState","_isPerformingEffect","_applyDepartureIsHistoryPrinciple","item","departingIndex","add","getPlaybackMode","getVolume","isPlaying","getPlaybackState","isPerformingEffect","getTopQueueItem","getQueue","getStateSnapshotForRuntime","playbackState","getStateSnapshotForPersistence","map","omit","Array","from","clear","loadState","stateToLoad","size","setPlaybackMode","setVolume","setPlaybackState","newState","setPerformingEffect","isPerforming","getLastActiveSwipeId","setLastActiveSwipeId","getFinishedBasePlaylists","addToFinishedBasePlaylists","clearFinishedBasePlaylists","updateQueue","newQueue","sort","a","b","setCurrentIndex","index","currentItem","commitNavigationStep","newTrackIndex","playbackPlan","newPlanIndex","indexOf","planIndex","clearHistoryForCurrentItem","resetCurrentItemForLoop","commitGenesisState","newCurrentIndex","newPlaybackPlan","userInitiatedJump","trackIndex","this","clearRandomModePlan","applyNewPlaybackPlan","plan","PlaybackEngine","_playerA","_playerB","_activePlayer","_standbyPlayer","_fadeInterval","_fadeVolumeAsync","player","targetVolume","duration","Promise","resolve","clearInterval","startVolume","steps","volumeStep","currentStep","window","setInterval","createPlayer","audio","Audio","preload","crossOrigin","addEventListener","async","broadcastFullState","decision","StrategyManager","getCurrentStrategy","onTrackEnd","directive","_applyNavigationDecision","needsAsyncEffect","targetIndex","_executeTransition","_executeSelfHealingLoop","_releaseEffectLock","writeState","_handleTrackEnded","broadcastTimeUpdate","getActivePlayer","getStandbyPlayer","transitionToTrack","targetTrackUrl","slice","Error","standbyPlayer","activePlayer","src","load","reject","onCanPlay","removeEventListener","onError","e","target","pause","newActivePlayer","playPromise","play","fadeOutAndPause","executeHardCut","resumeAndFadeIn","ListStrategy","onQueueChanged","_currentItem","advance","direction","playlistContent","totalTracks","nextIndex","action","lastIndex","totalValidTracks","onPlaybackError","SingleStrategy","RandomStrategy","_generateIntelligentShuffle","allTrackIndices","sourceForShuffle","filter","i","has","j","Math","floor","random","join","_generatePlaybackPlan","shuffledIndices","knownSequence","_handlePlanEnd","allIndices","shuffled","prepareGenesis","nextPlanIndex","targetTrackIndex","prevPlanIndex","_strategies","list","single","_currentStrategy","setMode","notifyQueueChanged","constructor","name","STATE_KEY","isInitializedForThisChat","isReconciling","_initializationPromiseControls","_initializationPromise","allPlaylists","defaultPlaylistId","isMvuIntegrationActive","isCorePlayerInitialized","_currentChatId","fullStateUpdateCallbacks","timeUpdateCallbacks","_reconcilePlaylistQueue","eventPayload","options","oldTopItem","stat_data","_findLatestAuthoritativeMvuState","mvuData","changeReport","remove","some","inactiveTrigger","areTriggersFunctionallyEqual","activeTrigger","newItem","createQueueItem","newTopItem","transitionEffect","_executeGenesisPlayInternal","track","currentPlaylist","payload","title","artist","cover","playbackMode","masterVolume","playlist","isTransitioning","forEach","callback","currentTime","source","dataToSave","_formatZodErrorForToastr","issue","issues","path","toastrMessage","toastr","timeOut","getCanonicalString","Object","keys","key","String","conditionsA","conditionsB","every","val","context","messageId","swipeId","mvuDataContainer","Mvu","getMvuData","message_id","swipeSpecificData","swipes_data","allMessages","getChatMessages","include_swipes","currentMessageId","parseWorldbookConfig","ConfigMissingError","super","aggregatedConfig","_defaultPlaylistIdSourceFile","worldbookNames","getCharWorldbookNames","searchOrder","primary","additional","Boolean","foundAnyConfigEntry","bookName","configEntries","getWorldbook","entry","rawConfig","YAML","parse","content","validationResult","safeParse","success","data","p","_sourceFile","t","warningMsg","warning","closeButton","isGloballyValid","playlistsById","groupBy","errorMsg","allPlaylistIds","finalTriggers","playlistsAsMap","pl","normalizedTracks","decodeURIComponent","pop","defaultId","reconstituteQueueItem","persistedItem","playlistConfig","Infinity","triggeredBy","config","baseItem","initializePlayerForChat","authoritativeState","savedData","readState","currentStatData","authoritativeMessageId","finalQueue","correctBasePlaylistId","msgZero","currentSwipeId","swipe_id","currentGreeting","swipes","tagMatch","tagPlaylistId","lastSwipeId","fatalErrorMsg","healedQueue","prototype","hasOwnProperty","call","currentTrigger","find","initialTopItem","autoPlayIfWasPlaying","_handleGenesisPlay","freshItem","targetTrack","nextTrack","prepareNextTrack","consecutiveFailures","currentItemForThreshold","threshold","errorDecision","nextError","nextTopItem","nextTrackTitle","itemToRemove","currentQueue","shift","genesisPlan","finalStartIndex","_handleNavigation","info","setupGlobalAPI","musicPlayerAPI","requestInitialization","togglePlayPause","playNext","playPrev","playIndex","currentMode","_handlePlayIndex","persistVolumeAndBroadcast","finalVolume","setLiveVolume","oldMode","seekTo","percentage","getCurrentState","c","x","onFullStateUpdate","splice","onTimeUpdate","initializeGlobal","tryInitialize","currentChatId","SillyTavern","getCurrentChatId","chat","isMvuCard","isArray","waitGlobalInitialized","WATCHER_TIMEOUT","WATCHER_INTERVAL","startTime","Date","isGenesisComplete","setTimeout","createReconcileHandler","eventName","eventOn","events","VARIABLE_UPDATE_ENDED","tavern_events","MESSAGE_DELETED","deletedId","_handleHistoryChangeEvent","_registerMvuEventListeners","_waitForMvuGenesis","CHARACTER_MESSAGE_RENDERED","role","setChatMessages","_handleNewAssistantMessage","MESSAGE_SWIPED","wasPlaying","_executeSoftReset","errorMessage","_ensureUiVisibility","lastMsgList","lastId","rangeString","recentMessages","foundTarget","msg","newContent","$","CHAT_CHANGED","reloadIframe","observerInterval","on"],"ignoreList":[],"sourceRoot":""}