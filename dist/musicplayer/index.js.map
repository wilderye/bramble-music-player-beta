{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/musicplayer/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","console.log('音乐播放器脚本9.2.2版本');\n\n// =================================================================\n// 0. 诊断工具 (Diagnostic Tools)\n// =================================================================\nimport { z, ZodError } from 'zod';\ndeclare global {\n  interface Window {\n    musicPlayerAPI: any;\n  }\n}\nconst SCRIPT_LOAD_TIME = performance.now();\n\nfunction logProbe(message: string, type: 'log' | 'warn' | 'error' | 'group' | 'groupCollapsed' | 'groupEnd' = 'log') {\n  const timestamp = `(T+${(performance.now() - SCRIPT_LOAD_TIME).toFixed(0)}ms)`;\n  const finalMessage = `${timestamp} ${message}`;\n\n  switch (type) {\n    case 'warn':\n      console.warn(finalMessage);\n      break;\n    case 'error':\n      console.error(finalMessage);\n      break;\n    case 'group':\n      console.group(finalMessage);\n      break;\n    case 'groupCollapsed':\n      console.groupCollapsed(finalMessage);\n      break;\n    case 'groupEnd':\n      console.groupEnd();\n      break;\n    default:\n      console.log(finalMessage);\n  }\n}\n\n// =================================================================\n// 1. 类型定义 (Type Definitions)\n// =================================================================\n\ntype PlaylistItem = {\n  url: string;\n  歌名: string;\n  歌手?: string;\n  封面?: string;\n};\n\ntype PlaylistConfig = {\n  id: string;\n  tracks: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n};\n\ntype QueueItem = {\n  // --- 核心标识与排序依据 ---\n  playlistId: string;\n  priority: number;\n\n  // --- 内容与规则 ---\n  playlistContent: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n\n  // --- 状态记忆 ---\n  currentIndex: number;\n  playedIndices: Set<number>;\n  playbackPlan?: number[];\n  planIndex?: number;\n  wasEverPlayed: boolean;\n\n  // --- 溯源信息 ---\n  triggeredBy: 'base' | 'mvu';\n  triggerSource?: z.infer<typeof ZodTriggerConfig>;\n};\n\ntype PlaybackMode = 'list' | 'single' | 'random';\n\ntype FullStatePayload = {\n  currentItem: { title: string; artist?: string; cover?: string } | null;\n  isPlaying: boolean;\n  playbackState: 'STOPPED' | 'PLAYING' | 'PAUSED';\n  playbackMode: PlaybackMode;\n  masterVolume: number;\n  playlist: { title: string; artist?: string; cover?: string }[];\n  isTransitioning: boolean;\n};\n\ntype TimeUpdatePayload = {\n  currentTime: number;\n  duration: number;\n};\n\ntype StrategyDecision = {\n  action: 'GoTo' | 'RemoveTopAndAdvance' | 'Restart' | 'DoNothing' | 'LoopReset' | 'Stop';\n  nextIndex?: number;\n};\n\ninterface IPlaybackStrategy {\n  onQueueChanged(currentItem: QueueItem | undefined): void;\n  advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision;\n  onTrackEnd(currentItem: QueueItem): StrategyDecision;\n  onPlaybackError(currentItem: QueueItem): StrategyDecision;\n}\n\n// =================================================================\n// 1.1. Zod 边界防御 Schemas (Zod Border Defense Schemas)\n// -----------------------------------------------------------------\n// 探针: 这些 schemas 不仅仅是类型，它们是主动的验证器，是我们系统的第一道防线。\n//       每一个 `required_error` 和 `message` 都是一个内置的探针，当外部数据\n//       不符合我们的“法律”时，它们会自动报告错误。\n// 原则: 单一事实来源 (SSoT) - 关于外部数据应该长什么样的“真相”，只由这里定义。\n// =================================================================\n\n// 世界书音轨配置 Schema\nexport const ZodTrackConfig = z\n  .object({\n    歌名: z.string().optional(),\n    歌手: z.string().optional(),\n    封面: z.string().url({ message: '封面URL格式无效' }).optional(),\n    url: z.string().url({ message: '音轨URL格式无效' }),\n  })\n  .strict();\n\n// 定义一个“单一条件”\nexport const ZodSingleCondition = z\n  .object({\n    variable_path: z.string(),\n    greater_than: z.number().optional(),\n    greater_than_or_equal_to: z.number().optional(),\n    less_than: z.number().optional(),\n    less_than_or_equal_to: z.number().optional(),\n    value: z.union([z.string(), z.number(), z.boolean()]).optional(),\n    value_contains: z.string().optional(),\n    time_in_range: z\n      .string()\n      .regex(/^\\d{2}:\\d{2}-\\d{2}:\\d{2}$/, {\n        message: '时间范围格式必须是 \"HH:MM-HH:MM\"',\n      })\n      .optional(),\n  })\n  .strict();\n\n// 主触发器 Schema 引用“单一条件”的数组\nexport const ZodTriggerConfig = z\n  .object({\n    type: z.literal('mvu_variable'),\n    playlist_id: z.string(),\n    priority: z.number().default(0),\n    conditions: z.array(ZodSingleCondition).nonempty({ message: '触发器必须至少包含一个条件' }),\n  })\n  .strict();\n\n// 世界书歌单配置 Schema\nexport const ZodPlaylistConfig = z.object({\n  id: z.string(),\n  onFinishRule: z.enum(['loop', 'pop'], { message: \"onFinishRule 必须是 'loop' 或 'pop'\" }).default('loop'),\n  tracks: z.array(ZodTrackConfig).nonempty({ message: \"歌单的 'tracks' 列表不能为空\" }),\n});\n\n// 世界书总配置 Schema (这是我们将使用的顶级验证器)\nexport const ZodWorldbookConfig = z\n  .object({\n    default_playlist_id: z.string().optional(),\n    playlists: z.array(ZodPlaylistConfig).optional(),\n    triggers: z.array(ZodTriggerConfig).optional(),\n    is_mvu: z.boolean().optional(),\n  })\n  .strict();\n\n// 持久化状态 - 队列项 Schema\nexport const ZodQueueItemState = z.object({\n  playlistId: z.string(),\n  currentIndex: z.number().default(0),\n  playedIndices: z.array(z.number()).default([]),\n  wasEverPlayed: z.boolean().default(false),\n  triggerSource: ZodTriggerConfig.optional(),\n});\n\n// 持久化状态 - 总 Schema\nexport const ZodPersistedState = z.object({\n  active_queue: z.array(ZodQueueItemState),\n  mode: z.enum(['list', 'single', 'random']).default('list'),\n  volume: z.number().min(0).max(1).default(0.5),\n  last_active_swipe_id: z.number().nullable().default(null),\n  finished_base_playlists: z.array(z.string()).default([]),\n  previousMvuState: z.record(z.string(), z.any()).optional(),\n});\n\nconst STATE_KEY_MVU_HISTORY = '灰烬双星_MVU状态记忆';\n\n/**\n * [工具函数] 将多种格式的时间字符串解析为从午夜开始的分钟数。\n * 它的职责单一，且对输入格式有很强的容错能力。\n * @param timeStr - 例如 \"14:30\", \"8时5分\", \"22 : 00\"\n * @returns {number | null} 转换后的分钟数，或在无法解析时返回 null。\n */\nfunction _parseTimeToMinutes(timeStr: string): number | null {\n  // 探针: 记录传入的原始值，便于调试\n  if (!timeStr || typeof timeStr !== 'string') return null;\n\n  // 步骤1: 归一化输入，处理常见变体 (已修正 let -> const 和 replace 语法)\n  const cleanStr: string = timeStr.trim().replace('：', ':');\n\n  let match;\n\n  // 步骤2: 尝试匹配 \"HH:MM\" 格式 (最常见)\n  match = cleanStr.match(/^(\\d{1,2})\\s*:\\s*(\\d{1,2})$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    // 严格校验数值范围\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 步骤3: 尝试匹配 \"H时M分\" 格式\n  match = cleanStr.match(/^(\\d{1,2})\\s*时\\s*(\\d{1,2})\\s*分?$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 探针: 如果所有格式都匹配失败，记录下来\n  logProbe(`[TimeParser] 无法解析时间字符串: \"${timeStr}\"`, 'warn');\n\n  // [新增] 修复“缺少 return”的逻辑漏洞\n  return null;\n}\n\n// =================================================================\n// 2. MVU 管理器 (The MvuManager - \"The Analyst\")\n// =================================================================\nconst MvuManager = (() => {\n  logProbe('[MvuManager] 模块正在初始化...');\n\n  let _previousMvuState: Record<string, any> = {};\n\n  /**\n   * [核心算法 V2.1] 检查一个给定的 stat_data 是否满足一个触发器的所有条件。\n   * 新版已加固，支持多种匹配模式和 AND 条件组合，且代码风格已优化。\n   */\n  function _checkTriggerCondition(\n    trigger: z.infer<typeof ZodTriggerConfig>,\n    statData: Record<string, any> | null,\n  ): boolean {\n    if (!statData) return false;\n\n    // 遍历所有 AND 条件。只要有一个不满足，整个触发器就失败。\n    for (const condition of trigger.conditions) {\n      const currentValue = _.get(statData, condition.variable_path);\n\n      let conditionMet = false; // 当前条件是否满足\n      let isHandled = false; // 当前条件是否被任何一个匹配模式处理过\n\n      // 使用 if / else if 链条，确保每个条件项只采用一种匹配模式\n      if (condition.value_contains !== undefined) {\n        isHandled = true;\n        // [安全加固] 必须检查 currentValue 是字符串，否则 .includes() 会导致崩溃\n        if (typeof currentValue === 'string' && currentValue.includes(condition.value_contains)) {\n          conditionMet = true;\n        }\n      } else if (condition.time_in_range !== undefined) {\n        isHandled = true;\n        // [安全加固] 同样检查类型\n        if (typeof currentValue === 'string') {\n          const currentTimeInMinutes = _parseTimeToMinutes(currentValue);\n\n          if (currentTimeInMinutes !== null) {\n            const [startStr, endStr] = condition.time_in_range.split('-');\n            const startMinutes = _parseTimeToMinutes(startStr);\n            const endMinutes = _parseTimeToMinutes(endStr);\n\n            if (startMinutes !== null && endMinutes !== null) {\n              // [代码风格修正] 移除不必要的嵌套 if，使代码更简洁\n              if (startMinutes <= endMinutes) {\n                // 普通范围\n                conditionMet = currentTimeInMinutes >= startMinutes && currentTimeInMinutes <= endMinutes;\n              } else {\n                // 跨天范围\n                conditionMet = currentTimeInMinutes >= startMinutes || currentTimeInMinutes <= endMinutes;\n              }\n            }\n          }\n        }\n      } else if (condition.value !== undefined) {\n        isHandled = true;\n        if (currentValue === condition.value) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue > condition.greater_than) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue >= condition.greater_than_or_equal_to) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue < condition.less_than) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue <= condition.less_than_or_equal_to) {\n          conditionMet = true;\n        }\n      }\n\n      // [最终裁决] 如果这是一个空条件 (isHandled=false)，或条件不满足，则立即失败\n      if (!isHandled || !conditionMet) {\n        return false;\n      }\n    }\n\n    // 如果循环正常结束，说明所有 AND 条件都满足\n    return true;\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    checkTriggerCondition: _checkTriggerCondition,\n\n    /**\n     * [生命周期] 从酒馆变量中读取并恢复上一次的 MVU 状态。\n     */\n    initialize() {\n      logProbe('[MvuManager] (Lifecycle) 执行 initialize...');\n      try {\n        const savedState = getVariables({ type: 'chat' })[STATE_KEY_MVU_HISTORY];\n        if (savedState && typeof savedState === 'object') {\n          _previousMvuState = savedState;\n          logProbe('[MvuManager] 成功从存档中恢复了 MVU 历史状态。');\n        } else {\n          _previousMvuState = {};\n          logProbe('[MvuManager] 未发现有效的 MVU 历史存档，已初始化为空状态。', 'warn');\n        }\n      } catch (error) {\n        logProbe(`[MvuManager] 初始化时读取存档失败: ${error}`, 'error');\n        _previousMvuState = {};\n      }\n    },\n\n    resetState() {\n      logProbe('[MvuManager] (Lifecycle) 正在重置模块内部状态...');\n      _previousMvuState = {};\n      logProbe('[MvuManager] 模块状态已重置。');\n    },\n\n    /**\n     * [命令] 将当前的 MVU 状态持久化到酒馆变量中。\n     * @param currentStateData - 最新的 stat_data 对象。\n     */\n    async persistCurrentState(currentStateData: Record<string, any>) {\n      if (!isScriptActive) {\n        logProbe('[MvuManager] 持久化操作被阻止，因为脚本正在停机。', 'warn');\n        return;\n      }\n      logProbe('[MvuManager] (Command) 执行 persistCurrentState...');\n      _previousMvuState = _.cloneDeep(currentStateData);\n      try {\n        await updateVariablesWith(\n          vars => {\n            vars[STATE_KEY_MVU_HISTORY] = _previousMvuState;\n            return vars;\n          },\n          { type: 'chat' },\n        );\n        logProbe('[MvuManager] 已成功将当前 MVU 状态持久化。');\n      } catch (error) {\n        logProbe(`[MvuManager] 持久化 MVU 状态时发生严重错误: ${error}`, 'error');\n      }\n    },\n\n    /**\n     * [查询] 获取内存中存储的上一次的 MVU 状态。\n     */\n    getPreviousState: () => _.cloneDeep(_previousMvuState),\n\n    /**\n     * [核心查询] 计算新旧状态之间的“边沿变化”。\n     * @param previousStateData - 上一次的 stat_data。\n     * @param currentStateData - 最新的 stat_data。\n     * @param allTriggers - 从世界书解析出的所有有效触发器。\n     * @returns 报告对象，包含新激活和新失效的触发器列表。\n     */\n    calculateChangeReport(\n      previousStateData: Record<string, any>,\n      currentStateData: Record<string, any>,\n      allTriggers: z.infer<typeof ZodTriggerConfig>[],\n    ): {\n      newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n    } {\n      const report: {\n        newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n        newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      } = { newlyActiveTriggers: [], newlyInactiveTriggers: [] };\n\n      logProbe('[MvuManager] (Query) 正在计算状态变化报告 (\"边沿检测\")...', 'group');\n\n      logProbe('[Probe] 正在审查用于对比的新旧状态数据:');\n      console.log('上一份历史记忆 (previousStateData):');\n      console.dir(_.cloneDeep(previousStateData));\n      console.log('当前权威状态 (currentStateData):');\n      console.dir(_.cloneDeep(currentStateData));\n      // =======================================================\n\n      for (const trigger of allTriggers) {\n        const wasMet = _checkTriggerCondition(trigger, previousStateData);\n        const isMet = _checkTriggerCondition(trigger, currentStateData);\n\n        if (!wasMet && isMet) {\n          logProbe(`(探針) 新激活的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyActiveTriggers.push(trigger);\n        } else if (wasMet && !isMet) {\n          logProbe(`(探針) 新失效的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyInactiveTriggers.push(trigger);\n        }\n      }\n      logProbe(\n        `报告生成完毕: ${report.newlyActiveTriggers.length} 个新激活, ${report.newlyInactiveTriggers.length} 个新失效。`,\n      );\n      logProbe('', 'groupEnd');\n      return report;\n    },\n  };\n\n  logProbe('[MvuManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.X. 文本标签管理器 (The TextTagManager - \"The Bard\")\n// =================================================================\n/**\n * 职责 (SRP): 仅负责从历史文本中解析 <scene:xxx> 标签，将其转化为标准化的状态对象。\n * 它不负责播放，不负责决策，只负责“阅读”和“翻译”。\n */\nconst TextTagManager = (() => {\n  logProbe('[TextTagManager] 模块正在初始化 (吟游诗人引擎)...');\n\n  // 正则表达式：匹配 <scene: id >，允许冒号后有空格，捕获 id 部分\n  // 使用 'g' 标志以便我们在同一条消息中查找最后一个匹配项\n  const SCENE_TAG_REGEX = /<scene:\\s*([^>]+)\\s*>/g;\n\n  /**\n   * [核心算法] 滑动窗口回溯扫描。\n   * 性能: O(1) - 无论聊天记录多长，最多只拉取最近 20 条。\n   */\n  async function _getLatestState(): Promise<Record<string, any>> {\n    logProbe('[TextTagManager] (Query) 开始执行文本回溯扫描...', 'groupCollapsed');\n\n    try {\n      // 1. 确定锚点\n      const latestMsgs = getChatMessages(-1);\n      if (!latestMsgs || latestMsgs.length === 0) {\n        logProbe('[TextTagManager] 无法获取最新消息锚点，返回空状态。', 'warn');\n        logProbe('', 'groupEnd');\n        return { 'virtual.music_tag': null };\n      }\n\n      const lastId = latestMsgs[0].message_id;\n\n      // 2. 计算窗口 (最近 20 条)\n      const startId = Math.max(0, lastId - 19);\n      const rangeString = `${startId}-${lastId}`;\n      logProbe(`(探针) 扫描窗口确定: ${rangeString} (锚点ID: ${lastId})`);\n\n      // 3. 获取切片\n      const msgs = getChatMessages(rangeString);\n\n      // 4. 倒序遍历\n      for (let i = msgs.length - 1; i >= 0; i--) {\n        const msg = msgs[i];\n\n        // [过滤] 严格忽略用户的输入，防止用户通过发送标签操控 BGM\n        if (msg.role === 'user') {\n          continue;\n        }\n\n        // [解析] 在当前消息中寻找标签\n        // 逻辑: \"Last Match Wins\" (同一条消息里如果有多个标签，取最后一个)\n        const allMatches = [...msg.message.matchAll(SCENE_TAG_REGEX)];\n\n        if (allMatches.length > 0) {\n          // 取最后一个匹配项\n          const lastMatch = allMatches[allMatches.length - 1];\n          const rawId = lastMatch[1].trim();\n\n          // [归一化] 强制转小写，以匹配隐式生成的触发器\n          // 如果 ID 是 \"null\" (不分大小写)，则视为明确的“停止/空”指令\n          if (rawId.toLowerCase() === 'null') {\n            logProbe(`[TextTagManager] 在 message_id: ${msg.message_id} 找到明确的空指令 <scene:null>。`);\n            logProbe('', 'groupEnd');\n            return { 'virtual.music_tag': null };\n          }\n\n          const normalizedId = rawId.toLowerCase();\n          logProbe(\n            `[TextTagManager] 命中! 在 message_id: ${msg.message_id} 找到标签: \"${rawId}\" -> 归一化: \"${normalizedId}\"`,\n          );\n          logProbe('', 'groupEnd');\n          return { 'virtual.music_tag': normalizedId };\n        }\n\n        // [规则] 遇到第一条 AI 消息，即使没有标签，也必须停止扫描。\n        // \"无标签即停止\"原则：这意味着场景歌单的生命周期仅维持在有标签的那一楼。\n        // 这种设计避免了为了找一个标签而无限回溯历史。\n        logProbe(\n          `[TextTagManager] 在 message_id: ${msg.message_id} (AI) 中未发现标签。根据“无标签即空”原则，扫描结束。`,\n        );\n        logProbe('', 'groupEnd');\n        return { 'virtual.music_tag': null };\n      }\n\n      // 5. 兜底\n      logProbe('[TextTagManager] 扫描完窗口内所有消息，未发现有效 AI 消息。返回空状态。');\n      logProbe('', 'groupEnd');\n      return { 'virtual.music_tag': null };\n    } catch (error) {\n      logProbe(`[TextTagManager] 扫描过程中发生错误: ${error}`, 'error');\n      logProbe('', 'groupEnd');\n      return { 'virtual.music_tag': null };\n    }\n  }\n\n  const publicAPI = {\n    getLatestState: _getLatestState,\n  };\n\n  logProbe('[TextTagManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2. 状态管理器 (The State Manager) - [V2.0 重构版]\n// =================================================================\nconst StateManager = (() => {\n  logProbe('[StateManager] 模块正在初始化 (优先级队列内核)...');\n\n  // -------------------\n  // 2.1. 私有状态 (Private State)\n  // -------------------\n  // [重构] 核心数据结构变更为优先级队列\n  let _activePlaylistQueue: QueueItem[] = [];\n  let _lastActiveSwipeId: number | null = null;\n  let _finishedBasePlaylists: Set<string> = new Set();\n  let _playbackMode: PlaybackMode = 'list';\n  let _masterVolume: number = 0.5;\n  let _playbackState: 'STOPPED' | 'PLAYING' | 'PAUSED' = 'STOPPED';\n  let _isPerformingEffect: boolean = false;\n\n  // -------------------\n  // 2.2. 私有核心算法 (Private Core Algorithms)\n  // -------------------\n  function _applyDepartureIsHistoryPrinciple(item: QueueItem, departingIndex: number) {\n    if (typeof departingIndex !== 'number' || departingIndex < 0) return;\n    item.playedIndices.add(departingIndex);\n  }\n\n  // -------------------\n  // 2.3. 公共接口 (Public API)\n  // -------------------\n  const publicAPI = {\n    // --- 基础状态查询 ---\n    getPlaybackMode: () => _playbackMode,\n    getVolume: () => _masterVolume,\n    // [兼容性] 旧接口，仅当状态明确为 PLAYING 时返回 true\n    isPlaying: () => _playbackState === 'PLAYING',\n    getPlaybackState: () => _playbackState,\n    isPerformingEffect: () => _isPerformingEffect,\n\n    // --- [重构] 队列核心查询 ---\n    /**\n     * 获取当前优先级最高的歌单项（队首）。\n     * 这是系统唯一的事实来源：当前应该播放什么。\n     */\n    getTopQueueItem: (): QueueItem | undefined => _.cloneDeep(_activePlaylistQueue[0]),\n\n    /**\n     * 获取整个队列的副本（用于调试或决策分析）。\n     */\n    getQueue: (): QueueItem[] => _.cloneDeep(_activePlaylistQueue),\n\n    // --- 状态快照 ---\n    getStateSnapshotForRuntime: () => {\n      return _.cloneDeep({\n        active_queue: _activePlaylistQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        // [兼容性] 同时提供布尔值和枚举值\n        isPlaying: _playbackState === 'PLAYING',\n        playbackState: _playbackState,\n        isPerformingEffect: _isPerformingEffect,\n      });\n    },\n\n    getStateSnapshotForPersistence() {\n      const runtimeQueue = _.cloneDeep(_activePlaylistQueue);\n\n      const persistentQueue = runtimeQueue.map(item => {\n        const persistedItem = _.omit(item, ['playbackPlan', 'planIndex', 'playlistContent']);\n\n        return {\n          ...persistedItem,\n          // 将 Set 转换为 Array 以便 JSON 序列化\n          playedIndices: Array.from(item.playedIndices),\n        };\n      });\n\n      return {\n        active_queue: persistentQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        last_active_swipe_id: _lastActiveSwipeId,\n        finished_base_playlists: Array.from(_finishedBasePlaylists),\n      };\n    },\n\n    // --- 生命周期管理 ---\n    resetState() {\n      logProbe('[StateManager] 正在硬性重置所有状态...', 'warn');\n      _activePlaylistQueue = [];\n      _playbackMode = 'list';\n      _masterVolume = 0.5;\n      _playbackState = 'STOPPED';\n      _isPerformingEffect = false;\n      _lastActiveSwipeId = null;\n      _finishedBasePlaylists.clear();\n    },\n\n    loadState(stateToLoad: any) {\n      logProbe('[StateManager] 正在加载状态...', 'group');\n      _playbackMode = stateToLoad.mode;\n      _masterVolume = stateToLoad.volume;\n      _activePlaylistQueue = stateToLoad.active_queue || [];\n      _lastActiveSwipeId = stateToLoad.last_active_swipe_id ?? null;\n      _finishedBasePlaylists = new Set(stateToLoad.finished_base_playlists || []);\n      logProbe(\n        `(探针) 记忆加载完成: 上次SwipeID=${_lastActiveSwipeId}, 已完结基础歌单数=${_finishedBasePlaylists.size}`,\n      );\n      logProbe(\n        `状态加载完成. 队列深度: ${_activePlaylistQueue.length}, 模式: ${_playbackMode}, 音量: ${_masterVolume}`,\n      );\n      logProbe('', 'groupEnd');\n    },\n\n    // --- 基础状态设置 ---\n    setPlaybackMode: (mode: PlaybackMode) => {\n      _playbackMode = mode;\n    },\n    setVolume: (volume: number) => {\n      _masterVolume = volume;\n    },\n    setPlaybackState: (newState: 'STOPPED' | 'PLAYING' | 'PAUSED') => {\n      // [探针] 状态变更日志，帮助我们追踪每一次状态跳变\n      if (_playbackState !== newState) {\n        logProbe(`[StateManager] 状态流转: ${_playbackState} -> ${newState}`);\n      }\n      _playbackState = newState;\n    },\n    setPerformingEffect: (isPerforming: boolean) => {\n      _isPerformingEffect = isPerforming;\n    },\n\n    getLastActiveSwipeId: () => _lastActiveSwipeId,\n    setLastActiveSwipeId: (id: number | null) => {\n      _lastActiveSwipeId = id;\n    },\n\n    getFinishedBasePlaylists: () => new Set(_finishedBasePlaylists),\n\n    addToFinishedBasePlaylists: (playlistId: string) => {\n      logProbe(`[StateManager]将基础歌单 \"${playlistId}\" 刻入已完成列表。`);\n      _finishedBasePlaylists.add(playlistId);\n    },\n\n    clearFinishedBasePlaylists: () => {\n      logProbe(`[StateManager]清空记录。`);\n      _finishedBasePlaylists.clear();\n    },\n\n    // --- [重构] 队列核心操作 ---\n    /**\n     * [核心] 更新整个队列。\n     * 此方法会自动按优先级降序排列队列，确保 _activePlaylistQueue[0] 永远是优先级最高的。\n     */\n    updateQueue(newQueue: QueueItem[]) {\n      logProbe(`[StateManager] (Command) updateQueue: 正在更新并重排序队列 (共 ${newQueue.length} 项)...`);\n\n      _activePlaylistQueue = _.cloneDeep(newQueue).sort((a, b) => b.priority - a.priority);\n\n      if (_activePlaylistQueue.length > 0) {\n        logProbe(\n          `(探针) 新队首: \"${_activePlaylistQueue[0].playlistId}\" (优先级: ${_activePlaylistQueue[0].priority})`,\n        );\n      } else {\n        logProbe(`(探针) 队列现已为空。`);\n      }\n    },\n\n    // --- 当前项操作 (作用于队首) ---\n    setCurrentIndex(index: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n        currentItem.currentIndex = index;\n      }\n    },\n\n    commitNavigationStep(newTrackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n\n      if (_playbackMode === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(newTrackIndex);\n        if (newPlanIndex !== -1) {\n          currentItem.planIndex = newPlanIndex;\n        }\n      }\n      currentItem.currentIndex = newTrackIndex;\n    },\n\n    clearHistoryForCurrentItem() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) currentItem.playedIndices.clear();\n    },\n\n    resetCurrentItemForLoop() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playedIndices.clear();\n        currentItem.currentIndex = 0;\n      }\n    },\n\n    commitGenesisState(newCurrentIndex: number, newPlaybackPlan: number[], newPlanIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.currentIndex = newCurrentIndex;\n        currentItem.playbackPlan = newPlaybackPlan;\n        currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    userInitiatedJump(trackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem || trackIndex === currentItem.currentIndex) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n      currentItem.currentIndex = trackIndex;\n\n      if (this.getPlaybackMode() === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(trackIndex);\n        if (newPlanIndex !== -1) currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    clearRandomModePlan() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = undefined;\n        currentItem.planIndex = undefined;\n      }\n    },\n\n    applyNewPlaybackPlan(plan: number[], planIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = plan;\n        currentItem.planIndex = planIndex;\n      }\n    },\n  };\n\n  logProbe('[StateManager] 模块初始化完成 (V2.0 内核)。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.1. 播放引擎 (The Playback Engine)\n// =================================================================\nconst PlaybackEngine = (() => {\n  logProbe('[PlaybackEngine] 模块正在初始化...');\n  let _playerA: HTMLAudioElement | null = null;\n  let _playerB: HTMLAudioElement | null = null;\n  let _activePlayer: HTMLAudioElement | null = null;\n  let _standbyPlayer: HTMLAudioElement | null = null;\n  let _fadeInterval: number | null = null;\n  const FADE_DURATION = 400;\n\n  // --- 私有函数 ---\n  function _swapPlayers() {\n    [_activePlayer, _standbyPlayer] = [_standbyPlayer, _activePlayer];\n  }\n\n  function _fadeVolumeAsync(player: HTMLAudioElement | null, targetVolume: number, duration: number): Promise<void> {\n    return new Promise(resolve => {\n      if (_fadeInterval) {\n        clearInterval(_fadeInterval);\n        _fadeInterval = null;\n      }\n\n      if (!player) return resolve();\n\n      const startVolume = player.volume;\n      const stepTime = 50;\n      const steps = duration / stepTime;\n      if (steps <= 0) {\n        player.volume = targetVolume;\n        return resolve();\n      }\n      const volumeStep = (targetVolume - startVolume) / steps;\n      let currentStep = 0;\n\n      _fadeInterval = window.setInterval(() => {\n        currentStep++;\n        if (currentStep >= steps) {\n          if (_fadeInterval) clearInterval(_fadeInterval);\n          _fadeInterval = null;\n          player.volume = targetVolume;\n          resolve();\n        } else {\n          player.volume += volumeStep;\n        }\n      }, stepTime);\n    });\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    initialize() {\n      if (_playerA && _playerB) return;\n      logProbe('[Engine] 正在创建和配置 HTML5 Audio 元素...');\n      const createPlayer = (): HTMLAudioElement => {\n        const audio = new Audio();\n        audio.preload = 'auto';\n        audio.crossOrigin = 'anonymous';\n        audio.addEventListener('ended', () => {\n          if (audio === _activePlayer) void _handleTrackEnded();\n        });\n        audio.addEventListener('error', () => {\n          /* 错误由 Promise reject 处理 */\n        });\n        audio.addEventListener('timeupdate', broadcastTimeUpdate);\n        return audio;\n      };\n      _playerA = createPlayer();\n      _playerB = createPlayer();\n      _activePlayer = _playerA;\n      _standbyPlayer = _playerB;\n      logProbe('[Engine] Audio 元素已就绪。');\n    },\n\n    getActivePlayer: () => _activePlayer,\n    getStandbyPlayer: () => _standbyPlayer,\n\n    async transitionToTrack(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine] 收到过渡请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n\n      if (!_standbyPlayer || !_activePlayer) {\n        logProbe('[Engine] 过渡中止：播放器实例尚未初始化。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('播放器实例尚未初始化');\n      }\n\n      const standbyPlayer = _standbyPlayer;\n      const activePlayer = _activePlayer;\n\n      standbyPlayer.src = targetTrackUrl;\n      standbyPlayer.load();\n\n      try {\n        await new Promise<void>((resolve, reject) => {\n          const onCanPlay = () => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe('[Engine] 备用播放器加载成功 (canplaythrough)。', 'log');\n            resolve();\n          };\n\n          const onError = (e: Event) => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe(`[Engine] 备用播放器加载失败!`, 'error');\n            const target = e.target as HTMLAudioElement;\n            const error = target.error;\n            reject(new Error(`音频加载失败: ${error?.message || '未知错误'}`));\n          };\n          standbyPlayer.addEventListener('canplaythrough', onCanPlay);\n          standbyPlayer.addEventListener('error', onError);\n        });\n      } catch (error) {\n        logProbe('[Engine] 过渡因加载失败而中止。', 'groupEnd');\n        throw error;\n      }\n\n      await _fadeVolumeAsync(activePlayer, 0, 500);\n      activePlayer.pause();\n\n      _swapPlayers();\n\n      const newActivePlayer = this.getActivePlayer();\n      if (!newActivePlayer) throw new Error('播放器实例在交换后丢失');\n\n      const playPromise = newActivePlayer.play();\n      if (playPromise) {\n        await playPromise;\n      }\n      await _fadeVolumeAsync(newActivePlayer, targetVolume, 500);\n\n      logProbe('[Engine] 过渡成功完成。', 'groupEnd');\n    },\n\n    async fadeOutAndPause(): Promise<void> {\n      logProbe('[Engine] 命令: FadeOutAndPause');\n      await _fadeVolumeAsync(_activePlayer, 0, FADE_DURATION);\n      _activePlayer?.pause();\n    },\n\n    async executeHardCut(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine:HardCut] 收到“瞬击”请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n      const activePlayer = this.getActivePlayer();\n      if (!activePlayer) {\n        logProbe('[Engine:HardCut] 致命错误：无可用播放器实例。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('No active player available for hard cut.');\n      }\n\n      logProbe(`(探针) 切换前 src: ${activePlayer.src.slice(-50)}`);\n\n      activePlayer.pause();\n      activePlayer.src = targetTrackUrl;\n      activePlayer.volume = targetVolume;\n\n      logProbe(`(探针) 切换后 src: ${activePlayer.src.slice(-50)}`);\n\n      try {\n        const playPromise = activePlayer.play();\n        if (playPromise) {\n          await playPromise;\n        }\n\n        StateManager.setPlaybackState('PLAYING');\n        logProbe('[Engine:HardCut] “瞬击”播放成功。');\n      } catch (error) {\n        logProbe(`[Engine:HardCut] “瞬击”播放失败! 这通常是因为用户未与页面交互。`, 'error');\n\n        StateManager.setPlaybackState('STOPPED');\n\n        throw error;\n      } finally {\n        logProbe('', 'groupEnd');\n      }\n    },\n\n    async resumeAndFadeIn(targetVolume: number): Promise<void> {\n      logProbe('[Engine] 命令: ResumeAndFadeIn');\n      const playPromise = _activePlayer?.play();\n      if (playPromise) await playPromise;\n      await _fadeVolumeAsync(_activePlayer, targetVolume, FADE_DURATION);\n    },\n  };\n\n  logProbe('[PlaybackEngine] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.2. 播放策略实现 (Playback Strategies)\n// =================================================================\n\nclass ListStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 advance 请求. 方向: ${direction}, 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    if (direction === 'next') {\n      logProbe('[Strategy:List] 决策: advance(next) -> 委托给 onTrackEnd');\n      return this.onTrackEnd(currentItem);\n    }\n\n    const { currentIndex, onFinishRule, playlistContent } = currentItem;\n    const totalTracks = playlistContent.length;\n\n    if (currentIndex > 0) {\n      const nextIndex = currentIndex - 1;\n      logProbe(`[Strategy:List] 决策: advance(prev) -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'loop') {\n      const lastIndex = totalTracks > 0 ? totalTracks - 1 : 0;\n      logProbe(`[Strategy:List] 决策: advance(prev) at start -> Loop to end (index: ${lastIndex})`);\n      return { action: 'GoTo', nextIndex: lastIndex };\n    } else {\n      logProbe('[Strategy:List] 决策: advance(prev) at start -> Restart');\n      return { action: 'Restart' };\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 onTrackEnd 请求. 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    const { currentIndex, onFinishRule, playlistContent, playedIndices } = currentItem;\n    const totalTracks = playlistContent.length;\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex < totalTracks) {\n      logProbe(`[Strategy:List] 决策: onTrackEnd -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'pop') {\n      logProbe('[Strategy:List] 决策: onTrackEnd at end -> PopStack');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      const totalValidTracks = playlistContent.length;\n      const historySizeAfterThisTrack = playedIndices.size + 1;\n\n      if (historySizeAfterThisTrack >= totalValidTracks) {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> LoopReset (一个完整的循环已结束)`, 'warn');\n        return { action: 'LoopReset' };\n      } else {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> GoTo (普通循环，继续播放未听过的歌曲)`);\n        return { action: 'GoTo', nextIndex: 0 };\n      }\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:List] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\nclass SingleStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(_currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 advance 请求. 方向: ${direction}. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onTrackEnd(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onTrackEnd 请求. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onPlaybackError(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onPlaybackError 请求。决策: Stop (单曲循环下无法自动前进)`);\n    return { action: 'Stop' };\n  }\n}\n\nclass RandomStrategy implements IPlaybackStrategy {\n  private _generateIntelligentShuffle(\n    allTrackIndices: number[],\n    playedIndices: Set<number>,\n    currentIndex: number,\n  ): number[] {\n    logProbe(`[Strategy:Random] (Algo) _generateIntelligentShuffle 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: allIndices.length=${allTrackIndices.length}, playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}`,\n    );\n\n    const sourceForShuffle = allTrackIndices.filter(i => !playedIndices.has(i) && i !== currentIndex);\n    logProbe(`计算待选池 (sourceForShuffle) 大小: ${sourceForShuffle.length}`);\n\n    for (let i = sourceForShuffle.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [sourceForShuffle[i], sourceForShuffle[j]] = [sourceForShuffle[j], sourceForShuffle[i]];\n    }\n\n    logProbe(`洗牌完成. 输出 shuffledIndices (纯粹的未来队列): [${sourceForShuffle.join(', ')}]`);\n    logProbe('', 'groupEnd');\n    return sourceForShuffle;\n  }\n\n  private _generatePlaybackPlan(\n    playedIndices: Set<number>,\n    currentIndex: number,\n    shuffledIndices: number[],\n  ): { playbackPlan: number[]; planIndex: number } {\n    logProbe(`[Strategy:Random] (Algo) _generatePlaybackPlan 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}, shuffledIndices.length=${shuffledIndices.length}`,\n    );\n\n    const knownSequence = Array.from(new Set([...playedIndices, currentIndex]));\n    const planIndex = knownSequence.indexOf(currentIndex);\n    const playbackPlan = [...knownSequence, ...shuffledIndices];\n\n    logProbe(`(守护者探针) \"已知序列\" (unique history + current): [${knownSequence.join(', ')}]`);\n    logProbe(`生成导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n    logProbe(`定位导航指针 (planIndex): ${planIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { playbackPlan, planIndex };\n  }\n\n  private _handlePlanEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] (Helper) _handlePlanEnd: 已到达计划终点，开始进行边界决策...`, 'groupCollapsed');\n    logProbe(`(探针) 待决策歌单: \"${currentItem.playlistId}\", 结束规则: \"${currentItem.onFinishRule}\"`);\n\n    if (currentItem.onFinishRule === 'pop') {\n      logProbe(`(边界决策) onFinishRule 为 'pop'，决策 -> PopStack`);\n      logProbe('', 'groupEnd');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      logProbe(`(边界决策) onFinishRule 为 'loop'，决策 -> LoopReset`);\n      logProbe('', 'groupEnd');\n      return { action: 'LoopReset' };\n    }\n  }\n\n  public onQueueChanged(currentItem: QueueItem | undefined): void {\n    if (!currentItem) {\n      logProbe('[Strategy:Random] onQueueChanged 中止：无有效的当前项。');\n      return;\n    }\n\n    logProbe(\n      `[Strategy:Random] onQueueChanged 已触发 (连续性恢复)，将为歌单 \"${currentItem.playlistId}\" 生成播放计划...`,\n    );\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    const shuffled = this._generateIntelligentShuffle(allIndices, currentItem.playedIndices, currentItem.currentIndex);\n    const { playbackPlan, planIndex } = this._generatePlaybackPlan(\n      currentItem.playedIndices,\n      currentItem.currentIndex,\n      shuffled,\n    );\n\n    StateManager.applyNewPlaybackPlan(playbackPlan, planIndex);\n  }\n\n  public prepareGenesis(currentItem: QueueItem | undefined): {\n    newCurrentIndex: number;\n    newPlaybackPlan: number[];\n    newPlanIndex: number;\n  } | null {\n    if (!currentItem || !currentItem.playlistContent) {\n      logProbe('[Strategy:Random] prepareGenesis 中止：传入的队列项无效。', 'error');\n      return null;\n    }\n\n    logProbe('[Strategy:Random] (Query) prepareGenesis: 收到“创世乐谱”谱写请求...', 'group');\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    for (let i = allIndices.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];\n    }\n\n    const newPlaybackPlan = allIndices;\n    const newPlanIndex = 0;\n    const newCurrentIndex = newPlaybackPlan[newPlanIndex];\n\n    logProbe(`(乐谱) 谱写完成。New CurrentIndex: ${newCurrentIndex}, New PlanIndex: ${newPlanIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { newCurrentIndex, newPlaybackPlan, newPlanIndex };\n  }\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 advance 请求. 方向: ${direction}`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'DoNothing' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    if (direction === 'next') {\n      const nextPlanIndex = planIndex + 1;\n\n      if (nextPlanIndex < playbackPlan.length) {\n        const targetTrackIndex = playbackPlan[nextPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(next) -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe('[Strategy:Random] advance(next) 已到达计划终点，委托给 _handlePlanEnd...');\n        logProbe('', 'groupEnd');\n        return this._handlePlanEnd(currentItem);\n      }\n    } else {\n      // direction === 'prev'\n      const prevPlanIndex = planIndex - 1;\n\n      if (prevPlanIndex >= 0) {\n        const targetTrackIndex = playbackPlan[prevPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(prev) -> GoTo (新 planIndex: ${prevPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe(`[Strategy:Random] 决策: advance(prev) 已在计划起点。返回 DoNothing。`);\n        logProbe('', 'groupEnd');\n        return { action: 'DoNothing' };\n      }\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onTrackEnd 请求.`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。返回 Stop 以策安全。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'Stop' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    const nextPlanIndex = planIndex + 1;\n\n    if (nextPlanIndex < playbackPlan.length) {\n      const targetTrackIndex = playbackPlan[nextPlanIndex];\n      logProbe(\n        `[Strategy:Random] 决策: onTrackEnd -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n      );\n      logProbe('', 'groupEnd');\n      return { action: 'GoTo', nextIndex: targetTrackIndex };\n    } else {\n      logProbe('[Strategy:Random] onTrackEnd 已到达计划终点，委托给 _handlePlanEnd...');\n      logProbe('', 'groupEnd');\n      return this._handlePlanEnd(currentItem);\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\n// =================================================================\n// 2.3. 策略管理器 (The StrategyManager - \"The Conductor\")\n// =================================================================\nconst StrategyManager = (() => {\n  logProbe('[StrategyManager] 模块正在初始化...');\n\n  const _strategies: Record<PlaybackMode, IPlaybackStrategy> = {\n    list: new ListStrategy(),\n    single: new SingleStrategy(),\n    random: new RandomStrategy(),\n  };\n  let _currentStrategy: IPlaybackStrategy = _strategies.list;\n\n  const publicAPI = {\n    /**\n     * [命令] 设置新的播放模式，并自动切换到对应的策略实例。\n     */\n    setMode(mode: PlaybackMode) {\n      logProbe(`[StrategyManager] (Command) setMode: 切换策略模式为 -> ${mode}`);\n      _currentStrategy = _strategies[mode];\n    },\n\n    /**\n     * [查询] 获取当前激活的策略实例。这是我们遵循CQS原则的体现。\n     */\n    getCurrentStrategy: () => _currentStrategy,\n\n    /**\n     * [命令] 通知当前策略：核心状态（如队列）已发生重大变化。\n     * 这是修复BUG的核心，它为策略提供了一个统一的生命周期钩子。\n     */\n\n    notifyQueueChanged() {\n      logProbe(\n        `[StrategyManager] (Command) notifyQueueChanged: 正在通知当前策略 (${_currentStrategy.constructor.name}) 队列已变更...`,\n        'groupCollapsed',\n      );\n      const currentItem = StateManager.getTopQueueItem();\n      _currentStrategy.onQueueChanged(currentItem);\n      logProbe('[StrategyManager] 通知完成。', 'groupEnd');\n    },\n  };\n\n  logProbe('[StrategyManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 3. 全局变量与常量 (Global Variables & Constants)\n// =================================================================\n\nconst STATE_KEY = '余烬双星_播放器状态';\n\nlet isInitializedForThisChat = false;\nlet isReconciling = false;\nlet _initializationPromiseControls: { resolve: () => void; reject: (reason?: any) => void } | null = null;\n\nlet _initializationPromise: Promise<void> | null = null;\nlet isScriptActive = true;\nlet allPlaylists: Record<string, PlaylistConfig> = {};\nlet triggers: z.infer<typeof ZodTriggerConfig>[] = [];\nlet defaultPlaylistId: string | undefined = '';\n\nlet isMvuIntegrationActive = false;\nlet isCorePlayerInitialized = false;\nlet isMvuMode = true;\nlet _currentChatId: string | number | null = null;\n\nconst fullStateUpdateCallbacks: ((payload: FullStatePayload) => void)[] = [];\nconst timeUpdateCallbacks: ((payload: TimeUpdatePayload) => void)[] = [];\n\n/**\n * [V9.5 统一校准官] 新架构的“运行时大脑”。\n * 它的单一职责是：响应“运行时”的增量事件，通过“边沿检测”模型，\n * 精确地、最小化地修改当前队列，并决策是否需要变更播放。\n * @param eventPayload - 可选的、来自 MVU 事件的最新状态数据。\n */\nasync function _reconcilePlaylistQueue(eventPayload?: any, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  if (!isScriptActive) {\n    return;\n  }\n  // --- 1. 【前置检查】: 防止并发的事件风暴 ---\n  if (isReconciling) {\n    logProbe('[Reconciler] 请求被合并：前一个校准任务仍在进行中。', 'warn');\n    return;\n  }\n  isReconciling = true;\n  logProbe(`=== [Reconciler] “统一校准官”已接管运行时事件 (模式: ${isMvuMode ? 'MVU' : 'Text'}) ===`, 'group');\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe('[Reconciler] (事务) 已上效果锁并广播“过渡中”状态，UI应进入等待。');\n    broadcastFullState();\n\n    // --- 核心逻辑 ---\n    try {\n      const oldTopItem = StateManager.getTopQueueItem();\n\n      // --- 2. 【获取事实 (The Branch)】: 双轨制分流 ---\n      let currentStateData: Record<string, any> = {};\n\n      if (isMvuMode) {\n        // [路径 A: MVU 模式]\n        if (eventPayload?.stat_data) {\n          // Case 1: 事件推送 (VARIABLE_UPDATE_ENDED)\n          currentStateData = eventPayload.stat_data;\n          logProbe('[Reconciler] (事实) 采用事件载荷提供的 MVU 状态。');\n        } else {\n          // Case 2: 主动查询 (MESSAGE_SWIPED / MESSAGE_DELETED)\n          // 注意：由于我们在事件监听层已经通过 duringGenerating() 过滤了生成中的情况，\n          // 这里获取到的权威状态应该是稳定且可靠的。\n          const authState = await _findLatestAuthoritativeMvuState();\n\n          if (authState) {\n            currentStateData = authState.mvuData?.stat_data ?? {};\n            logProbe('[Reconciler] (事实) 主动查询并采用了最新的 MVU 状态。');\n          } else {\n            // 如果真的找不到任何数据（极罕见），默认为空状态，这意味着触发器可能全部失效\n            logProbe('[Reconciler] (事实) 未找到有效的 MVU 状态，将使用空状态进行校准。', 'warn');\n            currentStateData = {};\n          }\n        }\n      } else {\n        // [路径 B: Text 模式]\n        logProbe('[Reconciler] (事实) 进入 Text 模式状态获取流程...');\n        currentStateData = await TextTagManager.getLatestState();\n        logProbe('[Reconciler] (事实) TextTagManager 已返回标准化状态。');\n      }\n\n      // --- 3. 【生成报告】: 委托 MvuManager 进行边沿检测 ---\n      const previousStateData = MvuManager.getPreviousState();\n      const changeReport = MvuManager.calculateChangeReport(previousStateData, currentStateData, triggers);\n\n      // --- 4. 【执行队列的增量修改】: 先减后加 ---\n      const newQueue = StateManager.getQueue();\n\n      if (changeReport.newlyInactiveTriggers.length > 0) {\n        _.remove(newQueue, item =>\n          changeReport.newlyInactiveTriggers.some(inactiveTrigger =>\n            areTriggersFunctionallyEqual(item.triggerSource, inactiveTrigger),\n          ),\n        );\n        logProbe(`[Reconciler] (修改) 根据报告移除了 ${changeReport.newlyInactiveTriggers.length} 个失效项。`);\n      }\n\n      if (changeReport.newlyActiveTriggers.length > 0) {\n        for (const activeTrigger of changeReport.newlyActiveTriggers) {\n          if (\n            newQueue.some(item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, activeTrigger))\n          ) {\n            logProbe(`[Reconciler] (防御) 拒绝添加重复的激活项: \"${activeTrigger.playlist_id}\"`, 'warn');\n            continue;\n          }\n          const newItem = createQueueItem({\n            type: 'mvu',\n            playlistId: activeTrigger.playlist_id,\n            trigger: activeTrigger,\n          });\n          if (newItem) {\n            newQueue.push(newItem);\n            logProbe(`[Reconciler] (修改) 根据报告添加了新激活项: \"${newItem.playlistId}\"`);\n          }\n        }\n      }\n\n      StateManager.updateQueue(newQueue);\n\n      // --- 5. 【决策与执行】: 对比新旧队首 ---\n      const newTopItem = StateManager.getTopQueueItem();\n\n      if (newTopItem?.playlistId !== oldTopItem?.playlistId) {\n        logProbe(\n          `[Reconciler] (决策) 队首发生变更！ 从 \"${oldTopItem?.playlistId ?? '无'}\" 变为 \"${newTopItem?.playlistId ?? '无'}\"。`,\n        );\n\n        if (newTopItem) {\n          logProbe('[Reconciler] (握手) 正在通知 StrategyManager 队列已变更...');\n          StrategyManager.notifyQueueChanged();\n\n          newTopItem.wasEverPlayed = true;\n          const targetIndex = newTopItem.wasEverPlayed ? newTopItem.currentIndex : 0;\n\n          if (StateManager.isPlaying()) {\n            logProbe('[Reconciler] (效果) 用户正在播放，将执行过渡效果...');\n            if (options?.transitionEffect === 'hard') {\n              await PlaybackEngine.executeHardCut(\n                newTopItem.playlistContent[targetIndex].url,\n                StateManager.getVolume(),\n              );\n            } else {\n              await _executeTransition(targetIndex);\n            }\n          } else if (\n            oldTopItem === undefined && // 1. 队列发生“从无到有”的跃迁\n            StateManager.getPlaybackState() === 'STOPPED' // 2. 关键：只要不是 PAUSED (用户主动暂停)，就允许场景触发播放\n          ) {\n            logProbe(\n              '[Reconciler] 自动播放契约满足 (Queue 0->1 + Not Paused)，将调用 _executeGenesisPlayInternal。',\n              'warn',\n            );\n            await _executeGenesisPlayInternal(targetIndex);\n          } else {\n            logProbe('[Reconciler] (效果) 用户已暂停或未授权，仅在后台静默更新轨道，不播放。');\n            const track = newTopItem.playlistContent[targetIndex];\n            const activePlayer = PlaybackEngine.getActivePlayer();\n            if (track && activePlayer) {\n              activePlayer.src = track.url;\n            }\n          }\n        } else {\n          logProbe('[Reconciler] (决策) 监测到队列已完全清空。正在执行“物理静音”协议...', 'warn');\n\n          await PlaybackEngine.fadeOutAndPause();\n\n          StateManager.setPlaybackState('STOPPED');\n\n          StrategyManager.notifyQueueChanged();\n\n          logProbe('[Reconciler] (执行) “物理静音”完成，播放状态已置为 STOPPED。');\n        }\n      } else {\n        logProbe('[Reconciler] (决策) 队首未发生变更，保持当前播放稳定。');\n      }\n\n      // --- 6. 【更新记忆】: 为下一次边沿检测做准备 ---\n      await MvuManager.persistCurrentState(currentStateData);\n    } catch (error) {\n      logProbe(`[Reconciler] 核心逻辑执行期间发生严重错误: ${error}`, 'error');\n      console.error(error);\n    } finally {\n      await writeState('reconciliation');\n    }\n  } finally {\n    isReconciling = false;\n    await _releaseEffectLock();\n    logProbe('=== [Reconciler] “统一校准官”任务完成 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 4. 核心工具与广播系统 (Core Utilities & Broadcast System)\n// =================================================================\n\nfunction broadcastFullState() {\n  const currentItem = StateManager.getTopQueueItem();\n  const currentPlaylist = currentItem?.playlistContent ?? [];\n  const currentIndex = currentItem?.currentIndex ?? 0;\n\n  const payload: FullStatePayload = {\n    currentItem: currentPlaylist[currentIndex]\n      ? {\n          title: currentPlaylist[currentIndex].歌名,\n          artist: currentPlaylist[currentIndex].歌手,\n          cover: currentPlaylist[currentIndex].封面,\n        }\n      : null,\n    isPlaying: StateManager.isPlaying(),\n    playbackState: StateManager.getPlaybackState(),\n    playbackMode: StateManager.getPlaybackMode(),\n    masterVolume: StateManager.getVolume(),\n    playlist: currentPlaylist.map(item => ({ title: item.歌名, artist: item.歌手, cover: item.封面 })),\n    isTransitioning: StateManager.isPerformingEffect(),\n  };\n  logProbe(\n    `[Broadcast] 正在广播完整状态... [旧兼容: isPlaying=${payload.isPlaying}] [新内核: state=${payload.playbackState}] mode: ${payload.playbackMode}, currentItem: ${payload.currentItem?.title ?? '无'}`,\n    'groupCollapsed',\n  );\n  logProbe(`详细: isTransitioning=${payload.isTransitioning}`);\n  logProbe('', 'groupEnd');\n\n  fullStateUpdateCallbacks.forEach(callback => {\n    try {\n      callback(payload);\n    } catch (e) {\n      console.error('[音乐脚本] 完整状态回调执行出错:', e);\n    }\n  });\n}\n\nfunction broadcastTimeUpdate() {\n  const activePlayer = PlaybackEngine.getActivePlayer();\n  if (!StateManager.isPlaying() || !activePlayer) return;\n  const payload: TimeUpdatePayload = {\n    currentTime: activePlayer.currentTime,\n    duration: activePlayer.duration || 0,\n  };\n  timeUpdateCallbacks.forEach(callback => callback(payload));\n}\n\nfunction prepareNextTrack() {\n  const currentItem = StateManager.getTopQueueItem();\n  const standbyPlayer = PlaybackEngine.getStandbyPlayer();\n  if (!standbyPlayer || !currentItem) return;\n  const nextIndex = currentItem.currentIndex + 1;\n  if (nextIndex < currentItem.playlistContent.length) {\n    const nextTrack = currentItem.playlistContent[nextIndex];\n    if (nextTrack && standbyPlayer.src !== nextTrack.url) {\n      standbyPlayer.src = nextTrack.url;\n      standbyPlayer.load();\n    }\n  }\n}\n\n// =================================================================\n// 5. 状态管理 (State Management)\n// =================================================================\n\nfunction readState() {\n  logProbe('[StateReader] 正在尝试从酒馆变量读取持久化状态...');\n  const savedData = getVariables({ type: 'chat' })[STATE_KEY];\n\n  if (!savedData || typeof savedData !== 'object') {\n    logProbe('[StateReader] 未发现有效存档。');\n    return null;\n  }\n\n  logProbe('[StateReader] 发现原始状态数据，正在提交给 Zod 进行安全验证...');\n  const validationResult = ZodPersistedState.safeParse(savedData);\n\n  if (validationResult.success) {\n    logProbe('[StateReader] Zod 验证成功，状态数据安全。');\n    return validationResult.data;\n  } else {\n    console.warn('[StateReader] 持久化状态验证失败:', validationResult.error);\n    return null;\n  }\n}\n\nasync function writeState(source: string) {\n  if (!isScriptActive) {\n    logProbe(`[State] 写入操作被阻止，因为脚本正在停机。(来源: ${source})`, 'warn');\n    return;\n  }\n  try {\n    logProbe(`[State] 由 \"${source}\" 触发状态写入...`);\n    const dataToSave = StateManager.getStateSnapshotForPersistence();\n\n    await updateVariablesWith(\n      vars => {\n        vars[STATE_KEY] = dataToSave;\n        return vars;\n      },\n      { type: 'chat' },\n    );\n\n    logProbe(`[State] 状态已成功写入酒馆变量`);\n  } catch (e: any) {\n    logProbe(`[State] 写入状态时发生严重错误: ${e}`, 'error');\n  }\n}\n\n// =================================================================\n// 6. 世界书配置解析与队列操作 (Worldbook Parsing & Stack Operations)\n// =================================================================\n\n/**\n * @description 格式化 Zod 验证错误，以便在 toastr 中为角色卡作者显示清晰、可操作的反馈。\n */\nfunction _formatZodErrorForToastr(error: ZodError): void {\n  const issue = error.issues[0];\n  const path = issue.path.join(' -> ');\n  const message = issue.message;\n\n  const toastrTitle = `[MusicConfig] 内容错误`;\n  const toastrMessage = `路径: ${path} | 问题: ${message}`;\n\n  const fullLogMessage = `[MusicConfig] 内容错误:\\n路径: ${path}\\n问题: ${message}`;\n  logProbe(`[ZodValidator] 世界书配置验证失败: ${fullLogMessage}`, 'error');\n\n  toastr.error(toastrMessage, toastrTitle, { timeOut: 15000 });\n}\n\n// =================================================================\n// 核心算法 V9.5 (Core Algorithms for \"Concerto\")\n// 原则: 这些函数都必须是纯粹的查询 (CQS)，严禁产生任何副作用。\n// =================================================================\n\n/**\n * [核心算法] 判断两个触发器对象是否代表同一个“功能身份”。\n * @param a - 第一个触发器对象。\n * @param b - 第二个触发器对象。\n * @returns {boolean} 如果功能上相等，则返回 true。\n */\nfunction areTriggersFunctionallyEqual(\n  a: z.infer<typeof ZodTriggerConfig> | undefined,\n  b: z.infer<typeof ZodTriggerConfig> | undefined,\n): boolean {\n  if (!a || !b) return a === b;\n\n  if (a.playlist_id !== b.playlist_id) return false;\n\n  type ConditionKey = keyof z.infer<typeof ZodSingleCondition>;\n\n  const getCanonicalString = (condition: z.infer<typeof ZodSingleCondition>): string => {\n    return (Object.keys(condition) as ConditionKey[])\n      .sort()\n      .map(key => `${key}:${String(condition[key])}`) // 使用 String() 来确保所有值都能被正确处理\n      .join(',');\n  };\n\n  const conditionsA = a.conditions.map(getCanonicalString).sort();\n  const conditionsB = b.conditions.map(getCanonicalString).sort();\n\n  return conditionsA.length === conditionsB.length && conditionsA.every((val, index) => val === conditionsB[index]);\n}\n\n/**\n * @description [V9.7 核心强化] 查找权威MVU状态。现在能够识别“创世”和“运行时”两种数据结构。\n * @param context - 可选的上下文，用于指导查找方式。\n * @returns {Promise<{ mvuData: any, messageId: number } | null>} 权威状态或 null。\n */\nasync function _findLatestAuthoritativeMvuState(context?: {\n  messageId: number;\n  swipeId: number;\n}): Promise<{ mvuData: any; messageId: number } | null> {\n  // --- 模式一: 精确制导 (通常用于开场白) ---\n  if (context && context.messageId === 0 && typeof context.swipeId === 'number') {\n    logProbe(\n      `[StateFinder] (精确制导模式) 目标: message_id=${context.messageId}, swipe_id=${context.swipeId}`,\n      'groupCollapsed',\n    );\n    try {\n      const mvuDataContainer: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n\n      const swipeSpecificData = mvuDataContainer?.swipes_data?.[context.swipeId];\n\n      if (swipeSpecificData?.stat_data) {\n        // 成功在 \"创世\" 结构中找到特定 swipe 的数据\n        logProbe('[StateFinder] (探针) 检测到“创世”结构 (swipes_data)，成功命中！');\n        logProbe('', 'groupEnd');\n        return { mvuData: swipeSpecificData, messageId: 0 };\n      } else if (mvuDataContainer?.stat_data) {\n        // 在顶层找到了 \"运行时\" 结构的数据 (可能只有一个开场白)\n        logProbe('[StateFinder] (探针) 检测到“运行时”结构 (顶层 stat_data)，直接采用。');\n        logProbe('', 'groupEnd');\n        return { mvuData: mvuDataContainer, messageId: 0 };\n      } else {\n        logProbe('[StateFinder] (精确制导模式) 查找失败：在两种已知结构中均未找到 stat_data。', 'warn');\n      }\n    } catch (error) {\n      logProbe(`[StateFinder] (精确制导模式) 查询时出错: ${error}`, 'error');\n    } finally {\n      logProbe('', 'groupEnd');\n    }\n  }\n\n  // --- 模式二: 回溯扫描 (找不到精确目标时的标准流程) ---\n  logProbe('[StateFinder] (回溯扫描模式) 开始执行...', 'groupCollapsed');\n  try {\n    const allMessages = getChatMessages(-1, { include_swipes: true });\n    for (let i = allMessages.length - 1; i >= 0; i--) {\n      const message = allMessages[i];\n      // [V9.7 核心修正] 修复致命拼写错误：message.id -> message.message_id\n      const currentMessageId = message.message_id;\n\n      // 防御性编程：如果 message_id 无效，直接跳过，防止意外\n      if (typeof currentMessageId !== 'number') {\n        logProbe(`(探针) 跳过无效楼层 (索引 ${i})，因其 message_id 为 ${currentMessageId}。`, 'warn');\n        continue;\n      }\n\n      try {\n        logProbe(`(探针) 正在查询 message_id: ${currentMessageId}...`);\n        const mvuData = await Mvu.getMvuData({ type: 'message', message_id: currentMessageId });\n\n        if (mvuData?.stat_data) {\n          logProbe(`[StateFinder] 查找成功！在 message_id: ${currentMessageId} 处找到权威状态。`);\n          logProbe('', 'groupEnd');\n          return { mvuData, messageId: currentMessageId };\n        }\n      } catch (error) {\n        logProbe(`(探针) 查询 message_id: ${currentMessageId} 时接口失败，将继续向前查找。错误: ${error}`, 'warn');\n      }\n    }\n    logProbe('[StateFinder] 查找失败：遍历完所有消息楼层，均未找到有效的 stat_data。', 'warn');\n    return null;\n  } catch (error) {\n    logProbe(`[StateFinder] 在获取聊天记录时发生严重错误: ${error}`, 'error');\n    return null;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description [职责单一] 找到、解析、验证并准备好【可供运行时直接使用】的音乐配置。\n * @returns {Promise<{ playlists: Record<string, PlaylistConfig>, defaultId: string, triggers: Trigger[] } | null>}\n *          一个包含了【 playlists 映射 】的、完全准备就绪的配置对象，或在失败时返回 null。\n */\n\nasync function parseWorldbookConfig() {\n  logProbe('[WorldbookParser V4-健壮模式] 开始解析...', 'group');\n\n  // [修改点] 自定义错误类，用于清晰地区分“配置缺失”和“未知错误”\n  // 这让我们的错误处理逻辑更符合 SRP 原则\n  class ConfigMissingError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'ConfigMissingError';\n    }\n  }\n\n  type AggregatedPlaylist = z.infer<typeof ZodPlaylistConfig> & { _sourceFile: string };\n  type AggregatedTrigger = z.infer<typeof ZodTriggerConfig> & { _sourceFile: string };\n\n  const aggregatedConfig: {\n    playlists: AggregatedPlaylist[];\n    triggers: AggregatedTrigger[];\n    defaultPlaylistId?: string;\n    _defaultPlaylistIdSourceFile: string | null;\n    explicitMvuMode?: boolean;\n  } = {\n    playlists: [],\n    triggers: [],\n    defaultPlaylistId: undefined,\n    _defaultPlaylistIdSourceFile: null,\n    explicitMvuMode: undefined,\n  };\n\n  try {\n    // 前置检查：在执行任何复杂逻辑前，首先确认世界书数据是否可访问。\n    const worldbookNames = getCharWorldbookNames('current');\n    const searchOrder = [worldbookNames.primary, ...worldbookNames.additional].filter(Boolean);\n\n    // 如果角色卡没有关联任何世界书，直接抛出我们自定义的错误\n    if (searchOrder.length === 0) {\n      throw new ConfigMissingError('角色卡未关联任何世界书。');\n    }\n\n    let foundAnyConfigEntry = false;\n\n    for (const bookName of searchOrder) {\n      if (!bookName) continue;\n      const entries = await getWorldbook(bookName);\n      const configEntries = entries.filter(e => e.name.includes('[MusicConfig]'));\n\n      if (configEntries.length > 0) {\n        foundAnyConfigEntry = true;\n      }\n\n      for (const entry of configEntries) {\n        logProbe(`[Parser V4] 发现并处理配置文件: \"${entry.name}\"`);\n        try {\n          const rawConfig = YAML.parse(entry.content);\n          const validationResult = ZodWorldbookConfig.safeParse(rawConfig);\n\n          if (!validationResult.success) {\n            logProbe(`[Parser V4] 条目 \"${entry.name}\" Zod验证失败，已跳过。`, 'error');\n            _formatZodErrorForToastr(validationResult.error);\n            continue;\n          }\n\n          const data = validationResult.data;\n\n          if (data.playlists) {\n            aggregatedConfig.playlists.push(...data.playlists.map(p => ({ ...p, _sourceFile: entry.name })));\n          }\n          if (data.triggers) {\n            aggregatedConfig.triggers.push(...data.triggers.map(t => ({ ...t, _sourceFile: entry.name })));\n          }\n          if (data.default_playlist_id) {\n            if (aggregatedConfig.defaultPlaylistId && aggregatedConfig.defaultPlaylistId !== data.default_playlist_id) {\n              const warningMsg = `在文件 \"${entry.name}\" 中发现的 default_playlist_id (\"${data.default_playlist_id}\") 覆盖了来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\" 的定义 (\"${aggregatedConfig.defaultPlaylistId}\")。为确保行为可预测，建议只保留一个定义。`;\n              logProbe(`[Parser V4] ${warningMsg}`, 'warn');\n              toastr.warning(warningMsg, '配置警告', { timeOut: 20000, closeButton: true });\n            }\n            aggregatedConfig.defaultPlaylistId = data.default_playlist_id;\n            aggregatedConfig._defaultPlaylistIdSourceFile = entry.name;\n          }\n          if (data.is_mvu !== undefined) {\n            aggregatedConfig.explicitMvuMode = data.is_mvu;\n            logProbe(`[Parser V9.5] (配置) 在文件 \"${entry.name}\" 中读取到显式模式设置: is_mvu = ${data.is_mvu}`);\n          }\n        } catch (e: any) {\n          logProbe(`[Parser V4] 解析条目 \"${entry.name}\" 时发生YAML语法错误: ${e.message}`, 'error');\n          toastr.error(`[MusicConfig] 文件 \"${entry.name}\" 格式错误：YAML 语法不正确。`, '配置错误', {\n            timeOut: 10000,\n          });\n        }\n      }\n    }\n\n    // 在所有文件都检查完之后，再判断是否找到了任何 [MusicConfig] 条目\n    if (!foundAnyConfigEntry) {\n      throw new ConfigMissingError('在已关联的世界书中，未找到任何包含 [MusicConfig] 的条目。');\n    }\n\n    // 模式推断与虚拟触发器生成\n    let finalIsMvu = false;\n\n    // 1. 优先级判断: 显式配置 > 自动推断\n    if (aggregatedConfig.explicitMvuMode !== undefined) {\n      finalIsMvu = aggregatedConfig.explicitMvuMode;\n      logProbe(`[Parser V9.5] (决策) 遵循显式配置，运行模式锁定为: ${finalIsMvu ? 'MVU模式' : '纯文字模式'}`);\n    } else {\n      // 2. 自动推断: 有触发器就是 MVU，否则是纯文字\n      finalIsMvu = aggregatedConfig.triggers.length > 0;\n      logProbe(\n        `[Parser V9.5] (决策) 基于内容自动推断，运行模式锁定为: ${finalIsMvu ? 'MVU模式 (发现触发器)' : '纯文字模式 (无触发器)'}`,\n      );\n    }\n\n    // 3. 纯文字模式下的虚拟化处理\n    if (!finalIsMvu) {\n      const uniquePlaylistIds = new Set(aggregatedConfig.playlists.map(p => p.id));\n      logProbe(`[Parser V9.5] (虚拟化) 正在为 ${uniquePlaylistIds.size} 个歌单生成隐式触发器...`);\n\n      for (const pid of uniquePlaylistIds) {\n        const virtualTrigger: AggregatedTrigger = {\n          type: 'mvu_variable',\n          playlist_id: pid,\n          priority: 0,\n          conditions: [\n            {\n              variable_path: 'virtual.music_tag',\n              value: pid.toLowerCase(),\n            },\n          ],\n          _sourceFile: 'System_Auto_Generated',\n        };\n        aggregatedConfig.triggers.push(virtualTrigger);\n      }\n      logProbe(\n        `[Parser V9.5] (虚拟化) 生成完成。系统现在可以识别 <scene:${Array.from(uniquePlaylistIds)[0]}...> 等标签。`,\n      );\n    }\n\n    // --- 全局健全性检查 (逻辑保持不变) ---\n    logProbe('[Parser V4] 所有文件聚合完毕，开始执行全局健全性检查...', 'groupCollapsed');\n    let isGloballyValid = true;\n    const playlistsById = _.groupBy(aggregatedConfig.playlists, 'id');\n    for (const id in playlistsById) {\n      if (playlistsById[id].length > 1) {\n        const sources = playlistsById[id].map(p => p._sourceFile).join(', ');\n        const errorMsg = `[MusicConfig] 致命错误: 歌单 ID \"${id}\" 在多个文件中重复定义。来源: ${sources}。ID 必须是唯一的。`;\n        logProbe(errorMsg, 'error');\n        toastr.error(errorMsg, '配置冲突', { timeOut: 15000 });\n        isGloballyValid = false;\n      }\n    }\n    const allPlaylistIds = new Set(aggregatedConfig.playlists.map(p => p.id));\n    if (aggregatedConfig.defaultPlaylistId && !allPlaylistIds.has(aggregatedConfig.defaultPlaylistId)) {\n      const errorMsg = `[MusicConfig] 配置错误: 最终的 default_playlist_id (\"${aggregatedConfig.defaultPlaylistId}\", 来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\") 指向了一个不存在的歌单。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 15000 });\n      aggregatedConfig.defaultPlaylistId = undefined;\n    }\n    const finalTriggers = aggregatedConfig.triggers.filter(trigger => {\n      if (allPlaylistIds.has(trigger.playlist_id)) {\n        return true;\n      }\n      const errorMsg = `[MusicConfig] 校验失败: 来自文件 \"${trigger._sourceFile}\" 的触发器指向了不存在的歌单ID \"${trigger.playlist_id}\"。该触发器将被忽略。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 10000 });\n      return false;\n    });\n\n    if (!isGloballyValid) {\n      logProbe('[Parser V4] 全局健全性检查失败，配置被拒绝。', 'error');\n      logProbe('', 'groupEnd');\n      logProbe('', 'groupEnd');\n      return null;\n    }\n    logProbe('[Parser V4] 全局健全性检查通过。');\n    logProbe('', 'groupEnd');\n\n    if (aggregatedConfig.playlists.length === 0) {\n      throw new ConfigMissingError('所有配置文件中都未能找到任何有效的歌单 (playlists)。');\n    }\n\n    // --- 数据归一化并返回 ---\n    const playlistsAsMap: Record<string, PlaylistConfig> = {};\n    for (const pl of aggregatedConfig.playlists) {\n      const normalizedTracks = pl.tracks.map(track => ({\n        url: track.url,\n        歌名:\n          track.歌名 && track.歌名.trim() !== ''\n            ? track.歌名\n            : decodeURIComponent(track.url.split('/').pop()?.split('?')[0] || '未知歌曲'),\n        歌手: track.歌手,\n        封面: track.封面,\n      }));\n\n      playlistsAsMap[pl.id] = { ..._.omit(pl, '_sourceFile'), tracks: normalizedTracks };\n    }\n\n    const finalConfig = {\n      playlists: playlistsAsMap,\n      defaultId: aggregatedConfig.defaultPlaylistId,\n      triggers: finalTriggers.map(t => _.omit(t, '_sourceFile')),\n      isMvu: finalIsMvu,\n    };\n\n    logProbe('[Parser V4] 数据归一化完成，运行时配置已就绪。', 'log');\n    logProbe('', 'groupEnd');\n    return finalConfig;\n  } catch (error) {\n    // 这是新的、更智能的错误处理中心\n    if (error instanceof ConfigMissingError) {\n      // 判断这个错误是不是我们自己抛出的“配置缺失”错误\n      logProbe(`[Parser V4] 捕获到可预见的配置错误: ${error.message}`, 'error');\n\n      // [核心修改] 直接使用 error.message 作为 toastr 的提示内容\n      // 这确保了我们抛出的具体错误信息能够直接呈现给用户\n      toastr.error(error.message, '[音乐播放器] 配置缺失', {\n        timeOut: 20000,\n        closeButton: true,\n      });\n    } else {\n      // 如果是其他所有无法预料的错误，比如酒馆环境问题\n      logProbe(`[Parser V4] 解析过程中发生意外顶层错误: ${error}`, 'error');\n      // 显示通用的、建议用户刷新的提示\n      toastr.error(\n        '播放器在加载设置时遇到一个临时问题。这通常可以通过按 F5 刷新酒馆页面来解决。',\n        '[音乐播放器] 加载时遇到临时问题',\n        {\n          timeOut: 20000,\n          closeButton: true,\n        },\n      );\n    }\n    logProbe('', 'groupEnd');\n    return null;\n  }\n}\n\n/**\n * [工厂 V3.0] 从持久化对象重建一个完整的、可供运行时使用的 QueueItem。\n * @param persistedItem - 从酒馆变量读取的、经过 Zod 验证的item。\n * @param playlistConfig - 从当前世界书解析出的对应歌单配置。\n * @returns {QueueItem} 一个完整的运行时 QueueItem。\n */\nfunction reconstituteQueueItem(\n  persistedItem: z.infer<typeof ZodQueueItemState>,\n  playlistConfig: PlaylistConfig,\n): QueueItem {\n  return {\n    playlistId: persistedItem.playlistId,\n    priority: persistedItem.triggerSource?.priority ?? -Infinity,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    onFinishRule: playlistConfig.onFinishRule,\n    currentIndex: persistedItem.currentIndex,\n    playedIndices: new Set(persistedItem.playedIndices),\n    wasEverPlayed: persistedItem.wasEverPlayed,\n    triggeredBy: persistedItem.triggerSource ? 'mvu' : 'base',\n    triggerSource: persistedItem.triggerSource,\n  };\n}\n\ntype CreateQueueItemConfig =\n  | { type: 'base'; playlistId: string }\n  | { type: 'mvu'; playlistId: string; trigger: z.infer<typeof ZodTriggerConfig> };\n\n/**\n * [工厂 V3.0] 创建一个全新的、状态初始化的 QueueItem。\n * @param config - 一个包含所有必要信息的配置对象。\n * @returns {QueueItem | null} 一个完整的队列项，或在失败时返回 null。\n */\nfunction createQueueItem(config: CreateQueueItemConfig): QueueItem | null {\n  const { playlistId } = config;\n\n  if (!playlistId || !allPlaylists[playlistId]) {\n    logProbe(`[Factory] 创建队列项失败：请求的歌单ID \"${playlistId}\" 不存在。`, 'error');\n    return null;\n  }\n\n  const playlistConfig = allPlaylists[playlistId];\n\n  const baseItem: Omit<QueueItem, 'triggeredBy' | 'triggerSource' | 'onFinishRule' | 'priority'> = {\n    playlistId: playlistId,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    currentIndex: 0,\n    playedIndices: new Set(),\n    wasEverPlayed: false,\n  };\n\n  if (config.type === 'base') {\n    return {\n      ...baseItem,\n      priority: -Infinity,\n      triggeredBy: 'base',\n      onFinishRule: playlistConfig.onFinishRule ?? 'loop',\n    };\n  } else {\n    return {\n      ...baseItem,\n      priority: config.trigger.priority,\n      triggeredBy: 'mvu',\n      onFinishRule: playlistConfig.onFinishRule,\n      triggerSource: config.trigger,\n    };\n  }\n}\n\n// =================================================================\n// 7. 运行时初始化与播放器控制 (Runtime & Player Controls)\n// =================================================================\n\nasync function initializePlayerForChat(\n  config: any,\n  authoritativeState: any,\n  options?: { autoPlayIfWasPlaying?: boolean },\n) {\n  logProbe('=== 开始执行【核心·自愈式初始化】 V9.0 ===', 'group');\n  try {\n    // --- 【准备阶段】 清理与重置 ---\n    isCorePlayerInitialized = true;\n    // 注意：StateReset 会重置内存，所以我们需要先读档，再根据读档结果恢复必要的记忆\n    const savedState = readState();\n    StateManager.resetState();\n\n    if (savedState) {\n      // 恢复基础状态（此时 active_queue 还是空的，将在后面重建）\n      StateManager.loadState(savedState);\n    }\n\n    MvuManager.resetState();\n    MvuManager.initialize();\n    const activePlayer = PlaybackEngine.getActivePlayer();\n    if (activePlayer) activePlayer.pause();\n    triggers = [];\n    allPlaylists = {};\n    defaultPlaylistId = '';\n\n    if (!config) {\n      logProbe('[Initializer] 配置无效，初始化中止。', 'error');\n      broadcastFullState();\n      throw new Error('世界书音乐配置解析失败，请检查配置。');\n    }\n\n    allPlaylists = config.playlists;\n    defaultPlaylistId = config.defaultId;\n    triggers = config.triggers;\n\n    isMvuMode = config.isMvu;\n    logProbe(`[Initializer] 全局运行模式已固化: ${isMvuMode ? 'MVU 交响乐模式' : '纯文字 吟游诗人模式'}`);\n\n    const currentStatData = authoritativeState?.mvuData?.stat_data ?? null;\n    const authoritativeMessageId = authoritativeState?.messageId;\n\n    let finalQueue: QueueItem[] = [];\n\n    // --- 【第一步】 确定并验证权威的基础歌单 ID ---\n    let correctBasePlaylistId = defaultPlaylistId;\n\n    const msgZero = getChatMessages(0, { include_swipes: true })[0];\n    const currentSwipeId = msgZero?.swipe_id ?? 0;\n\n    if (msgZero) {\n      const currentGreeting = msgZero.swipes?.[msgZero.swipe_id];\n      const tagMatch = currentGreeting?.match(/<playlist:([^>]+)>/);\n      if (tagMatch && tagMatch[1]) {\n        const tagPlaylistId = tagMatch[1];\n        if (allPlaylists[tagPlaylistId]) {\n          logProbe(`[Initializer-Heal] (基准) 从开场白标签确定权威基础歌单: \"${tagPlaylistId}\"`);\n          correctBasePlaylistId = tagPlaylistId;\n        } else {\n          const errorMsg = `[MusicConfig] 配置警告: 开场白标签 <playlist:${tagPlaylistId}> 指向了一个不存在的歌单ID。将回退至默认歌单。`;\n          logProbe(errorMsg, 'warn');\n          toastr.warning(errorMsg, '配置警告', { timeOut: 15000 });\n        }\n      } else {\n        logProbe(`[Initializer-Heal] (基准) 开场白无标签，使用世界书默认歌单: \"${defaultPlaylistId ?? '无'}\"`);\n      }\n    }\n\n    const lastSwipeId = StateManager.getLastActiveSwipeId();\n\n    if (lastSwipeId !== null && lastSwipeId !== currentSwipeId) {\n      logProbe(`[Initializer] (上下文切换) 检测到平行宇宙跃迁: Swipe ${lastSwipeId} -> ${currentSwipeId}。`, 'warn');\n      logProbe(`[Initializer] (决策) 旧时间线的墓志铭已失效，正在清空...`);\n      StateManager.clearFinishedBasePlaylists();\n    } else {\n      logProbe(`[Initializer] (上下文保持) 同一时间线 (Swipe ${currentSwipeId})，保持墓志铭记录。`);\n    }\n    // 更新当前锚点\n    StateManager.setLastActiveSwipeId(currentSwipeId);\n\n    // 检查 4: 基础歌单与场景歌单冲突检查\n    if (config.isMvu && correctBasePlaylistId) {\n      const scenePlaylistIds = new Set(triggers.map(t => t.playlist_id));\n      if (scenePlaylistIds.has(correctBasePlaylistId)) {\n        const fatalErrorMsg = `[MusicConfig] 致命配置错误: 歌单 \"${correctBasePlaylistId}\" 不能同时被用作基础歌单（在开场白或默认设置中）和场景歌单（被触发器关联）。请为它们使用不同的歌单。`;\n        logProbe(fatalErrorMsg, 'error');\n        toastr.error(fatalErrorMsg, '配置冲突', { timeOut: 20000, closeButton: true });\n        throw new Error('基础歌单与场景歌单存在致命冲突。');\n      }\n    } else if (!config.isMvu && correctBasePlaylistId) {\n      logProbe(`[Initializer] (冲突豁免) 纯文字模式下，跳过基础/场景歌单重名检查。`);\n    }\n\n    // --- 【第二步】 队列净化与重建 (Heal the Past) ---\n    if (savedState) {\n      logProbe('[Initializer-Heal] (净化) 开始审查存档...', 'groupCollapsed');\n      const healedQueue: QueueItem[] = [];\n      // 注意：此时我们使用的是 savedState.active_queue，而不是 StateManager 中的（因为 resetState 会清空）\n      for (const persistedItem of savedState.active_queue) {\n        if (!Object.prototype.hasOwnProperty.call(allPlaylists, persistedItem.playlistId)) {\n          logProbe(`(净化-丢弃) 存档歌单 \"${persistedItem.playlistId}\" 已不存在。`, 'warn');\n          continue;\n        }\n\n        const playlistConfig = allPlaylists[persistedItem.playlistId];\n        const isBaseItem = !persistedItem.triggerSource;\n\n        if (isBaseItem) {\n          if (persistedItem.playlistId === correctBasePlaylistId) {\n            logProbe(`(净化-保留) 基础歌单 \"${persistedItem.playlistId}\" 仍然有效。`);\n            healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n          } else {\n            logProbe(\n              `(净化-丢弃) 基础歌单 \"${persistedItem.playlistId}\" 已被新的权威歌单 \"${correctBasePlaylistId ?? '无'}\" 替代。`,\n              'warn',\n            );\n          }\n        } else {\n          const currentTrigger = triggers.find(t => t.playlist_id === persistedItem.playlistId);\n          logProbe(`(探针-净化) 正在审查存档的MVU歌单 \"${persistedItem.playlistId}\"...`);\n\n          if (playlistConfig.onFinishRule === 'pop') {\n            logProbe(`(净化-丢弃) 原因：规则为 'pop' (场景歌单不应跨会话保留)。`);\n            continue;\n          }\n\n          if (!currentTrigger) {\n            logProbe(`(净化-丢弃) 原因：在最新的世界书配置中已找不到对应的触发器。`, 'warn');\n            continue;\n          }\n\n          if (!MvuManager.checkTriggerCondition(currentTrigger, currentStatData)) {\n            logProbe(`(净化-丢弃) 原因：最新的触发器条件在当前状态下不满足。`);\n            continue;\n          }\n\n          logProbe(`(净化-保留) 验证通过。`);\n          healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n        }\n      }\n      finalQueue = healedQueue;\n      logProbe('[Initializer-Heal] (净化) 审查完成。', 'groupEnd');\n    }\n\n    // --- 【第三步】 队列补充 ---\n    if (currentStatData && triggers.length > 0) {\n      logProbe('[Initializer-Heal] (补充) 正在检查是否有新激活的场景歌单...', 'groupCollapsed');\n      for (const trigger of triggers) {\n        const alreadyExists = finalQueue.some(\n          item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, trigger),\n        );\n\n        if (!alreadyExists && MvuManager.checkTriggerCondition(trigger, currentStatData)) {\n          const playlistConfig = allPlaylists[trigger.playlist_id];\n          if (playlistConfig && playlistConfig.onFinishRule === 'pop') {\n            if (authoritativeMessageId === 0) {\n              logProbe(`(补充) 允许添加 'pop' 歌单 \"${trigger.playlist_id}\"，因为上下文是开场白。`);\n              const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n              if (newItem) finalQueue.push(newItem);\n            } else {\n              logProbe(\n                `(补充-阻止) 场景歌单 \"${trigger.playlist_id}\" 因规则为 'pop' 且上下文非开场白而被忽略。`,\n                'warn',\n              );\n            }\n          } else {\n            const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n            if (newItem) finalQueue.push(newItem);\n          }\n        }\n      }\n      logProbe('[Initializer-Heal] (补充) 检查完成。', 'groupEnd');\n    }\n\n    // --- 【第四步】 基础歌单最终注入 (Final Guarantee V2.0) ---\n    const basePlaylistExists = finalQueue.some(item => item.triggeredBy === 'base');\n    if (!basePlaylistExists && correctBasePlaylistId && allPlaylists[correctBasePlaylistId]) {\n      const isDead = StateManager.getFinishedBasePlaylists().has(correctBasePlaylistId);\n\n      if (isDead) {\n        logProbe(\n          `[Initializer-Heal] (注入-阻止) 基础歌单 \"${correctBasePlaylistId}\" 在此上下文(Swipe ${currentSwipeId})中已完结(墓志铭在册)。尊重历史，拒绝复活。`,\n        );\n      } else {\n        logProbe(`[Initializer-Heal] (注入) 最终注入权威基础歌单 \"${correctBasePlaylistId}\"。`);\n        const baseItem = createQueueItem({ type: 'base', playlistId: correctBasePlaylistId });\n        if (baseItem) finalQueue.push(baseItem);\n      }\n    }\n\n    // --- 【第五步】 最终加载与后续设置 ---\n    logProbe('[Initializer-Finalize] 正在提交最终队列并完成设置...');\n    StateManager.updateQueue(finalQueue);\n\n    // 注意：如果 resetState 重置了模式，我们需要从 savedState 恢复，或者使用默认\n    // 之前的代码是在 resetState 后直接覆盖，但这里我们利用 loadState 已经恢复了一部分\n    // 我们需要确保 StrategyManager 同步\n    const mode = StateManager.getPlaybackMode();\n    StrategyManager.setMode(mode);\n    logProbe(`(探针) 策略模式已同步为: ${mode}`);\n    StrategyManager.notifyQueueChanged();\n\n    PlaybackEngine.initialize();\n\n    const volume = StateManager.getVolume();\n    if (PlaybackEngine.getActivePlayer()) PlaybackEngine.getActivePlayer()!.volume = volume;\n    if (PlaybackEngine.getStandbyPlayer()) PlaybackEngine.getStandbyPlayer()!.volume = 0;\n\n    const initialTopItem = StateManager.getTopQueueItem();\n    if (initialTopItem) {\n      const track = initialTopItem.playlistContent[initialTopItem.currentIndex];\n      if (track && PlaybackEngine.getActivePlayer()) {\n        PlaybackEngine.getActivePlayer()!.src = track.url;\n      }\n    } else {\n      logProbe(`[Initializer] (探针) 最终队列为空（可能因基础歌单已完结），不执行音频预加载。`);\n    }\n\n    if (currentStatData) {\n      await MvuManager.persistCurrentState(currentStatData);\n      logProbe('[Initializer-Finalize]  已将本次创世的权威MVU状态持久化为历史基准。');\n    } else {\n      await MvuManager.persistCurrentState({});\n      logProbe('[Initializer-Finalize] 当前无MVU状态，已将空状态持久化为历史基准。');\n    }\n\n    await writeState('initialization');\n    broadcastFullState();\n\n    if (options?.autoPlayIfWasPlaying) {\n      logProbe('[Initializer] (探针) 检测到来自开场白滑动的“自动播放”意图。', 'warn');\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem) {\n        logProbe('[Initializer] 新的开场白已配置歌单，将执行“创世播放”...');\n        await _handleGenesisPlay();\n      } else {\n        logProbe('[Initializer] 新的开场白未配置歌单，自动播放已取消。');\n      }\n    }\n  } catch (error) {\n    logProbe(`[Initializer] 核心初始化过程中发生严重错误: ${error}`, 'error');\n    console.error(error);\n    throw error;\n  } finally {\n    logProbe('=== 【核心·自愈式初始化】执行完毕 ===', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】播放执行器。\n *              它的单一职责是：接收一个目标索引，并尝试播放它。\n *              它会返回一个 Promise，成功时 resolve，失败时 reject，将错误冒泡给调用者处理。\n *              它自身不包含任何重试或自愈逻辑。\n */\nasync function _executeTransition(targetIndex: number): Promise<void> {\n  logProbe(`[Executor] 收到播放指令，目标索引: ${targetIndex}`, 'group');\n\n  const freshItem = StateManager.getTopQueueItem();\n  if (!freshItem) {\n    logProbe(`[Executor] 执行中止：无有效队列项`, 'warn');\n    logProbe('', 'groupEnd');\n    return Promise.resolve();\n  }\n\n  const targetTrack = freshItem.playlistContent[targetIndex];\n  if (!targetTrack?.url) {\n    logProbe(`[Executor] 执行失败：在索引 ${targetIndex} 处找不到音轨或音轨URL无效。`, 'error');\n    logProbe('', 'groupEnd');\n    throw new Error(`Invalid track at index ${targetIndex}`);\n  }\n\n  try {\n    await PlaybackEngine.transitionToTrack(targetTrack.url, StateManager.getVolume());\n\n    StateManager.setPlaybackState('PLAYING');\n    prepareNextTrack();\n    logProbe(`[Executor] 索引 ${targetIndex} 播放成功。`);\n  } catch (error) {\n    logProbe(`[Executor] PlaybackEngine报告播放失败。原因: ${error}`, 'error');\n    throw error;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】迭代式自愈循环。\n *              此最终版严格遵守 SRP 原则，将决策应用逻辑完全委托给 _applyNavigationDecision。\n */\nasync function _executeSelfHealingLoop(): Promise<void> {\n  logProbe('[SelfHeal] 启动“迭代式自愈循环”... 播放器进入紧急自愈模式。', 'warn');\n\n  let consecutiveFailures = 1;\n  const currentItemForThreshold = StateManager.getTopQueueItem();\n  const threshold = currentItemForThreshold?.playlistContent.length ?? 0;\n\n  if (currentItemForThreshold) {\n    toastr.error(\n      `歌曲《${currentItemForThreshold.playlistContent[currentItemForThreshold.currentIndex]?.歌名 ?? '未知歌曲'}》加载失败，正在尝试自动处理...`,\n    );\n  }\n\n  while (true) {\n    if (threshold > 0 && consecutiveFailures >= threshold) {\n      logProbe(\n        `[SelfHeal] (熔断器) 连续失败 ${consecutiveFailures} 次，已达到或超过阈值 ${threshold}。自愈中止。`,\n        'error',\n      );\n      if (currentItemForThreshold) {\n        toastr.error(`歌单《${currentItemForThreshold.playlistId}》中所有歌曲均无法加载，播放已停止。`);\n      }\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    const currentItem = StateManager.getTopQueueItem();\n    if (!currentItem) {\n      logProbe('[SelfHeal] 自愈中止：中途队列变空。', 'warn');\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    const errorDecision = StrategyManager.getCurrentStrategy().onPlaybackError(currentItem);\n    logProbe(\n      `[SelfHeal] 收到策略 (${StrategyManager.getCurrentStrategy().constructor.name}) 的错误决策: { action: '${errorDecision.action}' }`,\n    );\n\n    const directive = await _applyNavigationDecision(errorDecision);\n\n    if (!directive.needsAsyncEffect) {\n      logProbe('[SelfHeal] 决策应用后无需播放，自愈中止。');\n      // 注意：applyNavigationDecision 内部已经处理了 setPlaying(false) 和广播\n      return;\n    }\n\n    // 防御性编程：确保 targetIndex 存在\n    if (typeof directive.targetIndex !== 'number') {\n      logProbe('[SelfHeal] 决策应用后需要播放，但没有有效的 targetIndex。自愈中止。', 'error');\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    // 步骤 4: 再次尝试播放\n    try {\n      await _executeTransition(directive.targetIndex);\n\n      logProbe('[SelfHeal] 播放成功，自愈循环结束。', 'log');\n      broadcastFullState();\n      return;\n    } catch (nextError) {\n      consecutiveFailures++;\n      const nextTopItem = StateManager.getTopQueueItem();\n      const nextTrackTitle = nextTopItem?.playlistContent[nextTopItem.currentIndex]?.歌名 ?? '未知歌曲';\n      logProbe(`[SelfHeal] 第 ${consecutiveFailures} 次播放失败:`, 'error');\n      console.error(nextError);\n      toastr.error(`下一首《${nextTrackTitle}》加载失败...`);\n    }\n  }\n}\n\nasync function _applyNavigationDecision(\n  decision: StrategyDecision,\n): Promise<{ needsAsyncEffect: boolean; targetIndex?: number }> {\n  logProbe(\n    `[CentralCommand] 正在应用策略决策: { action: '${decision.action}', nextIndex: ${decision.nextIndex ?? 'N/A'} }`,\n    'group',\n  );\n\n  let needsAsyncEffect = false;\n  let targetIndex: number | undefined;\n\n  const currentItem = StateManager.getTopQueueItem();\n\n  switch (decision.action) {\n    case 'GoTo': {\n      if (typeof decision.nextIndex === 'number') {\n        logProbe('[CentralCommand] 指令: GoTo。提交导航步骤...');\n        StateManager.commitNavigationStep(decision.nextIndex);\n        needsAsyncEffect = true;\n        targetIndex = decision.nextIndex;\n      } else {\n        logProbe('[CentralCommand] 致命逻辑错误: GoTo 指令缺少 nextIndex！这是一个策略模块的BUG。', 'error');\n        console.error('探针捕获：错误的决策对象:', decision);\n        console.error('探针捕获：发生错误时的播放器状态:', StateManager.getStateSnapshotForRuntime());\n        needsAsyncEffect = false;\n      }\n      break;\n    }\n\n    case 'Restart': {\n      logProbe('[CentralCommand] 指令: Restart。请求从头重播当前轨道。');\n      if (currentItem) {\n        logProbe('[CentralCommand] (探针) 此决策不改变状态索引，仅生成一个效果指令。');\n        needsAsyncEffect = true;\n        targetIndex = currentItem.currentIndex;\n      }\n      break;\n    }\n\n    case 'RemoveTopAndAdvance': {\n      logProbe('[CentralCommand] 指令: RemoveTopAndAdvance。正在执行【自洽式】队列修改与过渡...');\n      const itemToRemove = StateManager.getTopQueueItem();\n      if (itemToRemove && itemToRemove.triggeredBy === 'base' && itemToRemove.onFinishRule === 'pop') {\n        logProbe(`[CentralCommand] (死亡登记) 基础歌单 \"${itemToRemove.playlistId}\" 即将离场`, 'warn');\n        StateManager.addToFinishedBasePlaylists(itemToRemove.playlistId);\n      }\n      const currentQueue = StateManager.getQueue();\n\n      const poppedItem = currentQueue.shift();\n      logProbe(`(探针) 已从队列中移除: \"${poppedItem?.playlistId}\"`);\n\n      StateManager.updateQueue(currentQueue);\n\n      logProbe('[CentralCommand] (握手) 正在通知 StrategyManager 队列已变更...');\n      StrategyManager.notifyQueueChanged();\n\n      const newTopItem = StateManager.getTopQueueItem();\n      if (newTopItem) {\n        logProbe(`(决策) 新队首为 \"${newTopItem.playlistId}\"，准备过渡到其当前索引: ${newTopItem.currentIndex}`);\n        needsAsyncEffect = true;\n        targetIndex = newTopItem.currentIndex;\n      } else {\n        logProbe('(决策) 队列已空，停止播放。');\n        logProbe('[CentralCommand] (修复) 检测到队列清空，正在下达物理静音指令...');\n        await PlaybackEngine.fadeOutAndPause();\n        StateManager.setPlaybackState('STOPPED');\n        needsAsyncEffect = false;\n      }\n\n      break;\n    }\n\n    case 'LoopReset': {\n      logProbe('[CentralCommand] 指令: LoopReset。执行“指挥家模型”...', 'warn');\n      StateManager.resetCurrentItemForLoop();\n      const currentMode = StateManager.getPlaybackMode();\n      if (currentMode === 'random') {\n        logProbe('(指挥) 检测到随机模式，向作曲家索要新乐谱...');\n        const genesisPlan = (StrategyManager.getCurrentStrategy() as RandomStrategy).prepareGenesis(\n          StateManager.getTopQueueItem(),\n        );\n        if (genesisPlan) {\n          StateManager.commitGenesisState(\n            genesisPlan.newCurrentIndex,\n            genesisPlan.newPlaybackPlan,\n            genesisPlan.newPlanIndex,\n          );\n        }\n      }\n      const finalStartIndex = StateManager.getTopQueueItem()?.currentIndex ?? 0;\n      logProbe(`(指挥) 流程完成。最终确定的新起始索引为: ${finalStartIndex}`);\n      needsAsyncEffect = true;\n      targetIndex = finalStartIndex;\n      break;\n    }\n\n    case 'Stop': {\n      logProbe('[CentralCommand] 指令: Stop。停止播放。');\n      StateManager.setPlaybackState('STOPPED');\n      break;\n    }\n\n    case 'DoNothing':\n    default:\n      logProbe(`[CentralCommand] 指令: DoNothing。无状态变更。`);\n      break;\n  }\n\n  if (decision.action !== 'RemoveTopAndAdvance') {\n    broadcastFullState();\n  }\n\n  const directive = { needsAsyncEffect, targetIndex };\n  logProbe(\n    `[CentralCommand] 决策应用完成。返回指令: { needsAsyncEffect: ${directive.needsAsyncEffect}, targetIndex: ${directive.targetIndex ?? 'N/A'} }`,\n  );\n  logProbe('', 'groupEnd');\n  return directive;\n}\n\n/**\n * @description [V9.6 净化] 释放效果锁并广播最终状态。\n *              这是所有异步控制器 finally 块中的标准“谢幕”程序。\n */\nasync function _releaseEffectLock() {\n  // 探针: 记录锁释放的动作，这对于调试UI卡死问题至关重要\n  logProbe('[LockManager] 正在释放效果锁并广播最终状态...');\n\n  StateManager.setPerformingEffect(false);\n  broadcastFullState();\n}\n\nasync function _handleTrackEnded() {\n  logProbe('[Controller:TrackEnd] === 开始处理轨道自然结束事件 ===', 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:TrackEnd] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:TrackEnd] 请求中止：队列为空。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().onTrackEnd(currentItem);\n    const directive = await _applyNavigationDecision(decision);\n\n    if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    }\n  } catch (error) {\n    logProbe(`[Controller:TrackEnd] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('trackEnded');\n    logProbe('[Controller:TrackEnd] === 轨道结束事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 8. 全局API与事件系统 (Global API & Event System)\n// =================================================================\n\nasync function _handleNavigation(direction: 'next' | 'prev') {\n  logProbe(`[Controller:Nav] === 开始处理用户导航事件 (方向: ${direction}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:Nav] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe(`[Controller:Nav] 请求中止：队列为空。`);\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().advance(currentItem, direction);\n    const directive = await _applyNavigationDecision(decision);\n\n    logProbe(\n      `[Controller:Nav] (探针) 原始决策: ${decision.action}, 处理指令: needsAsyncEffect=${directive.needsAsyncEffect}`,\n    );\n\n    if (decision.action === 'Restart') {\n      logProbe(`[Controller:Nav] 检测到 Restart 决策，执行 seek(0) 效果。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n      if (StateManager.getPlaybackMode() !== 'single') {\n        toastr.info('已是第一首');\n      }\n    } else if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    } else if (decision.action === 'DoNothing') {\n      toastr.info(direction === 'next' ? '已是歌单最后一首。' : '已是歌单第一首。');\n    }\n  } catch (error) {\n    logProbe(`[Controller:Nav] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('navigation');\n    logProbe(`[Controller:Nav] === 用户导航事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\n/**\n * [内部核心] 执行创世播放的实际逻辑。\n * 注意：此函数不检查也不设置效果锁，调用者必须确保已持有锁。\n */\nasync function _executeGenesisPlayInternal(targetIndex: number) {\n  logProbe(`[Internal:Genesis] (动作) 执行内部创世播放逻辑 (目标索引: ${targetIndex})...`);\n  StateManager.setPlaybackState('PLAYING');\n  broadcastFullState();\n  await _executeTransition(targetIndex);\n}\n\nasync function _handleGenesisPlay() {\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Genesis] 请求被拒绝，因为效果正在执行。', 'warn');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Genesis] 请求中止：播放列表为空。');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe(`[Controller:Genesis] === “创世播放”效果开始 (目标索引: ${currentItem.currentIndex}) ===`, 'group');\n\n    await _executeGenesisPlayInternal(currentItem.currentIndex);\n  } catch (error) {\n    logProbe(`[Controller:Genesis] “创世播放”效果执行时发生意外顶层错误: ${error}`, 'error');\n    StateManager.setPlaybackState('STOPPED');\n    broadcastFullState();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('genesisPlay');\n    logProbe(`[Controller:Genesis] === “创世播放”效果结束 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function _handlePlayIndex(index: number) {\n  logProbe(`[Controller:PlayIndex] === 开始处理索引播放事件 (目标: ${index}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:PlayIndex] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentItem = StateManager.getTopQueueItem();\n    const currentMode = StateManager.getPlaybackMode();\n\n    if (currentItem && index === currentItem.currentIndex) {\n      logProbe(`[Controller:PlayIndex] (决策) 用户点击了当前歌曲，将从头重播。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n    } else if (currentMode === 'list' || currentMode === 'single') {\n      logProbe(`[Controller:PlayIndex] (决策) ${currentMode} 模式，执行标准跳转...`);\n      StateManager.setCurrentIndex(index);\n      await _executeTransition(index);\n    } else if (currentMode === 'random') {\n      logProbe(`[Controller:PlayIndex] (决策) random 模式，执行“用户跳转”高级逻辑...`);\n      StateManager.userInitiatedJump(index);\n      await _executeTransition(index);\n    }\n  } catch (error) {\n    logProbe(`[Controller:PlayIndex] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('playIndex');\n    logProbe(`[Controller:PlayIndex] === 索引播放事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function togglePlayPause() {\n  logProbe('[Controller:Toggle] === 开始处理播放/暂停切换事件 (三态机版) ===', 'group');\n\n  // 1. 效果锁检查\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Toggle] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  // 2. 空队列检查\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Toggle] 请求中止：播放列表为空。');\n    toastr.info('播放列表为空');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    // 3. 上锁并广播\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentState = StateManager.getPlaybackState();\n    logProbe(`[Controller:Toggle] 当前状态: ${currentState}`);\n\n    switch (currentState) {\n      case 'STOPPED': {\n        // [核心] 这是首次播放意图的关键点\n        logProbe('[Controller:Toggle] 决策: STOPPED -> PLAYING (视为创世播放)');\n\n        StateManager.setPlaybackState('PLAYING');\n        broadcastFullState();\n\n        // 尝试播放当前队首\n        // 如果是刚加载的歌单，currentIndex 应该是 0，或者是记忆中的位置\n        await _executeTransition(currentItem.currentIndex);\n        break;\n      }\n\n      case 'PLAYING': {\n        logProbe('[Controller:Toggle] 决策: PLAYING -> PAUSED');\n        StateManager.setPlaybackState('PAUSED');\n        broadcastFullState();\n        await PlaybackEngine.fadeOutAndPause();\n        break;\n      }\n\n      case 'PAUSED': {\n        logProbe('[Controller:Toggle] 决策: PAUSED -> PLAYING (恢复)');\n        StateManager.setPlaybackState('PLAYING');\n        broadcastFullState();\n        await PlaybackEngine.resumeAndFadeIn(StateManager.getVolume());\n        break;\n      }\n    }\n  } catch (error) {\n    logProbe(`[Controller:Toggle] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('togglePlayPause');\n    logProbe('[Controller:Toggle] === 播放/暂停切换事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\nfunction playNext() {\n  void _handleNavigation('next');\n}\n\nfunction playPrev() {\n  void _handleNavigation('prev');\n}\n\nfunction setupGlobalAPI() {\n  window.musicPlayerAPI = {\n    requestInitialization: (): Promise<void> => {\n      if (isInitializedForThisChat) {\n        logProbe('[API] requestInitialization (已完成): 一个迟到的界面发来请求，立即返回成功契约。');\n        broadcastFullState();\n        return Promise.resolve();\n      }\n\n      if (!_initializationPromise) {\n        logProbe('[API] requestInitialization (首次): 第一个界面请求到达，正在创建【共享的】Promise契约...');\n        _initializationPromise = new Promise((resolve, reject) => {\n          _initializationPromiseControls = { resolve, reject };\n        });\n      } else {\n        logProbe('[API] requestInitialization (后续): 又一个界面请求到达，返回【已存在的】共享契约。');\n      }\n\n      return _initializationPromise;\n    },\n\n    togglePlayPause: () => togglePlayPause(),\n    playNext: () => playNext(),\n    playPrev: () => playPrev(),\n    playIndex: (index: number) => {\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem && index >= 0 && index < currentItem.playlistContent.length) {\n        void _handlePlayIndex(index);\n      }\n    },\n    persistVolumeAndBroadcast: (volume: number) => {\n      const finalVolume = Math.max(0, Math.min(1, volume));\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      StateManager.setVolume(finalVolume);\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = finalVolume;\n      void writeState('persistVolume');\n      broadcastFullState();\n    },\n    setLiveVolume: (volume: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = Math.max(0, Math.min(1, volume));\n    },\n\n    setPlaybackMode: (mode: PlaybackMode) => {\n      logProbe(`=== 开始执行【模式切换】事务 (请求: ${mode}) ===`, 'group');\n      const oldMode = StateManager.getPlaybackMode();\n      if (mode === oldMode) {\n        logProbe(`[ModeSwitch] 模式未变更 (仍为 ${mode})，事务提前中止。`);\n        logProbe('', 'groupEnd');\n        return;\n      }\n\n      StateManager.setPlaybackMode(mode);\n      StrategyManager.setMode(mode);\n\n      logProbe(`[ModeSwitch] 策略已切换为: ${StrategyManager.getCurrentStrategy().constructor.name}`);\n\n      if (oldMode === 'random') {\n        logProbe('[ModeSwitch] 正在为旧模式 \"random\" 执行“离开”生命周期钩子...');\n        StateManager.clearRandomModePlan();\n      }\n      if (mode === 'random') {\n        logProbe('[ModeSwitch] 正在为新模式 \"random\" 执行“进入”生命周期钩子...');\n        StrategyManager.notifyQueueChanged();\n      }\n\n      void writeState('setPlaybackMode');\n      broadcastFullState();\n      logProbe('=== 【模式切换】事务执行完毕 ===', 'groupEnd');\n    },\n    seekTo: (percentage: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer?.duration) activePlayer.currentTime = activePlayer.duration * percentage;\n    },\n    getCurrentState: (): FullStatePayload => {\n      const i = StateManager.getTopQueueItem();\n      const c = i?.playlistContent ?? [];\n      const x = i?.currentIndex ?? 0;\n      const stateToReturn: FullStatePayload = {\n        currentItem: c[x] ? { title: c[x].歌名, artist: c[x].歌手, cover: c[x].封面 } : null,\n        isPlaying: StateManager.isPlaying(),\n        playbackState: StateManager.getPlaybackState(),\n        playbackMode: StateManager.getPlaybackMode(),\n        masterVolume: StateManager.getVolume(),\n        playlist: c.map(t => ({ title: t.歌名, artist: t.歌手, cover: t.封面 })),\n        isTransitioning: StateManager.isPerformingEffect(),\n      };\n      logProbe('[探针 B] 前端主动调用 getCurrentState 获取初始状态，后台返回的数据如下:', 'warn');\n      console.dir(stateToReturn);\n      return stateToReturn;\n    },\n\n    onFullStateUpdate: (c: (payload: FullStatePayload) => void) => {\n      if (typeof c === 'function') {\n        fullStateUpdateCallbacks.push(c);\n        logProbe(`[API] 前端注册了 fullStateUpdate 监听器。当前监听数: ${fullStateUpdateCallbacks.length}`);\n\n        return () => {\n          const index = fullStateUpdateCallbacks.indexOf(c);\n          if (index > -1) {\n            fullStateUpdateCallbacks.splice(index, 1);\n            logProbe(`[API] 前端注销了 fullStateUpdate 监听器。剩余监听数: ${fullStateUpdateCallbacks.length}`);\n          }\n        };\n      }\n\n      return () => {};\n    },\n\n    onTimeUpdate: (c: (payload: TimeUpdatePayload) => void) => {\n      if (typeof c === 'function') {\n        timeUpdateCallbacks.push(c);\n\n        return () => {\n          const index = timeUpdateCallbacks.indexOf(c);\n          if (index > -1) {\n            timeUpdateCallbacks.splice(index, 1);\n          }\n        };\n      }\n      return () => {};\n    },\n  };\n  initializeGlobal('musicPlayerAPI', window.musicPlayerAPI);\n}\n\n// =================================================================\n// 9. 酒馆集成与主执行区 (Tavern Integration & Main Execution)\n// =================================================================\n\nfunction executeHardReset() {\n  logProbe('[HardReset] “优雅停机”协议启动...', 'warn');\n\n  isScriptActive = false;\n\n  PlaybackEngine.getActivePlayer()?.pause();\n  logProbe('[HardReset] 音频已暂停。');\n\n  logProbe('[HardReset] 即将调用 reloadIframe()。');\n  reloadIframe();\n}\n\nasync function tryInitialize() {\n  if (isInitializedForThisChat) return;\n\n  const currentChatId = SillyTavern.getCurrentChatId ? SillyTavern.getCurrentChatId() : null;\n\n  if (SillyTavern.chat.length > 0 && currentChatId !== null) {\n    // [原则: SRP] isInitializedForThisChat 标志现在是这个函数的“守卫”，确保初始化只执行一次。\n    isInitializedForThisChat = true;\n    _currentChatId = currentChatId;\n\n    logProbe(`【初始化指挥官 V9.8】锁定ID: ${_currentChatId}，开始执行“分流-等待-执行”协议...`, 'group');\n\n    try {\n      // --- 步骤一：检测 (Detect) ---\n      // [原则: SSoT] 初始化流程的第一个动作，就是获取“世界书”这个唯一事实来源。\n      const config = await parseWorldbookConfig();\n      if (!config) {\n        throw new Error('无法解析世界书配置，初始化中止。');\n      }\n\n      const isMvuCard = config.isMvu;\n      logProbe(`(探针-决策) 作者意图判断 -> 是MVU卡吗? ${isMvuCard}`);\n\n      // --- 步骤二：分流 (Branch) & 等待 (Wait) ---\n      if (isMvuCard) {\n        logProbe('【指挥官】(路径选择) 检测到MVU卡，进入“安全路径”，开始等待MVU就绪...');\n        // [原则: CQS] _waitForMvuGenesis 是一个“查询”，它询问外部环境状态，直到满足条件。\n        // 注意: MVU 模式的事件注册 (_registerMvuEventListeners) 是在 _waitForMvuGenesis 内部成功后触发的\n        const mvuIsReady = await _waitForMvuGenesis();\n        if (!mvuIsReady) {\n          throw new Error('MVU集成初始化失败或超时，部分功能将不可用。');\n        }\n        logProbe('【指挥官】MVU已完全就绪，可以安全继续。');\n      } else {\n        logProbe('【指挥官】(路径选择) 检测到纯文字卡，进入“快速路径”。');\n        _registerTextEventListeners();\n      }\n\n      // --- 步骤三：执行 (Execute) ---\n      logProbe('【指挥官】所有前置条件满足，开始执行播放器核心初始化...');\n\n      let authoritativeState = null;\n      if (isMvuCard) {\n        logProbe('【指挥官】(查询) 正在为MVU卡查找权威状态...');\n        authoritativeState = await _findLatestAuthoritativeMvuState();\n      } else {\n        logProbe('【指挥官】(跳过) 纯文字卡，无需查找MVU状态。');\n      }\n\n      await initializePlayerForChat(config, authoritativeState);\n\n      _registerContextualEventListeners();\n\n      if (_initializationPromiseControls) {\n        logProbe('【指挥官】(探针) 后台初始化成功，兑现 Promise 契约，唤醒前端。');\n        _initializationPromiseControls.resolve();\n      }\n    } catch (error) {\n      logProbe(`【指挥官】在初始化主流程中发生严重错误: ${error}`, 'error');\n      // 如果发生任何错误，都要通知前端，让它显示错误信息\n      if (_initializationPromiseControls) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        _initializationPromiseControls.reject(errorMessage);\n      }\n    } finally {\n      _initializationPromiseControls = null;\n      logProbe('【初始化指挥官 V9.8】协议执行完毕。', 'groupEnd');\n    }\n  }\n}\n\nfunction _registerMvuEventListeners() {\n  logProbe('[EventDispatcher] 正在注册【运行时】MVU 事件监听器...');\n\n  const createReconcileHandler = (eventName: string) => {\n    return (eventPayload?: any) => {\n      if (!isMvuIntegrationActive || !isCorePlayerInitialized) {\n        logProbe(`[Gatekeeper] 捕获到MVU事件 (${eventName})，但系统未就绪，已忽略。`, 'warn');\n        return;\n      }\n      logProbe(`[Event] 捕获到MVU事件: ${eventName}，即将唤醒校准官...`);\n      // (SSoT原则) 将事件载荷这个“事实”直接传递给校准官\n      void _reconcilePlaylistQueue(eventPayload);\n    };\n  };\n\n  eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, createReconcileHandler('VARIABLE_UPDATE_ENDED'));\n\n  // [已移除] MESSAGE_DELETED 已移动至 _registerContextualEventListeners 以实现通用支持\n\n  logProbe('[EventDispatcher] MVU监听器部署完毕。');\n}\n\n/**\n * 注册纯文字模式 (\"吟游诗人\") 专属的事件监听器。\n * 职责: 监听文本变动事件，并直接呼叫校准官。\n */\nfunction _registerTextEventListeners() {\n  logProbe('[EventDispatcher] 正在注册【吟游诗人】文本模式事件监听器...', 'group');\n\n  // 1. 监听 AI 生成完毕 (MESSAGE_RECEIVED)\n  eventOn(tavern_events.MESSAGE_RECEIVED, (id: number) => {\n    if (!isScriptActive) return;\n\n    logProbe(`[Event] 文本模式捕获到 MESSAGE_RECEIVED (id: ${id})，触发校准...`);\n    void _reconcilePlaylistQueue(undefined);\n  });\n\n  // 2. 监听 用户编辑消息 (MESSAGE_EDITED)\n  eventOn(tavern_events.MESSAGE_EDITED, async (id: number) => {\n    if (!isScriptActive) return;\n\n    logProbe(`[Event] 文本模式捕获到 MESSAGE_EDITED (id: ${id})，触发校准与UI补救...`);\n\n    // 第一步：校准播放队列（听觉层）\n    await _reconcilePlaylistQueue(undefined);\n\n    // 第二步：如果校准后队列有歌单，确保 UI 标签存在（视觉层）\n    await _ensureUiVisibility();\n  });\n\n  logProbe('[EventDispatcher] 文本模式监听器部署完毕。', 'groupEnd');\n}\n\n/**\n * [V9.1 核心处理器] 统一处理所有导致“运行时历史”变更的事件。\n * 职责：通知校准官进行全量状态同步。\n * @param eventName - 触发此处理器的事件名，用于日志记录。\n */\nasync function _handleHistoryChangeEvent(eventName: string, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  logProbe(`[HistoryChange] 检测到历史变更事件: ${eventName}。`);\n  if (!isCorePlayerInitialized) return;\n\n  if (triggers.length === 0) {\n    // 理论上 ParseConfig 阶段会为 Text 模式生成虚拟触发器，所以 triggers 不应为空。\n    // 但如果真的为空，说明没有任何音乐配置，直接跳过。\n    logProbe('[HistoryChange] (分流) 未检测到任何触发器配置，跳过校准。');\n    await _ensureUiVisibility();\n    return;\n  }\n\n  logProbe(`[HistoryChange] 正在委托校准官进行全量状态校准...`);\n\n  // 校准官内部会根据 isMvuMode 自动决定是查 MVU 还是查 TextTagManager。\n  await _reconcilePlaylistQueue(undefined, options);\n\n  await _ensureUiVisibility();\n}\n\n/**\n * [V9.9 核心修正] 处理新AI消息渲染事件的专用处理器。\n * (SRP: Single Responsibility Principle)\n * @param messageId - 由事件传来的消息ID。\n */\nasync function _handleNewAssistantMessage(messageId: number): Promise<void> {\n  logProbe(`[Injector] 捕获到 CHARACTER_MESSAGE_RENDERED 事件，message_id: ${messageId}`);\n\n  if (messageId === 0) {\n    logProbe(`[Injector] (探针) 操作中止：message_id 为 0 (开场白)，权限属于作者，无需注入。`);\n    return;\n  }\n\n  const topQueueItem = StateManager.getTopQueueItem();\n  if (!topQueueItem) {\n    logProbe(`[Injector] (守门员) 拒绝注入：当前播放队列为空。`);\n    return;\n  }\n\n  try {\n    const message = getChatMessages(messageId)?.[0];\n\n    if (message && message.role !== 'user' && !message.message.includes('<DarkBramblePlayer/>')) {\n      logProbe(`[Injector] (探针) 条件满足，立即为 message_id: ${messageId} 执行注入...`);\n\n      await setChatMessages([{ message_id: messageId, message: `${message.message}\\n<DarkBramblePlayer/>` }]);\n\n      logProbe(`[Injector] (探针) 注入成功。`);\n    } else {\n      logProbe(`[Injector] (探针) 操作跳过：消息是用户发送的，或已包含标签。Role: ${message?.role}`);\n    }\n  } catch (error) {\n    logProbe(`[Injector] 为 message_id: ${messageId} 注入标签时发生严重错误:`, 'error');\n    console.error(error);\n  }\n}\n\n/**\n * [V9.95 新增] UI 可见性卫士。\n * 职责：在 MVU 延迟加载或消息删除后，确保如果音乐在播放，界面一定存在。\n * 原则：SSoT (以队列状态为准), 鲁棒性 (补救缺失的 UI)\n */\nasync function _ensureUiVisibility() {\n  logProbe('[UiGuard] 正在检查界面一致性 (高性能局部扫描)...', 'groupCollapsed');\n\n  const topQueueItem = StateManager.getTopQueueItem();\n  if (!topQueueItem) {\n    logProbe('[UiGuard] 队列为空，无需 UI。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    // [步骤 1] 获取最后一条消息，作为定位锚点\n    // 参数 -1 表示获取最新的楼层\n    const lastMsgList = getChatMessages(-1);\n\n    if (!lastMsgList || lastMsgList.length === 0) {\n      logProbe('[UiGuard] 无法获取最新楼层锚点，检查中止。', 'warn');\n      logProbe('', 'groupEnd');\n      return;\n    }\n\n    // [步骤 2] 计算最近 10 楼的 ID 范围\n    // 假设最后一条 ID 是 100，我们想要 91-100 (共10条)\n    const lastId = lastMsgList[0].message_id;\n    // 使用 Math.max 确保不会算出负数 ID\n    const startId = Math.max(0, lastId - 9);\n    const rangeString = `${startId}-${lastId}`;\n\n    logProbe(`[UiGuard] 正在获取最近的 10 条消息 (ID范围: ${rangeString})...`);\n\n    // [步骤 3] 仅拉取这 10 条数据\n    // 接口支持 \"StartID-EndID\" 格式的字符串\n    const recentMessages = getChatMessages(rangeString);\n\n    if (!recentMessages || recentMessages.length === 0) {\n      logProbe('[UiGuard] 局部消息拉取为空，检查中止。', 'warn');\n      logProbe('', 'groupEnd');\n      return;\n    }\n\n    let foundTarget = false;\n\n    // [步骤 4] 倒序扫描这 10 条数据\n    for (let i = recentMessages.length - 1; i >= 0; i--) {\n      const msg = recentMessages[i];\n\n      // 1. 跳过用户消息\n      if (msg.role === 'user') {\n        continue;\n      }\n\n      // 2. 遇到开场白停止 (尊重作者排版)\n      if (msg.message_id === 0) {\n        logProbe('[UiGuard] 回溯至开场白，停止。');\n        break;\n      }\n\n      // 3. 检查是否已有标签\n      if (msg.message && msg.message.includes('<DarkBramblePlayer/>')) {\n        logProbe(`[UiGuard] 在 message_id: ${msg.message_id} 处发现已有标签，状态正常。`);\n        foundTarget = true;\n        break;\n      }\n\n      // 4. 执行注入\n      logProbe(`[UiGuard] 发现目标宿主: message_id: ${msg.message_id} (${msg.role})，执行补救注入...`);\n      const newContent = `${msg.message}\\n<DarkBramblePlayer/>`;\n\n      await setChatMessages([\n        {\n          message_id: msg.message_id,\n          message: newContent,\n        },\n      ]);\n\n      logProbe('[UiGuard] 补救注入成功。');\n      foundTarget = true;\n      break;\n    }\n\n    if (!foundTarget) {\n      logProbe('[UiGuard] 在最近 10 条消息中未发现合适的注入点。');\n    }\n  } catch (error) {\n    logProbe(`[UiGuard] 执行补救注入时发生错误: ${error}`, 'error');\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * [V9.0 核心] 执行一次“软重置”。\n * 这将在不刷新整个页面的情况下，重新执行完整的初始化流程。\n * 用于响应“开场白滑动”等根本性的上下文变更。\n */\nasync function _executeSoftReset(options?: { autoPlayIfWasPlaying?: boolean }) {\n  logProbe('[SoftReset] 检测到根本性上下文变更，启动“软重置”协议...', 'warn');\n  try {\n    const config = await parseWorldbookConfig();\n\n    logProbe('[SoftReset] 正在为新的开场白查找权威MVU状态...');\n    const authoritativeState = await _findLatestAuthoritativeMvuState();\n\n    await initializePlayerForChat(config, authoritativeState, options);\n  } catch (error) {\n    logProbe('[SoftReset] 软重置过程中发生严重错误。', 'error');\n    console.error(error);\n  }\n}\n\n/**\n * [V9.9 原始数据卫士] (Raw Data Guard)\n * 职责 (Query): 直接穿透封装层，检查酒馆内存中指定消息的内容是否已就绪。\n * 这是区分 \"浏览历史\" (内容已存在) 和 \"触发生成\" (内容为空) 的唯一事实来源。\n */\nfunction _isSwipeContentReady(messageId: number): boolean {\n  // 1. 安全获取上下文\n  // [修复] 必须通过 window.parent 才能在 iframe 中访问到酒馆的真实数据\n  const context = (window.parent as any).SillyTavern?.getContext?.();\n\n  if (!context || !context.chat) {\n    // 极罕见情况：如果上下文不存在，为安全起见视为未就绪\n    return false;\n  }\n\n  // 2. 获取消息对象\n  const msg = context.chat[messageId];\n  if (!msg) return false;\n\n  // 3. 获取指针和数据槽\n  const pointer = msg.swipe_id;\n  const swipes = msg.swipes;\n\n  // 4. 核心判定：必须是字符串且长度大于0\n  if (Array.isArray(swipes) && typeof pointer === 'number') {\n    const content = swipes[pointer];\n    // 只有当内容是实实在在的字符串，且不是空串时，才视为历史记录\n    return typeof content === 'string' && content.length > 0;\n  }\n\n  return false;\n}\n\nfunction _registerContextualEventListeners() {\n  logProbe('[EventDispatcher] 正在注册“上下文专属”事件监听器...');\n\n  eventOn(tavern_events.CHARACTER_MESSAGE_RENDERED, (id: number) => {\n    if (!isScriptActive) return;\n    void _handleNewAssistantMessage(id);\n  });\n\n  eventOn(tavern_events.MESSAGE_DELETED, (deletedId: number) => {\n    if (!isScriptActive) return;\n    logProbe(`[EventAdapter] 捕获到删除事件 (原ID: ${deletedId})，正在通过“高级历史通道”触发全量校准...`);\n    void _handleHistoryChangeEvent('MESSAGE_DELETED');\n  });\n\n  eventOn(tavern_events.MESSAGE_SWIPED, (id: number) => {\n    if (!isScriptActive) return;\n\n    // 原始数据卫士 (Raw Data Guard)\n    // 目的: 区分 \"浏览历史Swipe\" 和 \"触发生成Swipe\"\n    // 原理: 直接检查内存。如果内容为空，说明是生成行为，必须拦截。\n    if (!_isSwipeContentReady(id)) {\n      logProbe(\n        `[Event-Swipe] (卫士) 拦截生效！检测到 message_id: ${id} 的内容尚未填充 (生成中/空内容)，忽略本次操作。`,\n        'warn',\n      );\n      return;\n    }\n\n    logProbe(`[Event] 捕获到滑动事件 (message_id: ${id})。卫士已放行 (内容已就绪)。`);\n    if (!isCorePlayerInitialized) return;\n\n    if (id === 0) {\n      logProbe('[Event-Swipe] 判断为开场白滑动，执行软重置...');\n      const wasPlaying = StateManager.isPlaying();\n      logProbe(`[Event-Swipe] (探针) 软重置前的播放状态: ${wasPlaying}`);\n      void _executeSoftReset({ autoPlayIfWasPlaying: wasPlaying });\n    } else {\n      logProbe('[Event-Swipe] 判断为历史消息滑动，执行历史变更处理...');\n      void _handleHistoryChangeEvent('MESSAGE_SWIPED', { transitionEffect: 'hard' });\n    }\n  });\n\n  logProbe('[EventDispatcher] “上下文专属”事件监听器注册完毕。');\n}\n\n/**\n * [原则: SRP] 这个函数的单一职责是：作为一个返回 Promise 的“观察哨”，\n * 它只负责“等待MVU创世完成”这一件事。成功则 resolve(true)，失败或超时则 resolve(false)。\n * 所有后续操作（如注册事件）都作为成功后的“副作用”在内部执行。\n */\nasync function _waitForMvuGenesis(): Promise<boolean> {\n  logProbe('【安全观察哨】已上岗，开始执行MVU就绪检查...', 'group');\n\n  try {\n    // [探针] 阶段一：等待 MVU 框架本身出现\n    await waitGlobalInitialized('Mvu');\n    logProbe('【观察哨】(探针) 阶段一成功：MVU 框架已加载。');\n  } catch (e) {\n    logProbe(`【观察哨】(探针) 阶段一失败: ${e}。`, 'warn');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段二：轮询观察，等待 MVU 将初始数据写入消息楼层\n  const WATCHER_TIMEOUT = 10000;\n  const WATCHER_INTERVAL = 250;\n  const startTime = Date.now();\n  let isGenesisComplete = false;\n\n  logProbe('【观察哨】(探针) 阶段二开始：正在严密监视 message_id: 0 的创世数据...');\n  while (Date.now() - startTime < WATCHER_TIMEOUT) {\n    try {\n      const mvuData: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n      if (mvuData && (mvuData.swipes_data || mvuData.stat_data)) {\n        logProbe('【观察哨】(探针) 阶段二成功：在消息楼层中确认到创世数据！');\n        isGenesisComplete = true;\n        break;\n      }\n    } catch (error) {\n      /* 在MVU启动初期，查询失败是正常现象，静默处理 */\n    }\n    await new Promise(resolve => setTimeout(resolve, WATCHER_INTERVAL));\n  }\n\n  if (!isGenesisComplete) {\n    logProbe('【观察哨】(探针) 阶段二失败：观察超时！', 'error');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段三：所有条件满足，执行激活序列\n  logProbe('【观察哨】(探针) 阶段三开始：执行MVU集成激活序列...');\n  try {\n    _registerMvuEventListeners();\n    isMvuIntegrationActive = true;\n    logProbe('【观察哨】(探针) 阶段三成功：MVU集成已完全激活。');\n    logProbe('【安全观察哨】任务成功完成！', 'groupEnd');\n    return true;\n  } catch (error) {\n    logProbe(`【观察哨】(探针) 阶段三失败：激活序列发生意外崩溃: ${error}`, 'error');\n    isMvuIntegrationActive = false;\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n}\n\n$(() => {\n  PlaybackEngine.initialize();\n  setupGlobalAPI();\n\n  eventOn(tavern_events.CHAT_CHANGED, () => {\n    logProbe(`[硬重置] CHAT_CHANGED 事件触发，检测到聊天上下文变更。即将执行“优雅停机”协议。`, 'warn');\n    executeHardReset();\n  });\n\n  const observerInterval = setInterval(() => {\n    void tryInitialize();\n    if (isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化成功，观察者已销毁。');\n    }\n  }, 250);\n\n  setTimeout(() => {\n    if (!isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化超时！', 'error');\n\n      if (_initializationPromiseControls) {\n        _initializationPromiseControls.reject('Initialization timed out after 10 seconds.');\n        _initializationPromiseControls = null;\n      }\n    }\n  }, 10000);\n\n  $(window).on('pagehide', () => {\n    logProbe('PAGEHIDE 事件触发！', 'warn');\n\n    PlaybackEngine.getActivePlayer()?.pause();\n    logProbe('音频已暂停。');\n  });\n});\n"],"names":["z","performance","now","ZodTrackConfig","object","string","optional","url","message","strict","ZodSingleCondition","variable_path","greater_than","number","greater_than_or_equal_to","less_than","less_than_or_equal_to","value","union","boolean","value_contains","time_in_range","regex","ZodTriggerConfig","type","literal","playlist_id","priority","default","conditions","array","nonempty","ZodPlaylistConfig","id","onFinishRule","enum","tracks","ZodWorldbookConfig","default_playlist_id","playlists","triggers","is_mvu","ZodQueueItemState","playlistId","currentIndex","playedIndices","wasEverPlayed","triggerSource","ZodPersistedState","active_queue","mode","volume","min","max","last_active_swipe_id","nullable","finished_base_playlists","previousMvuState","record","any","STATE_KEY_MVU_HISTORY","_parseTimeToMinutes","timeStr","cleanStr","trim","replace","match","hours","parseInt","minutes","MvuManager","_previousMvuState","_checkTriggerCondition","trigger","statData","condition","currentValue","_","get","conditionMet","isHandled","undefined","includes","currentTimeInMinutes","startStr","endStr","split","startMinutes","endMinutes","checkTriggerCondition","initialize","savedState","getVariables","error","resetState","persistCurrentState","currentStateData","isScriptActive","cloneDeep","updateVariablesWith","vars","getPreviousState","calculateChangeReport","previousStateData","allTriggers","report","newlyActiveTriggers","newlyInactiveTriggers","wasMet","isMet","push","length","TextTagManager","SCENE_TAG_REGEX","getLatestState","async","latestMsgs","getChatMessages","lastId","message_id","rangeString","Math","msgs","i","msg","role","allMatches","matchAll","rawId","toLowerCase","normalizedId","StateManager","_activePlaylistQueue","_lastActiveSwipeId","_finishedBasePlaylists","Set","_playbackMode","_masterVolume","_playbackState","_isPerformingEffect","_applyDepartureIsHistoryPrinciple","item","departingIndex","add","getPlaybackMode","getVolume","isPlaying","getPlaybackState","isPerformingEffect","getTopQueueItem","getQueue","getStateSnapshotForRuntime","playbackState","getStateSnapshotForPersistence","map","omit","Array","from","clear","loadState","stateToLoad","size","setPlaybackMode","setVolume","setPlaybackState","newState","setPerformingEffect","isPerforming","getLastActiveSwipeId","setLastActiveSwipeId","getFinishedBasePlaylists","addToFinishedBasePlaylists","clearFinishedBasePlaylists","updateQueue","newQueue","sort","a","b","setCurrentIndex","index","currentItem","commitNavigationStep","newTrackIndex","playbackPlan","newPlanIndex","indexOf","planIndex","clearHistoryForCurrentItem","resetCurrentItemForLoop","commitGenesisState","newCurrentIndex","newPlaybackPlan","userInitiatedJump","trackIndex","this","clearRandomModePlan","applyNewPlaybackPlan","plan","PlaybackEngine","_playerA","_playerB","_activePlayer","_standbyPlayer","_fadeInterval","_fadeVolumeAsync","player","targetVolume","duration","Promise","resolve","clearInterval","startVolume","steps","volumeStep","currentStep","window","setInterval","createPlayer","audio","Audio","preload","crossOrigin","addEventListener","broadcastFullState","decision","StrategyManager","getCurrentStrategy","onTrackEnd","directive","_applyNavigationDecision","needsAsyncEffect","targetIndex","_executeTransition","_executeSelfHealingLoop","_releaseEffectLock","writeState","_handleTrackEnded","broadcastTimeUpdate","getActivePlayer","getStandbyPlayer","transitionToTrack","targetTrackUrl","slice","Error","standbyPlayer","activePlayer","src","load","reject","onCanPlay","removeEventListener","onError","e","target","pause","newActivePlayer","playPromise","play","fadeOutAndPause","executeHardCut","resumeAndFadeIn","ListStrategy","onQueueChanged","_currentItem","advance","direction","playlistContent","totalTracks","nextIndex","action","lastIndex","totalValidTracks","onPlaybackError","SingleStrategy","RandomStrategy","_generateIntelligentShuffle","allTrackIndices","sourceForShuffle","filter","has","j","floor","random","join","_generatePlaybackPlan","shuffledIndices","knownSequence","_handlePlanEnd","allIndices","shuffled","prepareGenesis","nextPlanIndex","targetTrackIndex","prevPlanIndex","_strategies","list","single","_currentStrategy","setMode","notifyQueueChanged","constructor","name","STATE_KEY","isInitializedForThisChat","isReconciling","_initializationPromiseControls","_initializationPromise","allPlaylists","defaultPlaylistId","isMvuIntegrationActive","isCorePlayerInitialized","isMvuMode","_currentChatId","fullStateUpdateCallbacks","timeUpdateCallbacks","_reconcilePlaylistQueue","eventPayload","options","oldTopItem","stat_data","authState","_findLatestAuthoritativeMvuState","mvuData","changeReport","remove","some","inactiveTrigger","areTriggersFunctionallyEqual","activeTrigger","newItem","createQueueItem","newTopItem","transitionEffect","_executeGenesisPlayInternal","track","currentPlaylist","payload","title","artist","cover","playbackMode","masterVolume","playlist","isTransitioning","forEach","callback","currentTime","source","dataToSave","_formatZodErrorForToastr","issue","issues","path","toastrMessage","toastr","timeOut","getCanonicalString","Object","keys","key","String","conditionsA","conditionsB","every","val","context","messageId","swipeId","mvuDataContainer","Mvu","getMvuData","swipeSpecificData","swipes_data","allMessages","include_swipes","currentMessageId","parseWorldbookConfig","ConfigMissingError","super","aggregatedConfig","_defaultPlaylistIdSourceFile","explicitMvuMode","worldbookNames","getCharWorldbookNames","searchOrder","primary","additional","Boolean","foundAnyConfigEntry","bookName","configEntries","getWorldbook","entry","rawConfig","YAML","parse","content","validationResult","safeParse","success","data","p","_sourceFile","t","warningMsg","warning","closeButton","finalIsMvu","uniquePlaylistIds","pid","virtualTrigger","isGloballyValid","playlistsById","groupBy","errorMsg","allPlaylistIds","finalTriggers","playlistsAsMap","pl","normalizedTracks","decodeURIComponent","pop","defaultId","isMvu","reconstituteQueueItem","persistedItem","playlistConfig","Infinity","triggeredBy","config","baseItem","initializePlayerForChat","authoritativeState","savedData","readState","currentStatData","authoritativeMessageId","finalQueue","correctBasePlaylistId","msgZero","currentSwipeId","swipe_id","currentGreeting","swipes","tagMatch","tagPlaylistId","lastSwipeId","fatalErrorMsg","healedQueue","prototype","hasOwnProperty","call","currentTrigger","find","initialTopItem","autoPlayIfWasPlaying","_handleGenesisPlay","freshItem","targetTrack","nextTrack","prepareNextTrack","consecutiveFailures","currentItemForThreshold","threshold","errorDecision","nextError","nextTopItem","nextTrackTitle","itemToRemove","currentQueue","shift","genesisPlan","finalStartIndex","_handleNavigation","info","setupGlobalAPI","musicPlayerAPI","requestInitialization","togglePlayPause","playNext","playPrev","playIndex","currentMode","_handlePlayIndex","persistVolumeAndBroadcast","finalVolume","setLiveVolume","oldMode","seekTo","percentage","getCurrentState","c","x","onFullStateUpdate","splice","onTimeUpdate","initializeGlobal","tryInitialize","currentChatId","SillyTavern","getCurrentChatId","chat","isMvuCard","waitGlobalInitialized","WATCHER_TIMEOUT","WATCHER_INTERVAL","startTime","Date","isGenesisComplete","setTimeout","createReconcileHandler","eventName","eventOn","events","VARIABLE_UPDATE_ENDED","_registerMvuEventListeners","_waitForMvuGenesis","tavern_events","MESSAGE_RECEIVED","MESSAGE_EDITED","_ensureUiVisibility","CHARACTER_MESSAGE_RENDERED","setChatMessages","_handleNewAssistantMessage","MESSAGE_DELETED","deletedId","_handleHistoryChangeEvent","MESSAGE_SWIPED","parent","getContext","pointer","isArray","_isSwipeContentReady","wasPlaying","_executeSoftReset","errorMessage","lastMsgList","recentMessages","foundTarget","newContent","$","CHAT_CHANGED","reloadIframe","observerInterval","on"],"ignoreList":[],"sourceRoot":""}