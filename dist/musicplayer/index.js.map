{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/musicplayer/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","console.log('音乐播放器脚本9.4.6版本');\n\n// =================================================================\n// 0. 诊断工具 (Diagnostic Tools)\n// =================================================================\nimport { z, ZodError } from 'zod';\ndeclare global {\n  interface Window {\n    musicPlayerAPI: any;\n  }\n}\nconst SCRIPT_LOAD_TIME = performance.now();\n\nfunction logProbe(message: string, type: 'log' | 'warn' | 'error' | 'group' | 'groupCollapsed' | 'groupEnd' = 'log') {\n  const timestamp = `(T+${(performance.now() - SCRIPT_LOAD_TIME).toFixed(0)}ms)`;\n  const finalMessage = `${timestamp} ${message}`;\n\n  switch (type) {\n    case 'warn':\n      console.warn(finalMessage);\n      break;\n    case 'error':\n      console.error(finalMessage);\n      break;\n    case 'group':\n      console.group(finalMessage);\n      break;\n    case 'groupCollapsed':\n      console.groupCollapsed(finalMessage);\n      break;\n    case 'groupEnd':\n      console.groupEnd();\n      break;\n    default:\n      console.log(finalMessage);\n  }\n}\n\n// =================================================================\n// 1. 类型定义 (Type Definitions)\n// =================================================================\n\ntype PlaylistItem = {\n  url: string;\n  歌名: string;\n  歌手?: string;\n  封面?: string;\n};\n\ntype PlaylistConfig = {\n  id: string;\n  tracks: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n};\n\ntype QueueItem = {\n  // --- 核心标识与排序依据 ---\n  playlistId: string;\n  priority: number;\n\n  // --- 内容与规则 ---\n  playlistContent: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n\n  // --- 状态记忆 ---\n  currentIndex: number;\n  playedIndices: Set<number>;\n  playbackPlan?: number[];\n  planIndex?: number;\n  wasEverPlayed: boolean;\n\n  // --- 溯源信息 ---\n  triggeredBy: 'base' | 'mvu';\n  triggerSource?: z.infer<typeof ZodTriggerConfig>;\n};\n\ntype PlaybackMode = 'list' | 'single' | 'random';\n\ntype FullStatePayload = {\n  currentItem: { title: string; artist?: string; cover?: string } | null;\n  isPlaying: boolean;\n  playbackState: 'STOPPED' | 'PLAYING' | 'PAUSED';\n  playbackMode: PlaybackMode;\n  masterVolume: number;\n  playlist: { title: string; artist?: string; cover?: string }[];\n  isTransitioning: boolean;\n};\n\ntype TimeUpdatePayload = {\n  currentTime: number;\n  duration: number;\n};\n\ntype StrategyDecision = {\n  action: 'GoTo' | 'RemoveTopAndAdvance' | 'Restart' | 'DoNothing' | 'LoopReset' | 'Stop';\n  nextIndex?: number;\n};\n\ninterface IPlaybackStrategy {\n  onQueueChanged(currentItem: QueueItem | undefined): void;\n  advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision;\n  onTrackEnd(currentItem: QueueItem): StrategyDecision;\n  onPlaybackError(currentItem: QueueItem): StrategyDecision;\n}\n\n// =================================================================\n// 1.1. Zod 边界防御 Schemas (Zod Border Defense Schemas)\n// -----------------------------------------------------------------\n// 探针: 这些 schemas 不仅仅是类型，它们是主动的验证器，是我们系统的第一道防线。\n//       每一个 `required_error` 和 `message` 都是一个内置的探针，当外部数据\n//       不符合我们的“法律”时，它们会自动报告错误。\n// 原则: 单一事实来源 (SSoT) - 关于外部数据应该长什么样的“真相”，只由这里定义。\n// =================================================================\n\n// 世界书音轨配置 Schema\nexport const ZodTrackConfig = z\n  .object({\n    歌名: z.string().optional(),\n    歌手: z.string().optional(),\n    封面: z.string().url({ message: '封面URL格式无效' }).optional(),\n    url: z.string().url({ message: '音轨URL格式无效' }),\n  })\n  .strict();\n\n// 定义一个“单一条件”\nexport const ZodSingleCondition = z\n  .object({\n    variable_path: z.string(),\n    greater_than: z.number().optional(),\n    greater_than_or_equal_to: z.number().optional(),\n    less_than: z.number().optional(),\n    less_than_or_equal_to: z.number().optional(),\n    value: z.union([z.string(), z.number(), z.boolean()]).optional(),\n    value_contains: z.string().optional(),\n    time_in_range: z\n      .string()\n      .regex(/^\\d{2}:\\d{2}-\\d{2}:\\d{2}$/, {\n        message: '时间范围格式必须是 \"HH:MM-HH:MM\"',\n      })\n      .optional(),\n  })\n  .strict();\n\n// 主触发器 Schema 引用“单一条件”的数组\nexport const ZodTriggerConfig = z\n  .object({\n    type: z.literal('mvu_variable'),\n    playlist_id: z.string(),\n    priority: z.number().default(0),\n    conditions: z.array(ZodSingleCondition).nonempty({ message: '触发器必须至少包含一个条件' }),\n  })\n  .strict();\n\n// 世界书歌单配置 Schema\nexport const ZodPlaylistConfig = z.object({\n  id: z.string(),\n  onFinishRule: z.enum(['loop', 'pop'], { message: \"onFinishRule 必须是 'loop' 或 'pop'\" }).default('loop'),\n  tracks: z.array(ZodTrackConfig).nonempty({ message: \"歌单的 'tracks' 列表不能为空\" }),\n});\n\n// 世界书总配置 Schema (这是我们将使用的顶级验证器)\nexport const ZodWorldbookConfig = z\n  .object({\n    default_playlist_id: z.string().optional(),\n    playlists: z.array(ZodPlaylistConfig).optional(),\n    triggers: z.array(ZodTriggerConfig).optional(),\n    is_mvu: z.boolean().optional(),\n  })\n  .strict();\n\n// 持久化状态 - 队列项 Schema\nexport const ZodQueueItemState = z.object({\n  playlistId: z.string(),\n  currentIndex: z.number().default(0),\n  playedIndices: z.array(z.number()).default([]),\n  wasEverPlayed: z.boolean().default(false),\n  triggerSource: ZodTriggerConfig.optional(),\n});\n\n// 持久化状态 - 总 Schema\nexport const ZodPersistedState = z.object({\n  active_queue: z.array(ZodQueueItemState),\n  mode: z.enum(['list', 'single', 'random']).default('list'),\n  volume: z.number().min(0).max(1).default(0.5),\n  last_active_swipe_id: z.number().nullable().default(null),\n  finished_base_playlists: z.array(z.string()).default([]),\n  previousMvuState: z.record(z.string(), z.any()).optional(),\n});\n\nconst STATE_KEY_MVU_HISTORY = '灰烬双星_MVU状态记忆';\n\n/**\n * [工具函数] 将多种格式的时间字符串解析为从午夜开始的分钟数。\n * 它的职责单一，且对输入格式有很强的容错能力。\n * @param timeStr - 例如 \"14:30\", \"8时5分\", \"22 : 00\"\n * @returns {number | null} 转换后的分钟数，或在无法解析时返回 null。\n */\nfunction _parseTimeToMinutes(timeStr: string): number | null {\n  // 探针: 记录传入的原始值，便于调试\n  if (!timeStr || typeof timeStr !== 'string') return null;\n\n  // 步骤1: 归一化输入，处理常见变体 (已修正 let -> const 和 replace 语法)\n  const cleanStr: string = timeStr.trim().replace('：', ':');\n\n  let match;\n\n  // 步骤2: 尝试匹配 \"HH:MM\" 格式 (最常见)\n  match = cleanStr.match(/^(\\d{1,2})\\s*:\\s*(\\d{1,2})$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    // 严格校验数值范围\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 步骤3: 尝试匹配 \"H时M分\" 格式\n  match = cleanStr.match(/^(\\d{1,2})\\s*时\\s*(\\d{1,2})\\s*分?$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 探针: 如果所有格式都匹配失败，记录下来\n  logProbe(`[TimeParser] 无法解析时间字符串: \"${timeStr}\"`, 'warn');\n\n  // [新增] 修复“缺少 return”的逻辑漏洞\n  return null;\n}\n\n// =================================================================\n// 2. MVU 管理器 (The MvuManager - \"The Analyst\")\n// =================================================================\nconst MvuManager = (() => {\n  logProbe('[MvuManager] 模块正在初始化...');\n\n  let _previousMvuState: Record<string, any> = {};\n\n  /**\n   * [核心算法 V2.1] 检查一个给定的 stat_data 是否满足一个触发器的所有条件。\n   * 新版已加固，支持多种匹配模式和 AND 条件组合，且代码风格已优化。\n   */\n  function _checkTriggerCondition(\n    trigger: z.infer<typeof ZodTriggerConfig>,\n    statData: Record<string, any> | null,\n  ): boolean {\n    if (!statData) return false;\n\n    // 遍历所有 AND 条件。只要有一个不满足，整个触发器就失败。\n    for (const condition of trigger.conditions) {\n      const currentValue = _.get(statData, condition.variable_path);\n\n      let conditionMet = false; // 当前条件是否满足\n      let isHandled = false; // 当前条件是否被任何一个匹配模式处理过\n\n      // 使用 if / else if 链条，确保每个条件项只采用一种匹配模式\n      if (condition.value_contains !== undefined) {\n        isHandled = true;\n        // [安全加固] 必须检查 currentValue 是字符串，否则 .includes() 会导致崩溃\n        if (typeof currentValue === 'string' && currentValue.includes(condition.value_contains)) {\n          conditionMet = true;\n        }\n      } else if (condition.time_in_range !== undefined) {\n        isHandled = true;\n        // [安全加固] 同样检查类型\n        if (typeof currentValue === 'string') {\n          const currentTimeInMinutes = _parseTimeToMinutes(currentValue);\n\n          if (currentTimeInMinutes !== null) {\n            const [startStr, endStr] = condition.time_in_range.split('-');\n            const startMinutes = _parseTimeToMinutes(startStr);\n            const endMinutes = _parseTimeToMinutes(endStr);\n\n            if (startMinutes !== null && endMinutes !== null) {\n              if (startMinutes <= endMinutes) {\n                // 普通范围\n                conditionMet = currentTimeInMinutes >= startMinutes && currentTimeInMinutes < endMinutes;\n              } else {\n                // 跨天范围\n                conditionMet = currentTimeInMinutes >= startMinutes || currentTimeInMinutes < endMinutes;\n              }\n            }\n          }\n        }\n      } else if (condition.value !== undefined) {\n        isHandled = true;\n        if (currentValue === condition.value) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue > condition.greater_than) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue >= condition.greater_than_or_equal_to) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue < condition.less_than) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue <= condition.less_than_or_equal_to) {\n          conditionMet = true;\n        }\n      }\n\n      // [最终裁决] 如果这是一个空条件 (isHandled=false)，或条件不满足，则立即失败\n      if (!isHandled || !conditionMet) {\n        return false;\n      }\n    }\n\n    // 如果循环正常结束，说明所有 AND 条件都满足\n    return true;\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    checkTriggerCondition: _checkTriggerCondition,\n\n    /**\n     * [生命周期] 从酒馆变量中读取并恢复上一次的 MVU 状态。\n     */\n    initialize() {\n      logProbe('[MvuManager] (Lifecycle) 执行 initialize...');\n      try {\n        const savedState = getVariables({ type: 'chat' })[STATE_KEY_MVU_HISTORY];\n        if (savedState && typeof savedState === 'object') {\n          _previousMvuState = savedState;\n          logProbe('[MvuManager] 成功从存档中恢复了 MVU 历史状态。');\n        } else {\n          _previousMvuState = {};\n          logProbe('[MvuManager] 未发现有效的 MVU 历史存档，已初始化为空状态。', 'warn');\n        }\n      } catch (error) {\n        logProbe(`[MvuManager] 初始化时读取存档失败: ${error}`, 'error');\n        _previousMvuState = {};\n      }\n    },\n\n    resetState() {\n      logProbe('[MvuManager] (Lifecycle) 正在重置模块内部状态...');\n      _previousMvuState = {};\n      logProbe('[MvuManager] 模块状态已重置。');\n    },\n\n    /**\n     * [命令] 将当前的 MVU 状态持久化到酒馆变量中。\n     * @param currentStateData - 最新的 stat_data 对象。\n     */\n    async persistCurrentState(currentStateData: Record<string, any>) {\n      if (!isScriptActive) {\n        logProbe('[MvuManager] 持久化操作被阻止，因为脚本正在停机。', 'warn');\n        return;\n      }\n      logProbe('[MvuManager] (Command) 执行 persistCurrentState...');\n      _previousMvuState = _.cloneDeep(currentStateData);\n      try {\n        await updateVariablesWith(\n          vars => {\n            vars[STATE_KEY_MVU_HISTORY] = _previousMvuState;\n            return vars;\n          },\n          { type: 'chat' },\n        );\n        logProbe('[MvuManager] 已成功将当前 MVU 状态持久化。');\n      } catch (error) {\n        logProbe(`[MvuManager] 持久化 MVU 状态时发生严重错误: ${error}`, 'error');\n      }\n    },\n\n    /**\n     * [查询] 获取内存中存储的上一次的 MVU 状态。\n     */\n    getPreviousState: () => _.cloneDeep(_previousMvuState),\n\n    /**\n     * [核心查询] 计算新旧状态之间的“边沿变化”。\n     * @param previousStateData - 上一次的 stat_data。\n     * @param currentStateData - 最新的 stat_data。\n     * @param allTriggers - 从世界书解析出的所有有效触发器。\n     * @returns 报告对象，包含新激活和新失效的触发器列表。\n     */\n    calculateChangeReport(\n      previousStateData: Record<string, any>,\n      currentStateData: Record<string, any>,\n      allTriggers: z.infer<typeof ZodTriggerConfig>[],\n    ): {\n      newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n    } {\n      const report: {\n        newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n        newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      } = { newlyActiveTriggers: [], newlyInactiveTriggers: [] };\n\n      logProbe('[MvuManager] (Query) 正在计算状态变化报告 (\"边沿检测\")...', 'group');\n\n      logProbe('[Probe] 正在审查用于对比的新旧状态数据:');\n      console.log('上一份历史记忆 (previousStateData):');\n      console.dir(_.cloneDeep(previousStateData));\n      console.log('当前权威状态 (currentStateData):');\n      console.dir(_.cloneDeep(currentStateData));\n      // =======================================================\n\n      for (const trigger of allTriggers) {\n        const wasMet = _checkTriggerCondition(trigger, previousStateData);\n        const isMet = _checkTriggerCondition(trigger, currentStateData);\n\n        if (!wasMet && isMet) {\n          logProbe(`(探針) 新激活的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyActiveTriggers.push(trigger);\n        } else if (wasMet && !isMet) {\n          logProbe(`(探針) 新失效的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyInactiveTriggers.push(trigger);\n        }\n      }\n      logProbe(\n        `报告生成完毕: ${report.newlyActiveTriggers.length} 个新激活, ${report.newlyInactiveTriggers.length} 个新失效。`,\n      );\n      logProbe('', 'groupEnd');\n      return report;\n    },\n  };\n\n  logProbe('[MvuManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.X. 文本标签管理器 (The TextTagManager - \"The Bard\")\n// =================================================================\n/**\n * 职责 (SRP): 仅负责从历史文本中解析 <scene:xxx> 标签，将其转化为标准化的状态对象。\n * 它不负责播放，不负责决策，只负责“阅读”和“翻译”。\n */\nconst TextTagManager = (() => {\n  logProbe('[TextTagManager] 模块正在初始化 (吟游诗人引擎)...');\n\n  // 正则表达式：匹配 <scene: id >，允许冒号后有空格，捕获 id 部分\n  // 使用 'g' 标志以便我们在同一条消息中查找最后一个匹配项\n  const SCENE_TAG_REGEX = /<scene:\\s*([^>]+)\\s*>/g;\n\n  /**\n   * [核心算法] 滑动窗口回溯扫描。\n   * 性能: O(1) - 无论聊天记录多长，最多只拉取最近 20 条。\n   */\n  async function _getLatestState(): Promise<{ tags: Record<string, any>; foundAtMessageId: number }> {\n    logProbe('[TextTagManager] (Query) 开始执行文本回溯扫描...', 'groupCollapsed');\n\n    try {\n      // 1. 确定锚点\n      const latestMsgs = getChatMessages(-1);\n      if (!latestMsgs || latestMsgs.length === 0) {\n        logProbe('[TextTagManager] 无法获取最新消息锚点，返回空状态。', 'warn');\n        logProbe('', 'groupEnd');\n        //返回统一结构\n        return { tags: { 'virtual.music_tag': null }, foundAtMessageId: -1 };\n      }\n\n      const lastId = latestMsgs[0].message_id;\n\n      // 2. 计算窗口 (最近 20 条)\n      const startId = Math.max(0, lastId - 19);\n      const rangeString = `${startId}-${lastId}`;\n      logProbe(`(探针) 扫描窗口确定: ${rangeString} (锚点ID: ${lastId})`);\n\n      // 3. 获取切片\n      const msgs = getChatMessages(rangeString);\n\n      // 4. 倒序遍历\n      for (let i = msgs.length - 1; i >= 0; i--) {\n        const msg = msgs[i];\n\n        // [过滤] 严格忽略用户消息\n        if (msg.role === 'user') {\n          continue;\n        }\n\n        // [解析] 在当前消息中寻找标签\n        // 逻辑: \"Last Match Wins\" (同一条消息里如果有多个标签，取最后一个)\n        const allMatches = [...msg.message.matchAll(SCENE_TAG_REGEX)];\n\n        if (allMatches.length > 0) {\n          // 取最后一个匹配项\n          const lastMatch = allMatches[allMatches.length - 1];\n          const rawId = lastMatch[1].trim();\n\n          // [归一化] 强制转小写，以匹配隐式生成的触发器\n          // 如果 ID 是 \"null\" (不分大小写)，则视为明确的“停止/空”指令\n          if (rawId.toLowerCase() === 'null') {\n            logProbe(`[TextTagManager] 在 message_id: ${msg.message_id} 找到明确的空指令 <scene:null>。`);\n            logProbe('', 'groupEnd');\n            return { tags: { 'virtual.music_tag': null }, foundAtMessageId: msg.message_id };\n          }\n\n          const normalizedId = rawId.toLowerCase();\n          logProbe(\n            `[TextTagManager] 命中! 在 message_id: ${msg.message_id} 找到标签: \"${rawId}\" -> 归一化: \"${normalizedId}\"`,\n          );\n          logProbe('', 'groupEnd');\n          return { tags: { 'virtual.music_tag': normalizedId }, foundAtMessageId: msg.message_id };\n        }\n\n        // [规则] 遇到第一条 AI 消息，即使没有标签，也必须停止扫描。\n        // \"无标签即停止\"原则：这意味着场景歌单的生命周期仅维持在有标签的那一楼。\n        // 这种设计避免了为了找一个标签而无限回溯历史。\n        logProbe(\n          `[TextTagManager] 在 message_id: ${msg.message_id} (AI) 中未发现标签。根据“无标签即空”原则，扫描结束。`,\n        );\n        logProbe('', 'groupEnd');\n        //虽然没标签，但也算是在这楼“确认了没有”，所以返回 -1 或当前ID均可，这里返回 -1 表示没有命中有效标签\n        return { tags: { 'virtual.music_tag': null }, foundAtMessageId: -1 };\n      }\n\n      // 5. 兜底\n      logProbe('[TextTagManager] 扫描完窗口内所有消息，未发现有效 AI 消息。返回空状态。');\n      logProbe('', 'groupEnd');\n      return { tags: { 'virtual.music_tag': null }, foundAtMessageId: -1 };\n    } catch (error) {\n      logProbe(`[TextTagManager] 扫描过程中发生错误: ${error}`, 'error');\n      logProbe('', 'groupEnd');\n      return { tags: { 'virtual.music_tag': null }, foundAtMessageId: -1 };\n    }\n  }\n\n  const publicAPI = {\n    getLatestState: _getLatestState,\n  };\n\n  logProbe('[TextTagManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2. 状态管理器 (The State Manager) - [V2.0 重构版]\n// =================================================================\nconst StateManager = (() => {\n  logProbe('[StateManager] 模块正在初始化 (优先级队列内核)...');\n\n  // -------------------\n  // 2.1. 私有状态 (Private State)\n  // -------------------\n  // [重构] 核心数据结构变更为优先级队列\n  let _activePlaylistQueue: QueueItem[] = [];\n  let _lastActiveSwipeId: number | null = null;\n  let _finishedBasePlaylists: Set<string> = new Set();\n  let _playbackMode: PlaybackMode = 'list';\n  let _masterVolume: number = 0.5;\n  let _playbackState: 'STOPPED' | 'PLAYING' | 'PAUSED' = 'STOPPED';\n  let _isPerformingEffect: boolean = false;\n\n  // -------------------\n  // 2.2. 私有核心算法 (Private Core Algorithms)\n  // -------------------\n  function _applyDepartureIsHistoryPrinciple(item: QueueItem, departingIndex: number) {\n    if (typeof departingIndex !== 'number' || departingIndex < 0) return;\n    item.playedIndices.add(departingIndex);\n  }\n\n  // -------------------\n  // 2.3. 公共接口 (Public API)\n  // -------------------\n  const publicAPI = {\n    // --- 基础状态查询 ---\n    getPlaybackMode: () => _playbackMode,\n    getVolume: () => _masterVolume,\n    // [兼容性] 旧接口，仅当状态明确为 PLAYING 时返回 true\n    isPlaying: () => _playbackState === 'PLAYING',\n    getPlaybackState: () => _playbackState,\n    isPerformingEffect: () => _isPerformingEffect,\n\n    // --- [重构] 队列核心查询 ---\n    /**\n     * 获取当前优先级最高的歌单项（队首）。\n     * 这是系统唯一的事实来源：当前应该播放什么。\n     */\n    getTopQueueItem: (): QueueItem | undefined => _.cloneDeep(_activePlaylistQueue[0]),\n\n    /**\n     * 获取整个队列的副本（用于调试或决策分析）。\n     */\n    getQueue: (): QueueItem[] => _.cloneDeep(_activePlaylistQueue),\n\n    // --- 状态快照 ---\n    getStateSnapshotForRuntime: () => {\n      return _.cloneDeep({\n        active_queue: _activePlaylistQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        // [兼容性] 同时提供布尔值和枚举值\n        isPlaying: _playbackState === 'PLAYING',\n        playbackState: _playbackState,\n        isPerformingEffect: _isPerformingEffect,\n      });\n    },\n\n    getStateSnapshotForPersistence() {\n      const runtimeQueue = _.cloneDeep(_activePlaylistQueue);\n\n      const persistentQueue = runtimeQueue.map(item => {\n        const persistedItem = _.omit(item, ['playbackPlan', 'planIndex', 'playlistContent']);\n\n        return {\n          ...persistedItem,\n          // 将 Set 转换为 Array 以便 JSON 序列化\n          playedIndices: Array.from(item.playedIndices),\n        };\n      });\n\n      return {\n        active_queue: persistentQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        last_active_swipe_id: _lastActiveSwipeId,\n        finished_base_playlists: Array.from(_finishedBasePlaylists),\n      };\n    },\n\n    // --- 生命周期管理 ---\n    resetState() {\n      logProbe('[StateManager] 正在硬性重置所有状态...', 'warn');\n      _activePlaylistQueue = [];\n      _playbackMode = 'list';\n      _masterVolume = 0.5;\n      _playbackState = 'STOPPED';\n      _isPerformingEffect = false;\n      _lastActiveSwipeId = null;\n      _finishedBasePlaylists.clear();\n    },\n\n    loadState(stateToLoad: any) {\n      logProbe('[StateManager] 正在加载状态...', 'group');\n      _playbackMode = stateToLoad.mode;\n      _masterVolume = stateToLoad.volume;\n      _activePlaylistQueue = stateToLoad.active_queue || [];\n      _lastActiveSwipeId = stateToLoad.last_active_swipe_id ?? null;\n      _finishedBasePlaylists = new Set(stateToLoad.finished_base_playlists || []);\n      logProbe(\n        `(探针) 记忆加载完成: 上次SwipeID=${_lastActiveSwipeId}, 已完结基础歌单数=${_finishedBasePlaylists.size}`,\n      );\n      logProbe(\n        `状态加载完成. 队列深度: ${_activePlaylistQueue.length}, 模式: ${_playbackMode}, 音量: ${_masterVolume}`,\n      );\n      logProbe('', 'groupEnd');\n    },\n\n    // --- 基础状态设置 ---\n    setPlaybackMode: (mode: PlaybackMode) => {\n      _playbackMode = mode;\n    },\n    setVolume: (volume: number) => {\n      _masterVolume = volume;\n    },\n    setPlaybackState: (newState: 'STOPPED' | 'PLAYING' | 'PAUSED') => {\n      // [探针] 状态变更日志，帮助我们追踪每一次状态跳变\n      if (_playbackState !== newState) {\n        logProbe(`[StateManager] 状态流转: ${_playbackState} -> ${newState}`);\n      }\n      _playbackState = newState;\n    },\n    setPerformingEffect: (isPerforming: boolean) => {\n      _isPerformingEffect = isPerforming;\n    },\n\n    getLastActiveSwipeId: () => _lastActiveSwipeId,\n    setLastActiveSwipeId: (id: number | null) => {\n      _lastActiveSwipeId = id;\n    },\n\n    getFinishedBasePlaylists: () => new Set(_finishedBasePlaylists),\n\n    addToFinishedBasePlaylists: (playlistId: string) => {\n      logProbe(`[StateManager]将基础歌单 \"${playlistId}\" 刻入已完成列表。`);\n      _finishedBasePlaylists.add(playlistId);\n    },\n\n    clearFinishedBasePlaylists: () => {\n      logProbe(`[StateManager]清空记录。`);\n      _finishedBasePlaylists.clear();\n    },\n\n    // --- [重构] 队列核心操作 ---\n    /**\n     * [核心] 更新整个队列。\n     * 此方法会自动按优先级降序排列队列，确保 _activePlaylistQueue[0] 永远是优先级最高的。\n     */\n    updateQueue(newQueue: QueueItem[]) {\n      logProbe(`[StateManager] (Command) updateQueue: 正在更新并重排序队列 (共 ${newQueue.length} 项)...`);\n\n      _activePlaylistQueue = _.cloneDeep(newQueue).sort((a, b) => b.priority - a.priority);\n\n      if (_activePlaylistQueue.length > 0) {\n        logProbe(\n          `(探针) 新队首: \"${_activePlaylistQueue[0].playlistId}\" (优先级: ${_activePlaylistQueue[0].priority})`,\n        );\n      } else {\n        logProbe(`(探针) 队列现已为空。`);\n      }\n    },\n\n    // --- 当前项操作 (作用于队首) ---\n    setCurrentIndex(index: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n        currentItem.currentIndex = index;\n      }\n    },\n\n    commitNavigationStep(newTrackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n\n      if (_playbackMode === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(newTrackIndex);\n        if (newPlanIndex !== -1) {\n          currentItem.planIndex = newPlanIndex;\n        }\n      }\n      currentItem.currentIndex = newTrackIndex;\n    },\n\n    clearHistoryForCurrentItem() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) currentItem.playedIndices.clear();\n    },\n\n    resetCurrentItemForLoop() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playedIndices.clear();\n        currentItem.currentIndex = 0;\n      }\n    },\n\n    commitGenesisState(newCurrentIndex: number, newPlaybackPlan: number[], newPlanIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.currentIndex = newCurrentIndex;\n        currentItem.playbackPlan = newPlaybackPlan;\n        currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    userInitiatedJump(trackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem || trackIndex === currentItem.currentIndex) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n      currentItem.currentIndex = trackIndex;\n\n      if (this.getPlaybackMode() === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(trackIndex);\n        if (newPlanIndex !== -1) currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    clearRandomModePlan() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = undefined;\n        currentItem.planIndex = undefined;\n      }\n    },\n\n    applyNewPlaybackPlan(plan: number[], planIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = plan;\n        currentItem.planIndex = planIndex;\n      }\n    },\n  };\n\n  logProbe('[StateManager] 模块初始化完成 (V2.0 内核)。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.1. 播放引擎 (The Playback Engine)\n// =================================================================\nconst PlaybackEngine = (() => {\n  logProbe('[PlaybackEngine] 模块正在初始化...');\n  let _playerA: HTMLAudioElement | null = null;\n  let _playerB: HTMLAudioElement | null = null;\n  let _activePlayer: HTMLAudioElement | null = null;\n  let _standbyPlayer: HTMLAudioElement | null = null;\n  let _fadeInterval: number | null = null;\n  const FADE_DURATION = 400;\n\n  // --- 私有函数 ---\n  function _swapPlayers() {\n    [_activePlayer, _standbyPlayer] = [_standbyPlayer, _activePlayer];\n  }\n\n  function _fadeVolumeAsync(player: HTMLAudioElement | null, targetVolume: number, duration: number): Promise<void> {\n    return new Promise(resolve => {\n      if (_fadeInterval) {\n        clearInterval(_fadeInterval);\n        _fadeInterval = null;\n      }\n\n      if (!player) return resolve();\n\n      const startVolume = player.volume;\n      const stepTime = 50;\n      const steps = duration / stepTime;\n      if (steps <= 0) {\n        player.volume = targetVolume;\n        return resolve();\n      }\n      const volumeStep = (targetVolume - startVolume) / steps;\n      let currentStep = 0;\n\n      _fadeInterval = window.setInterval(() => {\n        currentStep++;\n        if (currentStep >= steps) {\n          if (_fadeInterval) clearInterval(_fadeInterval);\n          _fadeInterval = null;\n          player.volume = targetVolume;\n          resolve();\n        } else {\n          player.volume += volumeStep;\n        }\n      }, stepTime);\n    });\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    initialize() {\n      if (_playerA && _playerB) return;\n      logProbe('[Engine] 正在创建和配置 HTML5 Audio 元素...');\n      const createPlayer = (): HTMLAudioElement => {\n        const audio = new Audio();\n        audio.preload = 'auto';\n        audio.crossOrigin = 'anonymous';\n        audio.addEventListener('ended', () => {\n          if (audio === _activePlayer) void _handleTrackEnded();\n        });\n        audio.addEventListener('error', () => {\n          /* 错误由 Promise reject 处理 */\n        });\n        audio.addEventListener('timeupdate', broadcastTimeUpdate);\n        return audio;\n      };\n      _playerA = createPlayer();\n      _playerB = createPlayer();\n      _activePlayer = _playerA;\n      _standbyPlayer = _playerB;\n      logProbe('[Engine] Audio 元素已就绪。');\n    },\n\n    getActivePlayer: () => _activePlayer,\n    getStandbyPlayer: () => _standbyPlayer,\n\n    async transitionToTrack(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine] 收到过渡请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n\n      if (!_standbyPlayer || !_activePlayer) {\n        logProbe('[Engine] 过渡中止：播放器实例尚未初始化。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('播放器实例尚未初始化');\n      }\n\n      const standbyPlayer = _standbyPlayer;\n      const activePlayer = _activePlayer;\n\n      standbyPlayer.src = targetTrackUrl;\n      standbyPlayer.load();\n\n      try {\n        await new Promise<void>((resolve, reject) => {\n          const onCanPlay = () => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe('[Engine] 备用播放器加载成功 (canplaythrough)。', 'log');\n            resolve();\n          };\n\n          const onError = (e: Event) => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe(`[Engine] 备用播放器加载失败!`, 'error');\n            const target = e.target as HTMLAudioElement;\n            const error = target.error;\n            reject(new Error(`音频加载失败: ${error?.message || '未知错误'}`));\n          };\n          standbyPlayer.addEventListener('canplaythrough', onCanPlay);\n          standbyPlayer.addEventListener('error', onError);\n        });\n      } catch (error) {\n        logProbe('[Engine] 过渡因加载失败而中止。', 'groupEnd');\n        throw error;\n      }\n\n      await _fadeVolumeAsync(activePlayer, 0, 500);\n      activePlayer.pause();\n\n      _swapPlayers();\n\n      const newActivePlayer = this.getActivePlayer();\n      if (!newActivePlayer) throw new Error('播放器实例在交换后丢失');\n\n      const playPromise = newActivePlayer.play();\n      if (playPromise) {\n        await playPromise;\n      }\n      await _fadeVolumeAsync(newActivePlayer, targetVolume, 500);\n\n      logProbe('[Engine] 过渡成功完成。', 'groupEnd');\n    },\n\n    async fadeOutAndPause(): Promise<void> {\n      logProbe('[Engine] 命令: FadeOutAndPause');\n      await _fadeVolumeAsync(_activePlayer, 0, FADE_DURATION);\n      _activePlayer?.pause();\n    },\n\n    async executeHardCut(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine:HardCut] 收到“瞬击”请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n      const activePlayer = this.getActivePlayer();\n      if (!activePlayer) {\n        logProbe('[Engine:HardCut] 致命错误：无可用播放器实例。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('No active player available for hard cut.');\n      }\n\n      logProbe(`(探针) 切换前 src: ${activePlayer.src.slice(-50)}`);\n\n      activePlayer.pause();\n      activePlayer.src = targetTrackUrl;\n      activePlayer.volume = targetVolume;\n\n      logProbe(`(探针) 切换后 src: ${activePlayer.src.slice(-50)}`);\n\n      try {\n        const playPromise = activePlayer.play();\n        if (playPromise) {\n          await playPromise;\n        }\n\n        StateManager.setPlaybackState('PLAYING');\n        logProbe('[Engine:HardCut] “瞬击”播放成功。');\n      } catch (error) {\n        logProbe(`[Engine:HardCut] “瞬击”播放失败! 这通常是因为用户未与页面交互。`, 'error');\n\n        StateManager.setPlaybackState('STOPPED');\n\n        throw error;\n      } finally {\n        logProbe('', 'groupEnd');\n      }\n    },\n\n    async resumeAndFadeIn(targetVolume: number): Promise<void> {\n      logProbe('[Engine] 命令: ResumeAndFadeIn');\n      const playPromise = _activePlayer?.play();\n      if (playPromise) await playPromise;\n      await _fadeVolumeAsync(_activePlayer, targetVolume, FADE_DURATION);\n    },\n  };\n\n  logProbe('[PlaybackEngine] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.2. 播放策略实现 (Playback Strategies)\n// =================================================================\n\nclass ListStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 advance 请求. 方向: ${direction}, 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    if (direction === 'next') {\n      logProbe('[Strategy:List] 决策: advance(next) -> 委托给 onTrackEnd');\n      return this.onTrackEnd(currentItem);\n    }\n\n    const { currentIndex, onFinishRule, playlistContent } = currentItem;\n    const totalTracks = playlistContent.length;\n\n    if (currentIndex > 0) {\n      const nextIndex = currentIndex - 1;\n      logProbe(`[Strategy:List] 决策: advance(prev) -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'loop') {\n      const lastIndex = totalTracks > 0 ? totalTracks - 1 : 0;\n      logProbe(`[Strategy:List] 决策: advance(prev) at start -> Loop to end (index: ${lastIndex})`);\n      return { action: 'GoTo', nextIndex: lastIndex };\n    } else {\n      logProbe('[Strategy:List] 决策: advance(prev) at start -> Restart');\n      return { action: 'Restart' };\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 onTrackEnd 请求. 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    const { currentIndex, onFinishRule, playlistContent, playedIndices } = currentItem;\n    const totalTracks = playlistContent.length;\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex < totalTracks) {\n      logProbe(`[Strategy:List] 决策: onTrackEnd -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'pop') {\n      logProbe('[Strategy:List] 决策: onTrackEnd at end -> PopStack');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      const totalValidTracks = playlistContent.length;\n      const historySizeAfterThisTrack = playedIndices.size + 1;\n\n      if (historySizeAfterThisTrack >= totalValidTracks) {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> LoopReset (一个完整的循环已结束)`, 'warn');\n        return { action: 'LoopReset' };\n      } else {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> GoTo (普通循环，继续播放未听过的歌曲)`);\n        return { action: 'GoTo', nextIndex: 0 };\n      }\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:List] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\nclass SingleStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(_currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 advance 请求. 方向: ${direction}. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onTrackEnd(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onTrackEnd 请求. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onPlaybackError(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onPlaybackError 请求。决策: Stop (单曲循环下无法自动前进)`);\n    return { action: 'Stop' };\n  }\n}\n\nclass RandomStrategy implements IPlaybackStrategy {\n  private _generateIntelligentShuffle(\n    allTrackIndices: number[],\n    playedIndices: Set<number>,\n    currentIndex: number,\n  ): number[] {\n    logProbe(`[Strategy:Random] (Algo) _generateIntelligentShuffle 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: allIndices.length=${allTrackIndices.length}, playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}`,\n    );\n\n    const sourceForShuffle = allTrackIndices.filter(i => !playedIndices.has(i) && i !== currentIndex);\n    logProbe(`计算待选池 (sourceForShuffle) 大小: ${sourceForShuffle.length}`);\n\n    for (let i = sourceForShuffle.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [sourceForShuffle[i], sourceForShuffle[j]] = [sourceForShuffle[j], sourceForShuffle[i]];\n    }\n\n    logProbe(`洗牌完成. 输出 shuffledIndices (纯粹的未来队列): [${sourceForShuffle.join(', ')}]`);\n    logProbe('', 'groupEnd');\n    return sourceForShuffle;\n  }\n\n  private _generatePlaybackPlan(\n    playedIndices: Set<number>,\n    currentIndex: number,\n    shuffledIndices: number[],\n  ): { playbackPlan: number[]; planIndex: number } {\n    logProbe(`[Strategy:Random] (Algo) _generatePlaybackPlan 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}, shuffledIndices.length=${shuffledIndices.length}`,\n    );\n\n    const knownSequence = Array.from(new Set([...playedIndices, currentIndex]));\n    const planIndex = knownSequence.indexOf(currentIndex);\n    const playbackPlan = [...knownSequence, ...shuffledIndices];\n\n    logProbe(`(守护者探针) \"已知序列\" (unique history + current): [${knownSequence.join(', ')}]`);\n    logProbe(`生成导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n    logProbe(`定位导航指针 (planIndex): ${planIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { playbackPlan, planIndex };\n  }\n\n  private _handlePlanEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] (Helper) _handlePlanEnd: 已到达计划终点，开始进行边界决策...`, 'groupCollapsed');\n    logProbe(`(探针) 待决策歌单: \"${currentItem.playlistId}\", 结束规则: \"${currentItem.onFinishRule}\"`);\n\n    if (currentItem.onFinishRule === 'pop') {\n      logProbe(`(边界决策) onFinishRule 为 'pop'，决策 -> PopStack`);\n      logProbe('', 'groupEnd');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      logProbe(`(边界决策) onFinishRule 为 'loop'，决策 -> LoopReset`);\n      logProbe('', 'groupEnd');\n      return { action: 'LoopReset' };\n    }\n  }\n\n  public onQueueChanged(currentItem: QueueItem | undefined): void {\n    if (!currentItem) {\n      logProbe('[Strategy:Random] onQueueChanged 中止：无有效的当前项。');\n      return;\n    }\n\n    logProbe(\n      `[Strategy:Random] onQueueChanged 已触发 (连续性恢复)，将为歌单 \"${currentItem.playlistId}\" 生成播放计划...`,\n    );\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    const shuffled = this._generateIntelligentShuffle(allIndices, currentItem.playedIndices, currentItem.currentIndex);\n    const { playbackPlan, planIndex } = this._generatePlaybackPlan(\n      currentItem.playedIndices,\n      currentItem.currentIndex,\n      shuffled,\n    );\n\n    StateManager.applyNewPlaybackPlan(playbackPlan, planIndex);\n  }\n\n  public prepareGenesis(currentItem: QueueItem | undefined): {\n    newCurrentIndex: number;\n    newPlaybackPlan: number[];\n    newPlanIndex: number;\n  } | null {\n    if (!currentItem || !currentItem.playlistContent) {\n      logProbe('[Strategy:Random] prepareGenesis 中止：传入的队列项无效。', 'error');\n      return null;\n    }\n\n    logProbe('[Strategy:Random] (Query) prepareGenesis: 收到“创世乐谱”谱写请求...', 'group');\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    for (let i = allIndices.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];\n    }\n\n    const newPlaybackPlan = allIndices;\n    const newPlanIndex = 0;\n    const newCurrentIndex = newPlaybackPlan[newPlanIndex];\n\n    logProbe(`(乐谱) 谱写完成。New CurrentIndex: ${newCurrentIndex}, New PlanIndex: ${newPlanIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { newCurrentIndex, newPlaybackPlan, newPlanIndex };\n  }\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 advance 请求. 方向: ${direction}`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'DoNothing' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    if (direction === 'next') {\n      const nextPlanIndex = planIndex + 1;\n\n      if (nextPlanIndex < playbackPlan.length) {\n        const targetTrackIndex = playbackPlan[nextPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(next) -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe('[Strategy:Random] advance(next) 已到达计划终点，委托给 _handlePlanEnd...');\n        logProbe('', 'groupEnd');\n        return this._handlePlanEnd(currentItem);\n      }\n    } else {\n      // direction === 'prev'\n      const prevPlanIndex = planIndex - 1;\n\n      if (prevPlanIndex >= 0) {\n        const targetTrackIndex = playbackPlan[prevPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(prev) -> GoTo (新 planIndex: ${prevPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe(`[Strategy:Random] 决策: advance(prev) 已在计划起点。返回 DoNothing。`);\n        logProbe('', 'groupEnd');\n        return { action: 'DoNothing' };\n      }\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onTrackEnd 请求.`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。返回 Stop 以策安全。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'Stop' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    const nextPlanIndex = planIndex + 1;\n\n    if (nextPlanIndex < playbackPlan.length) {\n      const targetTrackIndex = playbackPlan[nextPlanIndex];\n      logProbe(\n        `[Strategy:Random] 决策: onTrackEnd -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n      );\n      logProbe('', 'groupEnd');\n      return { action: 'GoTo', nextIndex: targetTrackIndex };\n    } else {\n      logProbe('[Strategy:Random] onTrackEnd 已到达计划终点，委托给 _handlePlanEnd...');\n      logProbe('', 'groupEnd');\n      return this._handlePlanEnd(currentItem);\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\n// =================================================================\n// 2.3. 策略管理器 (The StrategyManager - \"The Conductor\")\n// =================================================================\nconst StrategyManager = (() => {\n  logProbe('[StrategyManager] 模块正在初始化...');\n\n  const _strategies: Record<PlaybackMode, IPlaybackStrategy> = {\n    list: new ListStrategy(),\n    single: new SingleStrategy(),\n    random: new RandomStrategy(),\n  };\n  let _currentStrategy: IPlaybackStrategy = _strategies.list;\n\n  const publicAPI = {\n    /**\n     * [命令] 设置新的播放模式，并自动切换到对应的策略实例。\n     */\n    setMode(mode: PlaybackMode) {\n      logProbe(`[StrategyManager] (Command) setMode: 切换策略模式为 -> ${mode}`);\n      _currentStrategy = _strategies[mode];\n    },\n\n    /**\n     * [查询] 获取当前激活的策略实例。这是我们遵循CQS原则的体现。\n     */\n    getCurrentStrategy: () => _currentStrategy,\n\n    /**\n     * [命令] 通知当前策略：核心状态（如队列）已发生重大变化。\n     * 这是修复BUG的核心，它为策略提供了一个统一的生命周期钩子。\n     */\n\n    notifyQueueChanged() {\n      logProbe(\n        `[StrategyManager] (Command) notifyQueueChanged: 正在通知当前策略 (${_currentStrategy.constructor.name}) 队列已变更...`,\n        'groupCollapsed',\n      );\n      const currentItem = StateManager.getTopQueueItem();\n      _currentStrategy.onQueueChanged(currentItem);\n      logProbe('[StrategyManager] 通知完成。', 'groupEnd');\n    },\n  };\n\n  logProbe('[StrategyManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 3. 全局变量与常量 (Global Variables & Constants)\n// =================================================================\n\nconst STATE_KEY = '余烬双星_播放器状态';\n\nlet isInitializedForThisChat = false;\nlet isReconciling = false;\nlet _initializationResult: { success: boolean; error?: string } | null = null;\nlet _initializationPromiseControls: { resolve: () => void; reject: (reason?: any) => void } | null = null;\n\nlet _initializationPromise: Promise<void> | null = null;\nlet isScriptActive = true;\nlet allPlaylists: Record<string, PlaylistConfig> = {};\nlet triggers: z.infer<typeof ZodTriggerConfig>[] = [];\nlet defaultPlaylistId: string | undefined = '';\n\nlet isMvuIntegrationActive = false;\nlet isCorePlayerInitialized = false;\nlet isMvuMode = true;\nlet _currentChatId: string | number | null = null;\n\nconst fullStateUpdateCallbacks: ((payload: FullStatePayload) => void)[] = [];\nconst timeUpdateCallbacks: ((payload: TimeUpdatePayload) => void)[] = [];\n\n/**\n * 新架构的“运行时大脑”。\n * 它的单一职责是：响应“运行时”的增量事件，通过“边沿检测”模型，\n * 精确地、最小化地修改当前队列，并决策是否需要变更播放。\n * @param eventPayload - 可选的、来自 MVU 事件的最新状态数据。\n */\nasync function _reconcilePlaylistQueue(eventPayload?: any, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  if (!isScriptActive) {\n    return;\n  }\n  // --- 1. 【前置检查】: 防止并发的事件风暴 ---\n  if (isReconciling) {\n    logProbe('[Reconciler] 请求被合并：前一个校准任务仍在进行中。', 'warn');\n    return;\n  }\n  isReconciling = true;\n  logProbe(`=== [Reconciler] “统一校准官”已接管运行时事件 (模式: ${isMvuMode ? 'MVU' : 'Text'}) ===`, 'group');\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe('[Reconciler] (事务) 已上效果锁并广播“过渡中”状态，UI应进入等待。');\n    broadcastFullState();\n\n    // --- 核心逻辑 ---\n    try {\n      const oldTopItem = StateManager.getTopQueueItem();\n\n      // --- 2. 【获取事实 (The Branch)】: 双轨制分流 ---\n      let currentStateData: Record<string, any> = {};\n\n      if (isMvuMode) {\n        // [路径 A: MVU 模式]\n        if (eventPayload?.stat_data) {\n          // Case 1: 事件推送 (VARIABLE_UPDATE_ENDED)\n          currentStateData = eventPayload.stat_data;\n          logProbe('[Reconciler] (事实) 采用事件载荷提供的 MVU 状态。');\n        } else {\n          // Case 2: 主动查询 (MESSAGE_SWIPED / MESSAGE_DELETED)\n          // 注意：由于我们在事件监听层已经通过 duringGenerating() 过滤了生成中的情况，\n          // 这里获取到的权威状态应该是稳定且可靠的。\n          const authState = await _findLatestAuthoritativeMvuState();\n\n          if (authState) {\n            currentStateData = authState.mvuData?.stat_data ?? {};\n            logProbe('[Reconciler] (事实) 主动查询并采用了最新的 MVU 状态。');\n          } else {\n            // 如果真的找不到任何数据（极罕见），默认为空状态，这意味着触发器可能全部失效\n            logProbe('[Reconciler] (事实) 未找到有效的 MVU 状态，将使用空状态进行校准。', 'warn');\n            currentStateData = {};\n          }\n        }\n      } else {\n        // [路径 B: Text 模式]\n        logProbe('[Reconciler] (事实) 进入 Text 模式状态获取流程...');\n        const textResult = await TextTagManager.getLatestState();\n        currentStateData = textResult.tags;\n        logProbe(`[Reconciler] (事实) TextTagManager 已返回标准化状态 (FoundAt: ${textResult.foundAtMessageId})。`);\n      }\n\n      // --- 3. 【生成报告】: 委托 MvuManager 进行边沿检测 ---\n      const previousStateData = MvuManager.getPreviousState();\n      const changeReport = MvuManager.calculateChangeReport(previousStateData, currentStateData, triggers);\n\n      // --- 4. 【执行队列的增量修改】: 先减后加 ---\n      const newQueue = StateManager.getQueue();\n\n      if (changeReport.newlyInactiveTriggers.length > 0) {\n        _.remove(newQueue, item =>\n          changeReport.newlyInactiveTriggers.some(inactiveTrigger =>\n            areTriggersFunctionallyEqual(item.triggerSource, inactiveTrigger),\n          ),\n        );\n        logProbe(`[Reconciler] (修改) 根据报告移除了 ${changeReport.newlyInactiveTriggers.length} 个失效项。`);\n      }\n\n      if (changeReport.newlyActiveTriggers.length > 0) {\n        // 获取当前队列中的基础歌单ID，用于同名排斥检查\n        const baseItem = newQueue.find(item => item.triggeredBy === 'base');\n        const currentBaseId = baseItem?.playlistId;\n\n        for (const activeTrigger of changeReport.newlyActiveTriggers) {\n          // 1.自身重复性检查\n          if (\n            newQueue.some(item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, activeTrigger))\n          ) {\n            logProbe(`[Reconciler] (防御) 拒绝添加重复的激活项: \"${activeTrigger.playlist_id}\"`, 'warn');\n            continue;\n          }\n\n          // 2. 同名排斥机制\n          // 如果新触发的场景歌单 ID 与当前的基础歌单 ID 相同，则视为冗余，拒绝添加。\n          if (currentBaseId && activeTrigger.playlist_id === currentBaseId) {\n            logProbe(\n              `[Reconciler] (同名排斥) 触发器 \"${activeTrigger.playlist_id}\" 指向当前基础歌单，拒绝重复添加。`,\n              'warn',\n            );\n            continue;\n          }\n\n          const newItem = createQueueItem({\n            type: 'mvu',\n            playlistId: activeTrigger.playlist_id,\n            trigger: activeTrigger,\n          });\n          if (newItem) {\n            newQueue.push(newItem);\n            logProbe(`[Reconciler] (修改) 根据报告添加了新激活项: \"${newItem.playlistId}\"`);\n          }\n        }\n      }\n      StateManager.updateQueue(newQueue);\n\n      // --- 5. 【决策与执行】: 对比新旧队首 ---\n      const newTopItem = StateManager.getTopQueueItem();\n\n      if (newTopItem?.playlistId !== oldTopItem?.playlistId) {\n        logProbe(\n          `[Reconciler] (决策) 队首发生变更！ 从 \"${oldTopItem?.playlistId ?? '无'}\" 变为 \"${newTopItem?.playlistId ?? '无'}\"。`,\n        );\n\n        if (newTopItem) {\n          logProbe('[Reconciler] (握手) 正在通知 StrategyManager 队列已变更...');\n          StrategyManager.notifyQueueChanged();\n\n          newTopItem.wasEverPlayed = true;\n          const targetIndex = newTopItem.wasEverPlayed ? newTopItem.currentIndex : 0;\n\n          if (StateManager.isPlaying()) {\n            logProbe('[Reconciler] (效果) 用户正在播放，将执行过渡效果...');\n            if (options?.transitionEffect === 'hard') {\n              await PlaybackEngine.executeHardCut(\n                newTopItem.playlistContent[targetIndex].url,\n                StateManager.getVolume(),\n              );\n            } else {\n              await _executeTransition(targetIndex);\n            }\n          } else if (\n            oldTopItem === undefined && // 1. 队列发生“从无到有”的跃迁\n            StateManager.getPlaybackState() === 'STOPPED' // 2. 关键：只要不是 PAUSED (用户主动暂停)，就允许场景触发播放\n          ) {\n            logProbe(\n              '[Reconciler] 自动播放契约满足 (Queue 0->1 + Not Paused)，将调用 _executeGenesisPlayInternal。',\n              'warn',\n            );\n            await _executeGenesisPlayInternal(targetIndex);\n          } else {\n            logProbe('[Reconciler] (效果) 用户已暂停或未授权，仅在后台静默更新轨道，不播放。');\n            const track = newTopItem.playlistContent[targetIndex];\n            const activePlayer = PlaybackEngine.getActivePlayer();\n            if (track && activePlayer) {\n              activePlayer.src = track.url;\n            }\n          }\n        } else {\n          logProbe('[Reconciler] (决策) 监测到队列已完全清空。正在执行“物理静音”协议...', 'warn');\n\n          await PlaybackEngine.fadeOutAndPause();\n\n          StateManager.setPlaybackState('STOPPED');\n\n          StrategyManager.notifyQueueChanged();\n\n          logProbe('[Reconciler] (执行) “物理静音”完成，播放状态已置为 STOPPED。');\n        }\n      } else {\n        logProbe('[Reconciler] (决策) 队首未发生变更，保持当前播放稳定。');\n      }\n\n      // --- 6. 【更新记忆】: 为下一次边沿检测做准备 ---\n      await MvuManager.persistCurrentState(currentStateData);\n    } catch (error) {\n      logProbe(`[Reconciler] 核心逻辑执行期间发生严重错误: ${error}`, 'error');\n      console.error(error);\n    } finally {\n      await writeState('reconciliation');\n    }\n  } finally {\n    isReconciling = false;\n    await _releaseEffectLock();\n    logProbe('=== [Reconciler] “统一校准官”任务完成 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 4. 核心工具与广播系统 (Core Utilities & Broadcast System)\n// =================================================================\n\nfunction broadcastFullState() {\n  const currentItem = StateManager.getTopQueueItem();\n  const currentPlaylist = currentItem?.playlistContent ?? [];\n  const currentIndex = currentItem?.currentIndex ?? 0;\n\n  const payload: FullStatePayload = {\n    currentItem: currentPlaylist[currentIndex]\n      ? {\n          title: currentPlaylist[currentIndex].歌名,\n          artist: currentPlaylist[currentIndex].歌手,\n          cover: currentPlaylist[currentIndex].封面,\n        }\n      : null,\n    isPlaying: StateManager.isPlaying(),\n    playbackState: StateManager.getPlaybackState(),\n    playbackMode: StateManager.getPlaybackMode(),\n    masterVolume: StateManager.getVolume(),\n    playlist: currentPlaylist.map(item => ({ title: item.歌名, artist: item.歌手, cover: item.封面 })),\n    isTransitioning: StateManager.isPerformingEffect(),\n  };\n  logProbe(\n    `[Broadcast] 正在广播完整状态... [旧兼容: isPlaying=${payload.isPlaying}] [新内核: state=${payload.playbackState}] mode: ${payload.playbackMode}, currentItem: ${payload.currentItem?.title ?? '无'}`,\n    'groupCollapsed',\n  );\n  logProbe(`详细: isTransitioning=${payload.isTransitioning}`);\n  logProbe('', 'groupEnd');\n\n  fullStateUpdateCallbacks.forEach(callback => {\n    try {\n      callback(payload);\n    } catch (e) {\n      console.error('[音乐脚本] 完整状态回调执行出错:', e);\n    }\n  });\n}\n\nfunction broadcastTimeUpdate() {\n  const activePlayer = PlaybackEngine.getActivePlayer();\n  if (!StateManager.isPlaying() || !activePlayer) return;\n  const payload: TimeUpdatePayload = {\n    currentTime: activePlayer.currentTime,\n    duration: activePlayer.duration || 0,\n  };\n  timeUpdateCallbacks.forEach(callback => callback(payload));\n}\n\nfunction prepareNextTrack() {\n  const currentItem = StateManager.getTopQueueItem();\n  const standbyPlayer = PlaybackEngine.getStandbyPlayer();\n  if (!standbyPlayer || !currentItem) return;\n  const nextIndex = currentItem.currentIndex + 1;\n  if (nextIndex < currentItem.playlistContent.length) {\n    const nextTrack = currentItem.playlistContent[nextIndex];\n    if (nextTrack && standbyPlayer.src !== nextTrack.url) {\n      standbyPlayer.src = nextTrack.url;\n      standbyPlayer.load();\n    }\n  }\n}\n\n// =================================================================\n// 5. 状态管理 (State Management)\n// =================================================================\n\nfunction readState() {\n  logProbe('[StateReader] 正在尝试从酒馆变量读取持久化状态...');\n  const savedData = getVariables({ type: 'chat' })[STATE_KEY];\n\n  if (!savedData || typeof savedData !== 'object') {\n    logProbe('[StateReader] 未发现有效存档。');\n    return null;\n  }\n\n  logProbe('[StateReader] 发现原始状态数据，正在提交给 Zod 进行安全验证...');\n  const validationResult = ZodPersistedState.safeParse(savedData);\n\n  if (validationResult.success) {\n    logProbe('[StateReader] Zod 验证成功，状态数据安全。');\n    return validationResult.data;\n  } else {\n    console.warn('[StateReader] 持久化状态验证失败:', validationResult.error);\n    return null;\n  }\n}\n\nasync function writeState(source: string) {\n  if (!isScriptActive) {\n    logProbe(`[State] 写入操作被阻止，因为脚本正在停机。(来源: ${source})`, 'warn');\n    return;\n  }\n  try {\n    logProbe(`[State] 由 \"${source}\" 触发状态写入...`);\n    const dataToSave = StateManager.getStateSnapshotForPersistence();\n\n    await updateVariablesWith(\n      vars => {\n        vars[STATE_KEY] = dataToSave;\n        return vars;\n      },\n      { type: 'chat' },\n    );\n\n    logProbe(`[State] 状态已成功写入酒馆变量`);\n  } catch (e: any) {\n    logProbe(`[State] 写入状态时发生严重错误: ${e}`, 'error');\n  }\n}\n\n// =================================================================\n// 6. 世界书配置解析与队列操作 (Worldbook Parsing & Stack Operations)\n// =================================================================\n\n/**\n * @description 格式化 Zod 验证错误，以便在 toastr 中为角色卡作者显示清晰、可操作的反馈。\n */\nfunction _formatZodErrorForToastr(error: ZodError): void {\n  const issue = error.issues[0];\n  const path = issue.path.join(' -> ');\n  const message = issue.message;\n\n  const toastrTitle = `[MusicConfig] 内容错误`;\n  const toastrMessage = `路径: ${path} | 问题: ${message}`;\n\n  const fullLogMessage = `[MusicConfig] 内容错误:\\n路径: ${path}\\n问题: ${message}`;\n  logProbe(`[ZodValidator] 世界书配置验证失败: ${fullLogMessage}`, 'error');\n\n  toastr.error(toastrMessage, toastrTitle, { timeOut: 15000 });\n}\n\n// =================================================================\n// 核心算法 V9.5 (Core Algorithms for \"Concerto\")\n// 原则: 这些函数都必须是纯粹的查询 (CQS)，严禁产生任何副作用。\n// =================================================================\n\n/**\n * [核心算法] 判断两个触发器对象是否代表同一个“功能身份”。\n * @param a - 第一个触发器对象。\n * @param b - 第二个触发器对象。\n * @returns {boolean} 如果功能上相等，则返回 true。\n */\nfunction areTriggersFunctionallyEqual(\n  a: z.infer<typeof ZodTriggerConfig> | undefined,\n  b: z.infer<typeof ZodTriggerConfig> | undefined,\n): boolean {\n  if (!a || !b) return a === b;\n\n  if (a.playlist_id !== b.playlist_id) return false;\n\n  type ConditionKey = keyof z.infer<typeof ZodSingleCondition>;\n\n  const getCanonicalString = (condition: z.infer<typeof ZodSingleCondition>): string => {\n    return (Object.keys(condition) as ConditionKey[])\n      .sort()\n      .map(key => `${key}:${String(condition[key])}`) // 使用 String() 来确保所有值都能被正确处理\n      .join(',');\n  };\n\n  const conditionsA = a.conditions.map(getCanonicalString).sort();\n  const conditionsB = b.conditions.map(getCanonicalString).sort();\n\n  return conditionsA.length === conditionsB.length && conditionsA.every((val, index) => val === conditionsB[index]);\n}\n\n/**\n * @description [V9.7 核心强化] 查找权威MVU状态。现在能够识别“创世”和“运行时”两种数据结构。\n * @param context - 可选的上下文，用于指导查找方式。\n * @returns {Promise<{ mvuData: any, messageId: number } | null>} 权威状态或 null。\n */\nasync function _findLatestAuthoritativeMvuState(context?: {\n  messageId: number;\n  swipeId: number;\n}): Promise<{ mvuData: any; messageId: number } | null> {\n  // --- 模式一: 精确制导 (通常用于开场白) ---\n  if (context && context.messageId === 0 && typeof context.swipeId === 'number') {\n    logProbe(\n      `[StateFinder] (精确制导模式) 目标: message_id=${context.messageId}, swipe_id=${context.swipeId}`,\n      'groupCollapsed',\n    );\n    try {\n      const mvuDataContainer: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n\n      const swipeSpecificData = mvuDataContainer?.swipes_data?.[context.swipeId];\n\n      if (swipeSpecificData?.stat_data) {\n        // 成功在 \"创世\" 结构中找到特定 swipe 的数据\n        logProbe('[StateFinder] (探针) 检测到“创世”结构 (swipes_data)，成功命中！');\n        logProbe('', 'groupEnd');\n        return { mvuData: swipeSpecificData, messageId: 0 };\n      } else if (mvuDataContainer?.stat_data) {\n        // 在顶层找到了 \"运行时\" 结构的数据 (可能只有一个开场白)\n        logProbe('[StateFinder] (探针) 检测到“运行时”结构 (顶层 stat_data)，直接采用。');\n        logProbe('', 'groupEnd');\n        return { mvuData: mvuDataContainer, messageId: 0 };\n      } else {\n        logProbe('[StateFinder] (精确制导模式) 查找失败：在两种已知结构中均未找到 stat_data。', 'warn');\n      }\n    } catch (error) {\n      logProbe(`[StateFinder] (精确制导模式) 查询时出错: ${error}`, 'error');\n    } finally {\n      logProbe('', 'groupEnd');\n    }\n  }\n\n  // --- 模式二: 查询最新权威状态 ---\n  logProbe('[StateFinder] (查询最新状态) 开始执行...', 'groupCollapsed');\n  try {\n    // 1. 获取最新的一条消息\n    const latestMsgs = getChatMessages(-1, { include_swipes: true });\n\n    if (latestMsgs && latestMsgs.length > 0) {\n      const message = latestMsgs[0];\n\n      // 接口规范：消息 ID 的字段名为 message_id，而非 id。\n      const currentMessageId = message.message_id;\n\n      // 2. 防御性编程：检查 ID 有效性\n      if (typeof currentMessageId === 'number') {\n        logProbe(`(探针) 正在锁定最新消息楼层 id: ${currentMessageId}...`);\n\n        try {\n          // 3. 直接查询 MVU 数据\n          const mvuData = await Mvu.getMvuData({ type: 'message', message_id: currentMessageId });\n\n          if (mvuData?.stat_data) {\n            logProbe(`[StateFinder] 查找成功！在最新消息 (id: ${currentMessageId}) 处找到权威状态。`);\n            logProbe('', 'groupEnd');\n            return { mvuData, messageId: currentMessageId };\n          } else {\n            // 如果最新楼层没有数据，通常意味着这一楼没有触发 MVU 更新\n            logProbe(`[StateFinder] 最新楼层 (${currentMessageId}) 未包含 stat_data。`, 'warn');\n          }\n        } catch (error) {\n          logProbe(`[StateFinder] 查询 MVU 接口时发生错误: ${error}`, 'error');\n        }\n      } else {\n        logProbe(`[StateFinder] 获取到的最新消息 ID 无效: ${currentMessageId}`, 'warn');\n      }\n    } else {\n      logProbe('[StateFinder] 无法获取最新消息，聊天记录可能为空。', 'warn');\n    }\n\n    return null;\n  } catch (error) {\n    logProbe(`[StateFinder] 在获取聊天记录时发生严重错误: ${error}`, 'error');\n    return null;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description [职责单一] 找到、解析、验证并准备好【可供运行时直接使用】的音乐配置。\n * @returns {Promise<{ playlists: Record<string, PlaylistConfig>, defaultId: string, triggers: Trigger[] } | null>}\n *          一个包含了【 playlists 映射 】的、完全准备就绪的配置对象，或在失败时返回 null。\n */\n\nasync function parseWorldbookConfig() {\n  logProbe('[WorldbookParser V4-健壮模式] 开始解析...', 'group');\n\n  // [修改点] 自定义错误类，用于清晰地区分“配置缺失”和“未知错误”\n  // 这让我们的错误处理逻辑更符合 SRP 原则\n  class ConfigMissingError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'ConfigMissingError';\n    }\n  }\n\n  type AggregatedPlaylist = z.infer<typeof ZodPlaylistConfig> & { _sourceFile: string };\n  type AggregatedTrigger = z.infer<typeof ZodTriggerConfig> & { _sourceFile: string };\n\n  const aggregatedConfig: {\n    playlists: AggregatedPlaylist[];\n    triggers: AggregatedTrigger[];\n    defaultPlaylistId?: string;\n    _defaultPlaylistIdSourceFile: string | null;\n    explicitMvuMode?: boolean;\n  } = {\n    playlists: [],\n    triggers: [],\n    defaultPlaylistId: undefined,\n    _defaultPlaylistIdSourceFile: null,\n    explicitMvuMode: undefined,\n  };\n\n  try {\n    // 前置检查：在执行任何复杂逻辑前，首先确认世界书数据是否可访问。\n    const worldbookNames = getCharWorldbookNames('current');\n    const searchOrder = [worldbookNames.primary, ...worldbookNames.additional].filter(Boolean);\n\n    // 如果角色卡没有关联任何世界书，直接抛出我们自定义的错误\n    if (searchOrder.length === 0) {\n      throw new ConfigMissingError('角色卡未关联任何世界书。');\n    }\n\n    let foundAnyConfigEntry = false;\n\n    for (const bookName of searchOrder) {\n      if (!bookName) continue;\n      const entries = await getWorldbook(bookName);\n      const configEntries = entries.filter(e => e.name.includes('[MusicConfig]'));\n\n      if (configEntries.length > 0) {\n        foundAnyConfigEntry = true;\n      }\n\n      for (const entry of configEntries) {\n        logProbe(`[Parser V4] 发现并处理配置文件: \"${entry.name}\"`);\n        try {\n          const rawConfig = YAML.parse(entry.content);\n          const validationResult = ZodWorldbookConfig.safeParse(rawConfig);\n\n          if (!validationResult.success) {\n            logProbe(`[Parser V4] 条目 \"${entry.name}\" Zod验证失败，已跳过。`, 'error');\n            _formatZodErrorForToastr(validationResult.error);\n            continue;\n          }\n\n          const data = validationResult.data;\n\n          if (data.playlists) {\n            aggregatedConfig.playlists.push(...data.playlists.map(p => ({ ...p, _sourceFile: entry.name })));\n          }\n          if (data.triggers) {\n            aggregatedConfig.triggers.push(...data.triggers.map(t => ({ ...t, _sourceFile: entry.name })));\n          }\n          if (data.default_playlist_id) {\n            if (aggregatedConfig.defaultPlaylistId && aggregatedConfig.defaultPlaylistId !== data.default_playlist_id) {\n              const warningMsg = `在文件 \"${entry.name}\" 中发现的 default_playlist_id (\"${data.default_playlist_id}\") 覆盖了来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\" 的定义 (\"${aggregatedConfig.defaultPlaylistId}\")。为确保行为可预测，建议只保留一个定义。`;\n              logProbe(`[Parser V4] ${warningMsg}`, 'warn');\n              toastr.warning(warningMsg, '配置警告', { timeOut: 20000, closeButton: true });\n            }\n            aggregatedConfig.defaultPlaylistId = data.default_playlist_id;\n            aggregatedConfig._defaultPlaylistIdSourceFile = entry.name;\n          }\n          if (data.is_mvu !== undefined) {\n            aggregatedConfig.explicitMvuMode = data.is_mvu;\n            logProbe(`[Parser V9.5] (配置) 在文件 \"${entry.name}\" 中读取到显式模式设置: is_mvu = ${data.is_mvu}`);\n          }\n        } catch (e: any) {\n          logProbe(`[Parser V4] 解析条目 \"${entry.name}\" 时发生YAML语法错误: ${e.message}`, 'error');\n          toastr.error(`[MusicConfig] 文件 \"${entry.name}\" 格式错误：YAML 语法不正确。`, '配置错误', {\n            timeOut: 10000,\n          });\n        }\n      }\n    }\n\n    // 在所有文件都检查完之后，再判断是否找到了任何 [MusicConfig] 条目\n    if (!foundAnyConfigEntry) {\n      throw new ConfigMissingError('在已关联的世界书中，未找到任何包含 [MusicConfig] 的条目。');\n    }\n\n    // 模式推断与虚拟触发器生成\n    let finalIsMvu = false;\n\n    // 1. 优先级判断: 显式配置 > 自动推断\n    if (aggregatedConfig.explicitMvuMode !== undefined) {\n      finalIsMvu = aggregatedConfig.explicitMvuMode;\n      logProbe(`[Parser V9.5] (决策) 遵循显式配置，运行模式锁定为: ${finalIsMvu ? 'MVU模式' : '纯文字模式'}`);\n    } else {\n      // 2. 自动推断: 有触发器就是 MVU，否则是纯文字\n      finalIsMvu = aggregatedConfig.triggers.length > 0;\n      logProbe(\n        `[Parser V9.5] (决策) 基于内容自动推断，运行模式锁定为: ${finalIsMvu ? 'MVU模式 (发现触发器)' : '纯文字模式 (无触发器)'}`,\n      );\n    }\n\n    // 3. 纯文字模式下的虚拟化处理\n    if (!finalIsMvu) {\n      const uniquePlaylistIds = new Set(aggregatedConfig.playlists.map(p => p.id));\n      logProbe(`[Parser V9.5] (虚拟化) 正在为 ${uniquePlaylistIds.size} 个歌单生成隐式触发器...`);\n\n      for (const pid of uniquePlaylistIds) {\n        const virtualTrigger: AggregatedTrigger = {\n          type: 'mvu_variable',\n          playlist_id: pid,\n          priority: 0,\n          conditions: [\n            {\n              variable_path: 'virtual.music_tag',\n              value: pid.toLowerCase(),\n            },\n          ],\n          _sourceFile: 'System_Auto_Generated',\n        };\n        aggregatedConfig.triggers.push(virtualTrigger);\n      }\n      logProbe(\n        `[Parser V9.5] (虚拟化) 生成完成。系统现在可以识别 <scene:${Array.from(uniquePlaylistIds)[0]}...> 等标签。`,\n      );\n    }\n\n    // --- 全局健全性检查 (逻辑保持不变) ---\n    logProbe('[Parser V4] 所有文件聚合完毕，开始执行全局健全性检查...', 'groupCollapsed');\n    let isGloballyValid = true;\n    const playlistsById = _.groupBy(aggregatedConfig.playlists, 'id');\n    for (const id in playlistsById) {\n      if (playlistsById[id].length > 1) {\n        const sources = playlistsById[id].map(p => p._sourceFile).join(', ');\n        const errorMsg = `[MusicConfig] 致命错误: 歌单 ID \"${id}\" 在多个文件中重复定义。来源: ${sources}。ID 必须是唯一的。`;\n        logProbe(errorMsg, 'error');\n        toastr.error(errorMsg, '配置冲突', { timeOut: 15000 });\n        isGloballyValid = false;\n      }\n    }\n    const allPlaylistIds = new Set(aggregatedConfig.playlists.map(p => p.id));\n    if (aggregatedConfig.defaultPlaylistId && !allPlaylistIds.has(aggregatedConfig.defaultPlaylistId)) {\n      const errorMsg = `[MusicConfig] 配置错误: 最终的 default_playlist_id (\"${aggregatedConfig.defaultPlaylistId}\", 来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\") 指向了一个不存在的歌单。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 15000 });\n      aggregatedConfig.defaultPlaylistId = undefined;\n    }\n    const finalTriggers = aggregatedConfig.triggers.filter(trigger => {\n      if (allPlaylistIds.has(trigger.playlist_id)) {\n        return true;\n      }\n      const errorMsg = `[MusicConfig] 校验失败: 来自文件 \"${trigger._sourceFile}\" 的触发器指向了不存在的歌单ID \"${trigger.playlist_id}\"。该触发器将被忽略。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 10000 });\n      return false;\n    });\n\n    if (!isGloballyValid) {\n      logProbe('[Parser V4] 全局健全性检查失败，配置被拒绝。', 'error');\n      logProbe('', 'groupEnd');\n      logProbe('', 'groupEnd');\n      return null;\n    }\n    logProbe('[Parser V4] 全局健全性检查通过。');\n    logProbe('', 'groupEnd');\n\n    if (aggregatedConfig.playlists.length === 0) {\n      throw new ConfigMissingError('所有配置文件中都未能找到任何有效的歌单 (playlists)。');\n    }\n\n    // --- 数据归一化并返回 ---\n    const playlistsAsMap: Record<string, PlaylistConfig> = {};\n    for (const pl of aggregatedConfig.playlists) {\n      const normalizedTracks = pl.tracks.map(track => ({\n        url: track.url,\n        歌名:\n          track.歌名 && track.歌名.trim() !== ''\n            ? track.歌名\n            : decodeURIComponent(track.url.split('/').pop()?.split('?')[0] || '未知歌曲'),\n        歌手: track.歌手,\n        封面: track.封面,\n      }));\n\n      playlistsAsMap[pl.id] = { ..._.omit(pl, '_sourceFile'), tracks: normalizedTracks };\n    }\n\n    const finalConfig = {\n      playlists: playlistsAsMap,\n      defaultId: aggregatedConfig.defaultPlaylistId,\n      triggers: finalTriggers.map(t => _.omit(t, '_sourceFile')),\n      isMvu: finalIsMvu,\n    };\n\n    logProbe('[Parser V4] 数据归一化完成，运行时配置已就绪。', 'log');\n    logProbe('', 'groupEnd');\n    return finalConfig;\n  } catch (error) {\n    // 这是新的、更智能的错误处理中心\n    if (error instanceof ConfigMissingError) {\n      // 判断这个错误是不是我们自己抛出的“配置缺失”错误\n      logProbe(`[Parser V4] 捕获到可预见的配置错误: ${error.message}`, 'error');\n\n      // [核心修改] 直接使用 error.message 作为 toastr 的提示内容\n      // 这确保了我们抛出的具体错误信息能够直接呈现给用户\n      toastr.error(error.message, '[音乐播放器] 配置缺失', {\n        timeOut: 20000,\n        closeButton: true,\n      });\n    } else {\n      // 如果是其他所有无法预料的错误，比如酒馆环境问题\n      logProbe(`[Parser V4] 解析过程中发生意外顶层错误: ${error}`, 'error');\n      // 显示通用的、建议用户刷新的提示\n      toastr.error(\n        '播放器在加载设置时遇到一个临时问题。这通常可以通过按 F5 刷新酒馆页面来解决。',\n        '[音乐播放器] 加载时遇到临时问题',\n        {\n          timeOut: 20000,\n          closeButton: true,\n        },\n      );\n    }\n    logProbe('', 'groupEnd');\n    return null;\n  }\n}\n\n/**\n * [工厂 V3.0] 从持久化对象重建一个完整的、可供运行时使用的 QueueItem。\n * @param persistedItem - 从酒馆变量读取的、经过 Zod 验证的item。\n * @param playlistConfig - 从当前世界书解析出的对应歌单配置。\n * @returns {QueueItem} 一个完整的运行时 QueueItem。\n */\nfunction reconstituteQueueItem(\n  persistedItem: z.infer<typeof ZodQueueItemState>,\n  playlistConfig: PlaylistConfig,\n): QueueItem {\n  return {\n    playlistId: persistedItem.playlistId,\n    priority: persistedItem.triggerSource?.priority ?? -Infinity,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    onFinishRule: playlistConfig.onFinishRule,\n    currentIndex: persistedItem.currentIndex,\n    playedIndices: new Set(persistedItem.playedIndices),\n    wasEverPlayed: persistedItem.wasEverPlayed,\n    triggeredBy: persistedItem.triggerSource ? 'mvu' : 'base',\n    triggerSource: persistedItem.triggerSource,\n  };\n}\n\ntype CreateQueueItemConfig =\n  | { type: 'base'; playlistId: string }\n  | { type: 'mvu'; playlistId: string; trigger: z.infer<typeof ZodTriggerConfig> };\n\n/**\n * [工厂 V3.0] 创建一个全新的、状态初始化的 QueueItem。\n * @param config - 一个包含所有必要信息的配置对象。\n * @returns {QueueItem | null} 一个完整的队列项，或在失败时返回 null。\n */\nfunction createQueueItem(config: CreateQueueItemConfig): QueueItem | null {\n  const { playlistId } = config;\n\n  if (!playlistId || !allPlaylists[playlistId]) {\n    logProbe(`[Factory] 创建队列项失败：请求的歌单ID \"${playlistId}\" 不存在。`, 'error');\n    return null;\n  }\n\n  const playlistConfig = allPlaylists[playlistId];\n\n  const baseItem: Omit<QueueItem, 'triggeredBy' | 'triggerSource' | 'onFinishRule' | 'priority'> = {\n    playlistId: playlistId,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    currentIndex: 0,\n    playedIndices: new Set(),\n    wasEverPlayed: false,\n  };\n\n  if (config.type === 'base') {\n    return {\n      ...baseItem,\n      priority: -Infinity,\n      triggeredBy: 'base',\n      onFinishRule: playlistConfig.onFinishRule ?? 'loop',\n    };\n  } else {\n    return {\n      ...baseItem,\n      priority: config.trigger.priority,\n      triggeredBy: 'mvu',\n      onFinishRule: playlistConfig.onFinishRule,\n      triggerSource: config.trigger,\n    };\n  }\n}\n\n// =================================================================\n// 7. 运行时初始化与播放器控制 (Runtime & Player Controls)\n// =================================================================\n\nasync function initializePlayerForChat(\n  config: any,\n  authoritativeState: any,\n  options?: { autoPlayIfWasPlaying?: boolean },\n) {\n  logProbe('=== 开始执行【核心·自愈式初始化】 ===', 'group');\n  try {\n    // --- 【准备阶段】 清理与重置 ---\n    isCorePlayerInitialized = true;\n    // 注意：StateReset 会重置内存，所以我们需要先读档，再根据读档结果恢复必要的记忆\n    const savedState = readState();\n    StateManager.resetState();\n\n    if (savedState) {\n      // 恢复基础状态（此时 active_queue 还是空的，将在后面重建）\n      StateManager.loadState(savedState);\n    }\n\n    MvuManager.resetState();\n    MvuManager.initialize();\n    const activePlayer = PlaybackEngine.getActivePlayer();\n    if (activePlayer) activePlayer.pause();\n    triggers = [];\n    allPlaylists = {};\n    defaultPlaylistId = '';\n\n    if (!config) {\n      logProbe('[Initializer] 配置无效，初始化中止。', 'error');\n      broadcastFullState();\n      throw new Error('世界书音乐配置解析失败，请检查配置。');\n    }\n\n    allPlaylists = config.playlists;\n    defaultPlaylistId = config.defaultId;\n    triggers = config.triggers;\n\n    isMvuMode = config.isMvu;\n    logProbe(`[Initializer] 全局运行模式已固化: ${isMvuMode ? 'MVU 交响乐模式' : '纯文字 吟游诗人模式'}`);\n\n    const currentStatData = authoritativeState?.mvuData?.stat_data ?? null;\n    const authoritativeMessageId = authoritativeState?.messageId;\n\n    let finalQueue: QueueItem[] = [];\n\n    // --- 【第一步】 确定并验证权威的基础歌单 ID ---\n    let correctBasePlaylistId = defaultPlaylistId;\n\n    const msgZero = getChatMessages(0, { include_swipes: true })[0];\n    const currentSwipeId = msgZero?.swipe_id ?? 0;\n\n    if (msgZero) {\n      const currentGreeting = msgZero.swipes?.[msgZero.swipe_id];\n      const tagMatch = currentGreeting?.match(/<playlist:([^>]+)>/);\n      if (tagMatch && tagMatch[1]) {\n        const tagPlaylistId = tagMatch[1];\n        if (allPlaylists[tagPlaylistId]) {\n          logProbe(`[Initializer-Heal] (基准) 从开场白标签确定权威基础歌单: \"${tagPlaylistId}\"`);\n          correctBasePlaylistId = tagPlaylistId;\n        } else {\n          const errorMsg = `[MusicConfig] 配置警告: 开场白标签 <playlist:${tagPlaylistId}> 指向了一个不存在的歌单ID。将回退至默认歌单。`;\n          logProbe(errorMsg, 'warn');\n          toastr.warning(errorMsg, '配置警告', { timeOut: 15000 });\n        }\n      } else {\n        logProbe(`[Initializer-Heal] (基准) 开场白无标签，使用世界书默认歌单: \"${defaultPlaylistId ?? '无'}\"`);\n      }\n    }\n\n    const lastSwipeId = StateManager.getLastActiveSwipeId();\n\n    if (lastSwipeId !== null && lastSwipeId !== currentSwipeId) {\n      logProbe(`[Initializer] (上下文切换) 检测到平行宇宙跃迁: Swipe ${lastSwipeId} -> ${currentSwipeId}。`, 'warn');\n      logProbe(`[Initializer] (决策) 旧时间线的墓志铭已失效，正在清空...`);\n      StateManager.clearFinishedBasePlaylists();\n    } else {\n      logProbe(`[Initializer] (上下文保持) 同一时间线 (Swipe ${currentSwipeId})，保持墓志铭记录。`);\n    }\n    // 更新当前锚点\n    StateManager.setLastActiveSwipeId(currentSwipeId);\n\n    // 检查 4: 基础歌单与场景歌单冲突检查\n    if (config.isMvu && correctBasePlaylistId) {\n      const scenePlaylistIds = new Set(triggers.map(t => t.playlist_id));\n      if (scenePlaylistIds.has(correctBasePlaylistId)) {\n        const fatalErrorMsg = `[MusicConfig] 致命配置错误: 歌单 \"${correctBasePlaylistId}\" 不能同时被用作基础歌单（在开场白或默认设置中）和场景歌单（被触发器关联）。请为它们使用不同的歌单。`;\n        logProbe(fatalErrorMsg, 'error');\n        toastr.error(fatalErrorMsg, '配置冲突', { timeOut: 20000, closeButton: true });\n        throw new Error('基础歌单与场景歌单存在致命冲突。');\n      }\n    } else if (!config.isMvu && correctBasePlaylistId) {\n      logProbe(`[Initializer] (冲突豁免) 纯文字模式下，跳过基础/场景歌单重名检查。`);\n    }\n\n    // --- 【第二步】 队列净化与重建 (Heal the Past) ---\n    if (savedState) {\n      logProbe('[Initializer-Heal] (净化) 开始审查存档...', 'groupCollapsed');\n      const healedQueue: QueueItem[] = [];\n      // 注意：此时我们使用的是 savedState.active_queue，而不是 StateManager 中的（因为 resetState 会清空）\n      for (const persistedItem of savedState.active_queue) {\n        if (!Object.prototype.hasOwnProperty.call(allPlaylists, persistedItem.playlistId)) {\n          logProbe(`(净化-丢弃) 存档歌单 \"${persistedItem.playlistId}\" 已不存在。`, 'warn');\n          continue;\n        }\n\n        const playlistConfig = allPlaylists[persistedItem.playlistId];\n        const isBaseItem = !persistedItem.triggerSource;\n\n        if (isBaseItem) {\n          if (persistedItem.playlistId === correctBasePlaylistId) {\n            logProbe(`(净化-保留) 基础歌单 \"${persistedItem.playlistId}\" 仍然有效。`);\n            healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n          } else {\n            logProbe(\n              `(净化-丢弃) 基础歌单 \"${persistedItem.playlistId}\" 已被新的权威歌单 \"${correctBasePlaylistId ?? '无'}\" 替代。`,\n              'warn',\n            );\n          }\n        } else {\n          //实施同名排斥：场景层不能与基础层重叠\n          if (correctBasePlaylistId && persistedItem.playlistId === correctBasePlaylistId) {\n            logProbe(\n              `(净化-丢弃) 触发器歌单 \"${persistedItem.playlistId}\" 与当前权威基础歌单重名 (同名排斥原则)。`,\n              'warn',\n            );\n            continue;\n          }\n\n          const currentTrigger = triggers.find(t => t.playlist_id === persistedItem.playlistId);\n          logProbe(`(探针-净化) 正在审查存档的MVU歌单 \"${persistedItem.playlistId}\"...`);\n\n          if (playlistConfig.onFinishRule === 'pop') {\n            logProbe(`(净化-丢弃) 原因：规则为 'pop' (场景歌单不应跨会话保留)。`);\n            continue;\n          }\n\n          if (!currentTrigger) {\n            logProbe(`(净化-丢弃) 原因：在最新的世界书配置中已找不到对应的触发器。`, 'warn');\n            continue;\n          }\n\n          if (!MvuManager.checkTriggerCondition(currentTrigger, currentStatData)) {\n            logProbe(`(净化-丢弃) 原因：最新的触发器条件在当前状态下不满足。`);\n            continue;\n          }\n\n          logProbe(`(净化-保留) 验证通过。`);\n          healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n        }\n      }\n      finalQueue = healedQueue;\n      logProbe('[Initializer-Heal] (净化) 审查完成。', 'groupEnd');\n    }\n\n    // --- 【第三步】 队列补充 ---\n    if (currentStatData && triggers.length > 0) {\n      logProbe('[Initializer-Heal] (补充) 正在检查是否有新激活的场景歌单...', 'groupCollapsed');\n      for (const trigger of triggers) {\n        // 1. 先检查是否已存在队列中\n        const alreadyExists = finalQueue.some(\n          item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, trigger),\n        );\n        if (alreadyExists) continue;\n\n        // 2. 先检查条件是否满足\n        if (MvuManager.checkTriggerCondition(trigger, currentStatData)) {\n          // 3. 同名排斥检查\n          if (correctBasePlaylistId && trigger.playlist_id === correctBasePlaylistId) {\n            logProbe(\n              `(补充-跳过) 虽然触发条件满足，但触发器 \"${trigger.playlist_id}\" 指向当前基础歌单，拒绝重复添加 (同名排斥)。`,\n            );\n            continue;\n          }\n\n          const playlistConfig = allPlaylists[trigger.playlist_id];\n\n          // 4. Pop 规则检查 (防诈尸)\n          if (playlistConfig && playlistConfig.onFinishRule === 'pop') {\n            if (authoritativeMessageId === 0) {\n              logProbe(`(补充) 允许添加 'pop' 歌单 \"${trigger.playlist_id}\"，因为上下文是开场白。`);\n              const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n              if (newItem) finalQueue.push(newItem);\n            } else {\n              logProbe(\n                `(补充-阻止) 场景歌单 \"${trigger.playlist_id}\" 已激活，但因规则为 'pop' 且上下文非开场白而被忽略 (防诈尸)。`,\n                'warn',\n              );\n            }\n          } else {\n            // Loop 规则，直接添加\n            const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n            if (newItem) finalQueue.push(newItem);\n          }\n        }\n      }\n      logProbe('[Initializer-Heal] (补充) 检查完成。', 'groupEnd');\n    }\n\n    // --- 【第四步】 基础歌单最终注入 (Final Guarantee V2.0) ---\n    const basePlaylistExists = finalQueue.some(item => item.triggeredBy === 'base');\n    if (!basePlaylistExists && correctBasePlaylistId && allPlaylists[correctBasePlaylistId]) {\n      const isDead = StateManager.getFinishedBasePlaylists().has(correctBasePlaylistId);\n\n      if (isDead) {\n        logProbe(\n          `[Initializer-Heal] (注入-阻止) 基础歌单 \"${correctBasePlaylistId}\" 在此上下文(Swipe ${currentSwipeId})中已完结(墓志铭在册)。尊重历史，拒绝复活。`,\n        );\n      } else {\n        logProbe(`[Initializer-Heal] (注入) 最终注入权威基础歌单 \"${correctBasePlaylistId}\"。`);\n        const baseItem = createQueueItem({ type: 'base', playlistId: correctBasePlaylistId });\n        if (baseItem) finalQueue.push(baseItem);\n      }\n    }\n\n    // --- 【第五步】 最终加载与后续设置 ---\n    logProbe('[Initializer-Finalize] 正在提交最终队列并完成设置...');\n    StateManager.updateQueue(finalQueue);\n\n    // 注意：如果 resetState 重置了模式，我们需要从 savedState 恢复，或者使用默认\n    // 之前的代码是在 resetState 后直接覆盖，但这里我们利用 loadState 已经恢复了一部分\n    // 我们需要确保 StrategyManager 同步\n    const mode = StateManager.getPlaybackMode();\n    StrategyManager.setMode(mode);\n    logProbe(`(探针) 策略模式已同步为: ${mode}`);\n    StrategyManager.notifyQueueChanged();\n\n    PlaybackEngine.initialize();\n\n    const volume = StateManager.getVolume();\n    if (PlaybackEngine.getActivePlayer()) PlaybackEngine.getActivePlayer()!.volume = volume;\n    if (PlaybackEngine.getStandbyPlayer()) PlaybackEngine.getStandbyPlayer()!.volume = 0;\n\n    const initialTopItem = StateManager.getTopQueueItem();\n    if (initialTopItem) {\n      const track = initialTopItem.playlistContent[initialTopItem.currentIndex];\n      if (track && PlaybackEngine.getActivePlayer()) {\n        PlaybackEngine.getActivePlayer()!.src = track.url;\n      }\n    } else {\n      logProbe(`[Initializer] (探针) 最终队列为空（可能因基础歌单已完结），不执行音频预加载。`);\n    }\n\n    if (currentStatData) {\n      await MvuManager.persistCurrentState(currentStatData);\n      logProbe('[Initializer-Finalize]  已将本次创世的权威MVU状态持久化为历史基准。');\n    } else {\n      await MvuManager.persistCurrentState({});\n      logProbe('[Initializer-Finalize] 当前无MVU状态，已将空状态持久化为历史基准。');\n    }\n\n    await writeState('initialization');\n    broadcastFullState();\n\n    if (options?.autoPlayIfWasPlaying) {\n      logProbe('[Initializer] (探针) 检测到来自开场白滑动的“自动播放”意图。', 'warn');\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem) {\n        logProbe('[Initializer] 新的开场白已配置歌单，将执行“创世播放”...');\n        await _handleGenesisPlay();\n      } else {\n        logProbe('[Initializer] 新的开场白未配置歌单，自动播放已取消。');\n      }\n    }\n  } catch (error) {\n    logProbe(`[Initializer] 核心初始化过程中发生严重错误: ${error}`, 'error');\n    console.error(error);\n    throw error;\n  } finally {\n    logProbe('=== 【核心·自愈式初始化】执行完毕 ===', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】播放执行器。\n *              它的单一职责是：接收一个目标索引，并尝试播放它。\n *              它会返回一个 Promise，成功时 resolve，失败时 reject，将错误冒泡给调用者处理。\n *              它自身不包含任何重试或自愈逻辑。\n */\nasync function _executeTransition(targetIndex: number): Promise<void> {\n  logProbe(`[Executor] 收到播放指令，目标索引: ${targetIndex}`, 'group');\n\n  const freshItem = StateManager.getTopQueueItem();\n  if (!freshItem) {\n    logProbe(`[Executor] 执行中止：无有效队列项`, 'warn');\n    logProbe('', 'groupEnd');\n    return Promise.resolve();\n  }\n\n  const targetTrack = freshItem.playlistContent[targetIndex];\n  if (!targetTrack?.url) {\n    logProbe(`[Executor] 执行失败：在索引 ${targetIndex} 处找不到音轨或音轨URL无效。`, 'error');\n    logProbe('', 'groupEnd');\n    throw new Error(`Invalid track at index ${targetIndex}`);\n  }\n\n  try {\n    await PlaybackEngine.transitionToTrack(targetTrack.url, StateManager.getVolume());\n\n    StateManager.setPlaybackState('PLAYING');\n    prepareNextTrack();\n    logProbe(`[Executor] 索引 ${targetIndex} 播放成功。`);\n  } catch (error) {\n    logProbe(`[Executor] PlaybackEngine报告播放失败。原因: ${error}`, 'error');\n    throw error;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】迭代式自愈循环。\n *              此最终版严格遵守 SRP 原则，将决策应用逻辑完全委托给 _applyNavigationDecision。\n */\nasync function _executeSelfHealingLoop(): Promise<void> {\n  logProbe('[SelfHeal] 启动“迭代式自愈循环”... 播放器进入紧急自愈模式。', 'warn');\n\n  let consecutiveFailures = 1;\n  const currentItemForThreshold = StateManager.getTopQueueItem();\n  const threshold = currentItemForThreshold?.playlistContent.length ?? 0;\n\n  if (currentItemForThreshold) {\n    toastr.error(\n      `歌曲《${currentItemForThreshold.playlistContent[currentItemForThreshold.currentIndex]?.歌名 ?? '未知歌曲'}》加载失败，正在尝试自动处理...`,\n    );\n  }\n\n  while (true) {\n    if (threshold > 0 && consecutiveFailures >= threshold) {\n      logProbe(\n        `[SelfHeal] (熔断器) 连续失败 ${consecutiveFailures} 次，已达到或超过阈值 ${threshold}。自愈中止。`,\n        'error',\n      );\n      if (currentItemForThreshold) {\n        toastr.error(`歌单《${currentItemForThreshold.playlistId}》中所有歌曲均无法加载，播放已停止。`);\n      }\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    const currentItem = StateManager.getTopQueueItem();\n    if (!currentItem) {\n      logProbe('[SelfHeal] 自愈中止：中途队列变空。', 'warn');\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    const errorDecision = StrategyManager.getCurrentStrategy().onPlaybackError(currentItem);\n    logProbe(\n      `[SelfHeal] 收到策略 (${StrategyManager.getCurrentStrategy().constructor.name}) 的错误决策: { action: '${errorDecision.action}' }`,\n    );\n\n    const directive = await _applyNavigationDecision(errorDecision);\n\n    if (!directive.needsAsyncEffect) {\n      logProbe('[SelfHeal] 决策应用后无需播放，自愈中止。');\n      // 注意：applyNavigationDecision 内部已经处理了 setPlaying(false) 和广播\n      return;\n    }\n\n    // 防御性编程：确保 targetIndex 存在\n    if (typeof directive.targetIndex !== 'number') {\n      logProbe('[SelfHeal] 决策应用后需要播放，但没有有效的 targetIndex。自愈中止。', 'error');\n      StateManager.setPlaybackState('STOPPED');\n      broadcastFullState();\n      return;\n    }\n\n    // 步骤 4: 再次尝试播放\n    try {\n      await _executeTransition(directive.targetIndex);\n\n      logProbe('[SelfHeal] 播放成功，自愈循环结束。', 'log');\n      broadcastFullState();\n      return;\n    } catch (nextError) {\n      consecutiveFailures++;\n      const nextTopItem = StateManager.getTopQueueItem();\n      const nextTrackTitle = nextTopItem?.playlistContent[nextTopItem.currentIndex]?.歌名 ?? '未知歌曲';\n      logProbe(`[SelfHeal] 第 ${consecutiveFailures} 次播放失败:`, 'error');\n      console.error(nextError);\n      toastr.error(`下一首《${nextTrackTitle}》加载失败...`);\n    }\n  }\n}\n\nasync function _applyNavigationDecision(\n  decision: StrategyDecision,\n): Promise<{ needsAsyncEffect: boolean; targetIndex?: number }> {\n  logProbe(\n    `[CentralCommand] 正在应用策略决策: { action: '${decision.action}', nextIndex: ${decision.nextIndex ?? 'N/A'} }`,\n    'group',\n  );\n\n  let needsAsyncEffect = false;\n  let targetIndex: number | undefined;\n\n  const currentItem = StateManager.getTopQueueItem();\n\n  switch (decision.action) {\n    case 'GoTo': {\n      if (typeof decision.nextIndex === 'number') {\n        logProbe('[CentralCommand] 指令: GoTo。提交导航步骤...');\n        StateManager.commitNavigationStep(decision.nextIndex);\n        needsAsyncEffect = true;\n        targetIndex = decision.nextIndex;\n      } else {\n        logProbe('[CentralCommand] 致命逻辑错误: GoTo 指令缺少 nextIndex！这是一个策略模块的BUG。', 'error');\n        console.error('探针捕获：错误的决策对象:', decision);\n        console.error('探针捕获：发生错误时的播放器状态:', StateManager.getStateSnapshotForRuntime());\n        needsAsyncEffect = false;\n      }\n      break;\n    }\n\n    case 'Restart': {\n      logProbe('[CentralCommand] 指令: Restart。请求从头重播当前轨道。');\n      if (currentItem) {\n        logProbe('[CentralCommand] (探针) 此决策不改变状态索引，仅生成一个效果指令。');\n        needsAsyncEffect = true;\n        targetIndex = currentItem.currentIndex;\n      }\n      break;\n    }\n\n    case 'RemoveTopAndAdvance': {\n      logProbe('[CentralCommand] 指令: RemoveTopAndAdvance。正在执行【自洽式】队列修改与过渡...');\n      const itemToRemove = StateManager.getTopQueueItem();\n      if (itemToRemove && itemToRemove.triggeredBy === 'base' && itemToRemove.onFinishRule === 'pop') {\n        logProbe(`[CentralCommand] (死亡登记) 基础歌单 \"${itemToRemove.playlistId}\" 即将离场`, 'warn');\n        StateManager.addToFinishedBasePlaylists(itemToRemove.playlistId);\n      }\n      const currentQueue = StateManager.getQueue();\n\n      const poppedItem = currentQueue.shift();\n      logProbe(`(探针) 已从队列中移除: \"${poppedItem?.playlistId}\"`);\n\n      StateManager.updateQueue(currentQueue);\n\n      logProbe('[CentralCommand] (握手) 正在通知 StrategyManager 队列已变更...');\n      StrategyManager.notifyQueueChanged();\n\n      const newTopItem = StateManager.getTopQueueItem();\n      if (newTopItem) {\n        logProbe(`(决策) 新队首为 \"${newTopItem.playlistId}\"，准备过渡到其当前索引: ${newTopItem.currentIndex}`);\n        needsAsyncEffect = true;\n        targetIndex = newTopItem.currentIndex;\n      } else {\n        logProbe('(决策) 队列已空，停止播放。');\n        logProbe('[CentralCommand] (修复) 检测到队列清空，正在下达物理静音指令...');\n        await PlaybackEngine.fadeOutAndPause();\n        StateManager.setPlaybackState('STOPPED');\n        needsAsyncEffect = false;\n      }\n\n      break;\n    }\n\n    case 'LoopReset': {\n      logProbe('[CentralCommand] 指令: LoopReset。执行“指挥家模型”...', 'warn');\n      StateManager.resetCurrentItemForLoop();\n      const currentMode = StateManager.getPlaybackMode();\n      if (currentMode === 'random') {\n        logProbe('(指挥) 检测到随机模式，向作曲家索要新乐谱...');\n        const genesisPlan = (StrategyManager.getCurrentStrategy() as RandomStrategy).prepareGenesis(\n          StateManager.getTopQueueItem(),\n        );\n        if (genesisPlan) {\n          StateManager.commitGenesisState(\n            genesisPlan.newCurrentIndex,\n            genesisPlan.newPlaybackPlan,\n            genesisPlan.newPlanIndex,\n          );\n        }\n      }\n      const finalStartIndex = StateManager.getTopQueueItem()?.currentIndex ?? 0;\n      logProbe(`(指挥) 流程完成。最终确定的新起始索引为: ${finalStartIndex}`);\n      needsAsyncEffect = true;\n      targetIndex = finalStartIndex;\n      break;\n    }\n\n    case 'Stop': {\n      logProbe('[CentralCommand] 指令: Stop。停止播放。');\n      StateManager.setPlaybackState('STOPPED');\n      break;\n    }\n\n    case 'DoNothing':\n    default:\n      logProbe(`[CentralCommand] 指令: DoNothing。无状态变更。`);\n      break;\n  }\n\n  if (decision.action !== 'RemoveTopAndAdvance') {\n    broadcastFullState();\n  }\n\n  const directive = { needsAsyncEffect, targetIndex };\n  logProbe(\n    `[CentralCommand] 决策应用完成。返回指令: { needsAsyncEffect: ${directive.needsAsyncEffect}, targetIndex: ${directive.targetIndex ?? 'N/A'} }`,\n  );\n  logProbe('', 'groupEnd');\n  return directive;\n}\n\n/**\n * @description [V9.6 净化] 释放效果锁并广播最终状态。\n *              这是所有异步控制器 finally 块中的标准“谢幕”程序。\n */\nasync function _releaseEffectLock() {\n  // 探针: 记录锁释放的动作，这对于调试UI卡死问题至关重要\n  logProbe('[LockManager] 正在释放效果锁并广播最终状态...');\n\n  StateManager.setPerformingEffect(false);\n  broadcastFullState();\n}\n\nasync function _handleTrackEnded() {\n  logProbe('[Controller:TrackEnd] === 开始处理轨道自然结束事件 ===', 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:TrackEnd] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:TrackEnd] 请求中止：队列为空。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().onTrackEnd(currentItem);\n    const directive = await _applyNavigationDecision(decision);\n\n    if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    }\n  } catch (error) {\n    logProbe(`[Controller:TrackEnd] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('trackEnded');\n    logProbe('[Controller:TrackEnd] === 轨道结束事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 8. 全局API与事件系统 (Global API & Event System)\n// =================================================================\n\nasync function _handleNavigation(direction: 'next' | 'prev') {\n  logProbe(`[Controller:Nav] === 开始处理用户导航事件 (方向: ${direction}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:Nav] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe(`[Controller:Nav] 请求中止：队列为空。`);\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().advance(currentItem, direction);\n    const directive = await _applyNavigationDecision(decision);\n\n    logProbe(\n      `[Controller:Nav] (探针) 原始决策: ${decision.action}, 处理指令: needsAsyncEffect=${directive.needsAsyncEffect}`,\n    );\n\n    if (decision.action === 'Restart') {\n      logProbe(`[Controller:Nav] 检测到 Restart 决策，执行 seek(0) 效果。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n      if (StateManager.getPlaybackMode() !== 'single') {\n        toastr.info('已是第一首');\n      }\n    } else if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    } else if (decision.action === 'DoNothing') {\n      toastr.info(direction === 'next' ? '已是歌单最后一首。' : '已是歌单第一首。');\n    }\n  } catch (error) {\n    logProbe(`[Controller:Nav] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('navigation');\n    logProbe(`[Controller:Nav] === 用户导航事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\n/**\n * [内部核心] 执行创世播放的实际逻辑。\n * 注意：此函数不检查也不设置效果锁，调用者必须确保已持有锁。\n */\nasync function _executeGenesisPlayInternal(targetIndex: number) {\n  logProbe(`[Internal:Genesis] (动作) 执行内部创世播放逻辑 (目标索引: ${targetIndex})...`);\n  StateManager.setPlaybackState('PLAYING');\n  broadcastFullState();\n  await _executeTransition(targetIndex);\n}\n\nasync function _handleGenesisPlay() {\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Genesis] 请求被拒绝，因为效果正在执行。', 'warn');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Genesis] 请求中止：播放列表为空。');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe(`[Controller:Genesis] === “创世播放”效果开始 (目标索引: ${currentItem.currentIndex}) ===`, 'group');\n\n    await _executeGenesisPlayInternal(currentItem.currentIndex);\n  } catch (error) {\n    logProbe(`[Controller:Genesis] “创世播放”效果执行时发生意外顶层错误: ${error}`, 'error');\n    StateManager.setPlaybackState('STOPPED');\n    broadcastFullState();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('genesisPlay');\n    logProbe(`[Controller:Genesis] === “创世播放”效果结束 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function _handlePlayIndex(index: number) {\n  logProbe(`[Controller:PlayIndex] === 开始处理索引播放事件 (目标: ${index}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:PlayIndex] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentItem = StateManager.getTopQueueItem();\n    const currentMode = StateManager.getPlaybackMode();\n\n    if (currentItem && index === currentItem.currentIndex) {\n      logProbe(`[Controller:PlayIndex] (决策) 用户点击了当前歌曲，将从头重播。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n    } else if (currentMode === 'list' || currentMode === 'single') {\n      logProbe(`[Controller:PlayIndex] (决策) ${currentMode} 模式，执行标准跳转...`);\n      StateManager.setCurrentIndex(index);\n      await _executeTransition(index);\n    } else if (currentMode === 'random') {\n      logProbe(`[Controller:PlayIndex] (决策) random 模式，执行“用户跳转”高级逻辑...`);\n      StateManager.userInitiatedJump(index);\n      await _executeTransition(index);\n    }\n  } catch (error) {\n    logProbe(`[Controller:PlayIndex] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('playIndex');\n    logProbe(`[Controller:PlayIndex] === 索引播放事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function togglePlayPause() {\n  logProbe('[Controller:Toggle] === 开始处理播放/暂停切换事件 (三态机版) ===', 'group');\n\n  // 1. 效果锁检查\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Toggle] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  // 2. 空队列检查\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Toggle] 请求中止：播放列表为空。');\n    toastr.info('播放列表为空');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    // 3. 上锁并广播\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentState = StateManager.getPlaybackState();\n    logProbe(`[Controller:Toggle] 当前状态: ${currentState}`);\n\n    switch (currentState) {\n      case 'STOPPED': {\n        // [核心] 这是首次播放意图的关键点\n        logProbe('[Controller:Toggle] 决策: STOPPED -> PLAYING (视为创世播放)');\n\n        StateManager.setPlaybackState('PLAYING');\n        broadcastFullState();\n\n        // 尝试播放当前队首\n        // 如果是刚加载的歌单，currentIndex 应该是 0，或者是记忆中的位置\n        await _executeTransition(currentItem.currentIndex);\n        break;\n      }\n\n      case 'PLAYING': {\n        logProbe('[Controller:Toggle] 决策: PLAYING -> PAUSED');\n        StateManager.setPlaybackState('PAUSED');\n        broadcastFullState();\n        await PlaybackEngine.fadeOutAndPause();\n        break;\n      }\n\n      case 'PAUSED': {\n        logProbe('[Controller:Toggle] 决策: PAUSED -> PLAYING (恢复)');\n        StateManager.setPlaybackState('PLAYING');\n        broadcastFullState();\n        await PlaybackEngine.resumeAndFadeIn(StateManager.getVolume());\n        break;\n      }\n    }\n  } catch (error) {\n    logProbe(`[Controller:Toggle] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('togglePlayPause');\n    logProbe('[Controller:Toggle] === 播放/暂停切换事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\nfunction playNext() {\n  void _handleNavigation('next');\n}\n\nfunction playPrev() {\n  void _handleNavigation('prev');\n}\n\nfunction setupGlobalAPI() {\n  window.musicPlayerAPI = {\n    requestInitialization: (): Promise<void> => {\n      // [修复] 时序竞态保护逻辑 V2.0\n      // 场景 A: 后台跑得太快，已经初始化完了 (Cache Hit)\n      if (_initializationResult) {\n        if (_initializationResult.success) {\n          logProbe('[API] requestInitialization (缓存命中): 后台已就绪，立即返回成功信号。', 'log');\n          return Promise.resolve();\n        } else {\n          logProbe(\n            `[API] requestInitialization (缓存命中): 后台初始化曾失败，返回错误: ${_initializationResult.error}`,\n            'error',\n          );\n          return Promise.reject(new Error(_initializationResult.error));\n        }\n      }\n\n      // 场景 B: 后台还在忙，或者还没开始 (Wait)\n      if (!_initializationPromise) {\n        logProbe(\n          '[API] requestInitialization (创建): 收到首个请求且无缓存，正在创建唯一的 Promise 契约 (状态: Pending)...',\n          'warn',\n        );\n        _initializationPromise = new Promise((resolve, reject) => {\n          _initializationPromiseControls = { resolve, reject };\n        });\n      } else {\n        logProbe('[API] requestInitialization (复用): 收到后续请求，返回已存在的 Promise 契约 (仍在等待后台)。');\n      }\n\n      return _initializationPromise;\n    },\n\n    togglePlayPause: () => togglePlayPause(),\n    playNext: () => playNext(),\n    playPrev: () => playPrev(),\n    playIndex: (index: number) => {\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem && index >= 0 && index < currentItem.playlistContent.length) {\n        void _handlePlayIndex(index);\n      }\n    },\n    persistVolumeAndBroadcast: (volume: number) => {\n      const finalVolume = Math.max(0, Math.min(1, volume));\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      StateManager.setVolume(finalVolume);\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = finalVolume;\n      void writeState('persistVolume');\n      broadcastFullState();\n    },\n    setLiveVolume: (volume: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = Math.max(0, Math.min(1, volume));\n    },\n\n    setPlaybackMode: (mode: PlaybackMode) => {\n      logProbe(`=== 开始执行【模式切换】事务 (请求: ${mode}) ===`, 'group');\n      const oldMode = StateManager.getPlaybackMode();\n      if (mode === oldMode) {\n        logProbe(`[ModeSwitch] 模式未变更 (仍为 ${mode})，事务提前中止。`);\n        logProbe('', 'groupEnd');\n        return;\n      }\n\n      StateManager.setPlaybackMode(mode);\n      StrategyManager.setMode(mode);\n\n      logProbe(`[ModeSwitch] 策略已切换为: ${StrategyManager.getCurrentStrategy().constructor.name}`);\n\n      if (oldMode === 'random') {\n        logProbe('[ModeSwitch] 正在为旧模式 \"random\" 执行“离开”生命周期钩子...');\n        StateManager.clearRandomModePlan();\n      }\n      if (mode === 'random') {\n        logProbe('[ModeSwitch] 正在为新模式 \"random\" 执行“进入”生命周期钩子...');\n        StrategyManager.notifyQueueChanged();\n      }\n\n      void writeState('setPlaybackMode');\n      broadcastFullState();\n      logProbe('=== 【模式切换】事务执行完毕 ===', 'groupEnd');\n    },\n    seekTo: (percentage: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer?.duration) activePlayer.currentTime = activePlayer.duration * percentage;\n    },\n    getCurrentState: (): FullStatePayload => {\n      const i = StateManager.getTopQueueItem();\n      const c = i?.playlistContent ?? [];\n      const x = i?.currentIndex ?? 0;\n      const stateToReturn: FullStatePayload = {\n        currentItem: c[x] ? { title: c[x].歌名, artist: c[x].歌手, cover: c[x].封面 } : null,\n        isPlaying: StateManager.isPlaying(),\n        playbackState: StateManager.getPlaybackState(),\n        playbackMode: StateManager.getPlaybackMode(),\n        masterVolume: StateManager.getVolume(),\n        playlist: c.map(t => ({ title: t.歌名, artist: t.歌手, cover: t.封面 })),\n        isTransitioning: StateManager.isPerformingEffect(),\n      };\n      logProbe('[探针 B] 前端主动调用 getCurrentState 获取初始状态，后台返回的数据如下:', 'warn');\n      console.dir(stateToReturn);\n      return stateToReturn;\n    },\n\n    onFullStateUpdate: (c: (payload: FullStatePayload) => void) => {\n      if (typeof c === 'function') {\n        fullStateUpdateCallbacks.push(c);\n        logProbe(`[API] 前端注册了 fullStateUpdate 监听器。当前监听数: ${fullStateUpdateCallbacks.length}`);\n\n        return () => {\n          const index = fullStateUpdateCallbacks.indexOf(c);\n          if (index > -1) {\n            fullStateUpdateCallbacks.splice(index, 1);\n            logProbe(`[API] 前端注销了 fullStateUpdate 监听器。剩余监听数: ${fullStateUpdateCallbacks.length}`);\n          }\n        };\n      }\n\n      return () => {};\n    },\n\n    onTimeUpdate: (c: (payload: TimeUpdatePayload) => void) => {\n      if (typeof c === 'function') {\n        timeUpdateCallbacks.push(c);\n\n        return () => {\n          const index = timeUpdateCallbacks.indexOf(c);\n          if (index > -1) {\n            timeUpdateCallbacks.splice(index, 1);\n          }\n        };\n      }\n      return () => {};\n    },\n  };\n  initializeGlobal('musicPlayerAPI', window.musicPlayerAPI);\n}\n\n// =================================================================\n// 9. 酒馆集成与主执行区 (Tavern Integration & Main Execution)\n// =================================================================\n\nfunction executeHardReset() {\n  logProbe('[HardReset] “优雅停机”协议启动...', 'warn');\n\n  isScriptActive = false;\n\n  PlaybackEngine.getActivePlayer()?.pause();\n  logProbe('[HardReset] 音频已暂停。');\n\n  logProbe('[HardReset] 即将调用 reloadIframe()。');\n  reloadIframe();\n}\n\nasync function tryInitialize() {\n  if (isInitializedForThisChat) return;\n\n  const currentChatId = SillyTavern.getCurrentChatId ? SillyTavern.getCurrentChatId() : null;\n\n  if (SillyTavern.chat.length > 0 && currentChatId !== null) {\n    // [原则: SRP] isInitializedForThisChat 标志现在是这个函数的“守卫”，确保初始化只执行一次。\n    isInitializedForThisChat = true;\n    _currentChatId = currentChatId;\n\n    logProbe(`【初始化】锁定ID: ${_currentChatId}，开始执行“分流-等待-执行”协议...`, 'group');\n\n    try {\n      // --- 步骤一：检测 (Detect) ---\n      // [原则: SSoT] 初始化流程的第一个动作，就是获取“世界书”这个唯一事实来源。\n      const config = await parseWorldbookConfig();\n      if (!config) {\n        throw new Error('无法解析世界书配置，初始化中止。');\n      }\n\n      const isMvuCard = config.isMvu;\n      logProbe(`(探针-决策) 作者意图判断 -> 是MVU卡吗? ${isMvuCard}`);\n\n      // --- 步骤二：分流 (Branch) & 等待 (Wait) ---\n      if (isMvuCard) {\n        logProbe('【指挥官】(路径选择) 检测到MVU卡，进入“安全路径”，开始等待MVU就绪...');\n        // [原则: CQS] _waitForMvuGenesis 是一个“查询”，它询问外部环境状态，直到满足条件。\n        // 注意: MVU 模式的事件注册 (_registerMvuEventListeners) 是在 _waitForMvuGenesis 内部成功后触发的\n        const mvuIsReady = await _waitForMvuGenesis();\n        if (!mvuIsReady) {\n          throw new Error('MVU集成初始化失败或超时，部分功能将不可用。');\n        }\n        logProbe('【指挥官】MVU已完全就绪，可以安全继续。');\n      } else {\n        logProbe('【指挥官】(路径选择) 检测到纯文字卡，进入“快速路径”。');\n        _registerTextEventListeners();\n      }\n\n      // --- 步骤三：执行 (Execute) ---\n      logProbe('【指挥官】所有前置条件满足，开始执行播放器核心初始化...');\n\n      let authoritativeState = null;\n      if (isMvuCard) {\n        logProbe('【指挥官】(查询) 正在为MVU卡查找权威状态...');\n        authoritativeState = await _findLatestAuthoritativeMvuState();\n      } else {\n        logProbe('【指挥官】(执行) 纯文字卡，正在查找最新的文本标签状态...');\n        const textResult = await TextTagManager.getLatestState();\n\n        //构造统一的权威状态对象 (Unified Authority Object)\n        authoritativeState = {\n          mvuData: { stat_data: textResult.tags },\n          messageId: textResult.foundAtMessageId,\n        };\n        logProbe(`【指挥官】文本状态获取完成 (Anchor ID: ${textResult.foundAtMessageId})。`);\n      }\n\n      await initializePlayerForChat(config, authoritativeState);\n\n      _registerContextualEventListeners();\n      logProbe('【指挥官】正在执行初始化后的 UI 一致性检查...');\n      await _ensureUiVisibility();\n\n      _initializationResult = { success: true };\n\n      if (_initializationPromiseControls) {\n        logProbe('【指挥官】(探针) 后台初始化成功，兑现 Promise 契约，唤醒前端。');\n        _initializationPromiseControls.resolve();\n      } else {\n        logProbe('【指挥官】(探针) 后台初始化成功，已写入缓存。前端尚未建立连接，等待其后续拉取。');\n      }\n    } catch (error) {\n      logProbe(`【指挥官】在初始化主流程中发生严重错误: ${error}`, 'error');\n\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      _initializationResult = { success: false, error: errorMessage };\n\n      if (_initializationPromiseControls) {\n        _initializationPromiseControls.reject(errorMessage);\n      } else {\n        logProbe('【指挥官】(探针) 初始化失败，已写入错误缓存。前端尚未建立连接。');\n      }\n    } finally {\n      _initializationPromiseControls = null;\n      logProbe('【初始化指挥官 】协议执行完毕。', 'groupEnd');\n    }\n  }\n}\n\n/**\n * MVU 哨兵探测器\n * 职责: 轮询检测 MVU 的 <StatusPlaceHolderImpl/> 标签，作为“MVU已接管本楼层”的信号。\n * @param messageId - 目标消息ID\n * @returns Promise<boolean> - true 表示发现哨兵，false 表示超时未发现\n */\nasync function _waitForMvuSentinel(messageId: number): Promise<boolean> {\n  const POLLING_INTERVAL = 100; // 100ms\n  const MAX_ATTEMPTS = 15; // 1.5秒超时 (放宽一点以适应稍慢的设备)\n\n  for (let i = 0; i < MAX_ATTEMPTS; i++) {\n    const msgs = getChatMessages(messageId);\n    if (msgs && msgs.length > 0) {\n      const content = msgs[0].message;\n      if (typeof content === 'string' && content.includes('<StatusPlaceHolderImpl/>')) {\n        logProbe(`[Sentinel] 在第 ${i + 1} 次轮询中发现 MVU 哨兵标签。`);\n        return true;\n      }\n    }\n    await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL));\n  }\n\n  logProbe(`[Sentinel] 轮询超时，未发现 MVU 哨兵标签 (可能是Extra模式或MVU未响应)。`);\n  return false;\n}\n\nfunction _registerMvuEventListeners() {\n  logProbe('[EventDispatcher] 正在注册【运行时】MVU 事件监听器 (哨兵模式 V3)...', 'group');\n\n  // 1. 变量更新监听器 (负责核心校准 + 覆写补救)\n  eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, async (eventPayload?: any) => {\n    if (!isMvuIntegrationActive || !isCorePlayerInitialized) return;\n\n    logProbe(`[Event-MVU] 捕获到变量更新事件 (Payload: ${eventPayload ? '有' : '无'})。`);\n\n    // 步骤 A: 校准队列\n    await _reconcilePlaylistQueue(eventPayload);\n\n    // 步骤 B: 补救 UI\n    logProbe(`[Event-MVU] 变量更新完毕，执行抗覆写 UI 检查...`);\n    await _ensureUiVisibility();\n  });\n\n  // 2. 消息接收监听器\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (id: number) => {\n    if (!isScriptActive) return;\n    logProbe(`[Event-MVU] 捕获到新消息 (id: ${id})。启动哨兵探测流程...`);\n\n    // 步骤 A: 哨兵轮询\n    await _waitForMvuSentinel(id);\n\n    // 步骤 B: 兜底校准\n    await _reconcilePlaylistQueue(undefined);\n\n    // 步骤 C: UI 注入\n    logProbe('[Event-MVU] 哨兵流程结束，执行 UI 注入尝试。');\n    await _handleNewAssistantMessage(id);\n  });\n\n  logProbe('[EventDispatcher] MVU 监听器部署完毕。', 'groupEnd');\n}\n\nfunction _registerTextEventListeners() {\n  logProbe('[EventDispatcher] 正在注册【吟游诗人】文本模式事件监听器...', 'group');\n\n  //为 MESSAGE_RECEIVED 事件建立一个原子的“校准-注入”流程。\n  eventOn(tavern_events.MESSAGE_RECEIVED, async (id: number) => {\n    if (!isScriptActive) return;\n\n    logProbe(`[Event-Text] 捕获到新消息 (id: ${id})。启动“校准-注入”原子流程...`);\n\n    // 步骤一: 等待校准完成。\n    await _reconcilePlaylistQueue(undefined);\n\n    // 步骤二: 在校准完成后，根据最新的内部状态来决定是否注入UI。\n    logProbe(`[Event-Text] 校准完成，尝试执行注入...`);\n    await _handleNewAssistantMessage(id);\n  });\n\n  // 监听用户编辑消息的逻辑保持不变，它已经遵循了正确的“校准后更新UI”的模式。\n  eventOn(tavern_events.MESSAGE_EDITED, async (id: number) => {\n    if (!isScriptActive) return;\n    logProbe(`[Event] 文本模式捕获到 MESSAGE_EDITED (id: ${id})，触发校准与UI补救...`);\n    await _reconcilePlaylistQueue(undefined);\n    await _ensureUiVisibility();\n  });\n\n  logProbe('[EventDispatcher] 文本模式监听器部署完毕。', 'groupEnd');\n}\n\n/**\n * [V9.1 核心处理器] 统一处理所有导致“运行时历史”变更的事件。\n * 职责：通知校准官进行全量状态同步。\n * @param eventName - 触发此处理器的事件名，用于日志记录。\n */\nasync function _handleHistoryChangeEvent(eventName: string, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  logProbe(`[HistoryChange] 检测到历史变更事件: ${eventName}。`);\n  if (!isCorePlayerInitialized) return;\n\n  if (triggers.length === 0) {\n    // 理论上 ParseConfig 阶段会为 Text 模式生成虚拟触发器，所以 triggers 不应为空。\n    // 但如果真的为空，说明没有任何音乐配置，直接跳过。\n    logProbe('[HistoryChange] (分流) 未检测到任何触发器配置，跳过校准。');\n    await _ensureUiVisibility();\n    return;\n  }\n\n  logProbe(`[HistoryChange] 正在委托校准官进行全量状态校准...`);\n\n  // 校准官内部会根据 isMvuMode 自动决定是查 MVU 还是查 TextTagManager。\n  await _reconcilePlaylistQueue(undefined, options);\n\n  await _ensureUiVisibility();\n}\n\n/**\n * 处理新AI消息渲染事件的专用处理器。\n * @param messageId - 由事件传来的消息ID。\n */\nasync function _handleNewAssistantMessage(messageId: number): Promise<void> {\n  logProbe(`[Injector] 收到 UI 注入请求，目标 message_id: ${messageId}`);\n\n  if (messageId === 0) {\n    logProbe(`[Injector] (探针) 操作中止：message_id 为 0 (开场白)，权限属于作者，无需注入。`);\n    return;\n  }\n\n  const topQueueItem = StateManager.getTopQueueItem();\n  if (!topQueueItem) {\n    logProbe(`[Injector] (守门员) 拒绝注入：当前播放队列为空。`);\n    return;\n  }\n\n  try {\n    const message = getChatMessages(messageId)?.[0];\n\n    if (message && message.role !== 'user' && !message.message.includes('<DarkBramblePlayer/>')) {\n      logProbe(`[Injector] (探针) 条件满足，立即为 message_id: ${messageId} 执行注入...`);\n\n      await setChatMessages([{ message_id: messageId, message: `${message.message}\\n<DarkBramblePlayer/>` }]);\n\n      logProbe(`[Injector] (探针) 注入成功。`);\n    } else {\n      logProbe(`[Injector] (探针) 操作跳过：消息是用户发送的，或已包含标签。Role: ${message?.role}`);\n    }\n  } catch (error) {\n    logProbe(`[Injector] 为 message_id: ${messageId} 注入标签时发生严重错误:`, 'error');\n    console.error(error);\n  }\n}\n\n/**\n * UI 可见性卫士。\n * 职责：在 MVU 延迟加载或消息删除后，确保如果音乐在播放，界面一定存在。\n * 原则：SSoT (以队列状态为准), 鲁棒性 (补救缺失的 UI)\n */\nasync function _ensureUiVisibility() {\n  logProbe('[UiGuard] 正在检查界面一致性 (高性能局部扫描)...', 'groupCollapsed');\n\n  const topQueueItem = StateManager.getTopQueueItem();\n  if (!topQueueItem) {\n    logProbe('[UiGuard] 队列为空，无需 UI。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    // [步骤 1] 获取最后一条消息，作为定位锚点\n    // 参数 -1 表示获取最新的楼层\n    const lastMsgList = getChatMessages(-1);\n\n    if (!lastMsgList || lastMsgList.length === 0) {\n      logProbe('[UiGuard] 无法获取最新楼层锚点，检查中止。', 'warn');\n      logProbe('', 'groupEnd');\n      return;\n    }\n\n    // [步骤 2] 计算最近 10 楼的 ID 范围\n    // 假设最后一条 ID 是 100，我们想要 91-100 (共10条)\n    const lastId = lastMsgList[0].message_id;\n    // 使用 Math.max 确保不会算出负数 ID\n    const startId = Math.max(0, lastId - 9);\n    const rangeString = `${startId}-${lastId}`;\n\n    logProbe(`[UiGuard] 正在获取最近的 10 条消息 (ID范围: ${rangeString})...`);\n\n    // [步骤 3] 仅拉取这 10 条数据\n    // 接口支持 \"StartID-EndID\" 格式的字符串\n    const recentMessages = getChatMessages(rangeString);\n\n    if (!recentMessages || recentMessages.length === 0) {\n      logProbe('[UiGuard] 局部消息拉取为空，检查中止。', 'warn');\n      logProbe('', 'groupEnd');\n      return;\n    }\n\n    let foundTarget = false;\n\n    // [步骤 4] 倒序扫描这 10 条数据\n    for (let i = recentMessages.length - 1; i >= 0; i--) {\n      const msg = recentMessages[i];\n\n      // 1. 跳过用户消息\n      if (msg.role === 'user') {\n        continue;\n      }\n\n      // 2. 遇到开场白停止 (尊重作者排版)\n      if (msg.message_id === 0) {\n        logProbe('[UiGuard] 回溯至开场白，停止。');\n        break;\n      }\n\n      // 3. 检查是否已有标签\n      if (msg.message && msg.message.includes('<DarkBramblePlayer/>')) {\n        logProbe(`[UiGuard] 在 message_id: ${msg.message_id} 处发现已有标签，状态正常。`);\n        foundTarget = true;\n        break;\n      }\n\n      // 4. 执行注入\n      logProbe(`[UiGuard] 发现目标宿主: message_id: ${msg.message_id} (${msg.role})，执行补救注入...`);\n      const newContent = `${msg.message}\\n<DarkBramblePlayer/>`;\n\n      await setChatMessages([\n        {\n          message_id: msg.message_id,\n          message: newContent,\n        },\n      ]);\n\n      logProbe('[UiGuard] 补救注入成功。');\n      foundTarget = true;\n      break;\n    }\n\n    if (!foundTarget) {\n      logProbe('[UiGuard] 在最近 10 条消息中未发现合适的注入点。');\n    }\n  } catch (error) {\n    logProbe(`[UiGuard] 执行补救注入时发生错误: ${error}`, 'error');\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * [V9.0 核心] 执行一次“软重置”。\n * 这将在不刷新整个页面的情况下，重新执行完整的初始化流程。\n * 用于响应“开场白滑动”等根本性的上下文变更。\n */\nasync function _executeSoftReset(options?: { autoPlayIfWasPlaying?: boolean }) {\n  logProbe('[SoftReset] 检测到根本性上下文变更，启动“软重置”协议...', 'warn');\n  try {\n    const config = await parseWorldbookConfig();\n\n    logProbe('[SoftReset] 正在为新的开场白查找权威MVU状态...');\n    const authoritativeState = await _findLatestAuthoritativeMvuState();\n\n    await initializePlayerForChat(config, authoritativeState, options);\n  } catch (error) {\n    logProbe('[SoftReset] 软重置过程中发生严重错误。', 'error');\n    console.error(error);\n  }\n}\n\n/**\n * [V9.9 原始数据卫士] (Raw Data Guard)\n * 职责 (Query): 直接穿透封装层，检查酒馆内存中指定消息的内容是否已就绪。\n * 这是区分 \"浏览历史\" (内容已存在) 和 \"触发生成\" (内容为空) 的唯一事实来源。\n */\nfunction _isSwipeContentReady(messageId: number): boolean {\n  // 1. 安全获取上下文\n  // [修复] 必须通过 window.parent 才能在 iframe 中访问到酒馆的真实数据\n  const context = (window.parent as any).SillyTavern?.getContext?.();\n\n  if (!context || !context.chat) {\n    // 极罕见情况：如果上下文不存在，为安全起见视为未就绪\n    return false;\n  }\n\n  // 2. 获取消息对象\n  const msg = context.chat[messageId];\n  if (!msg) return false;\n\n  // 3. 获取指针和数据槽\n  const pointer = msg.swipe_id;\n  const swipes = msg.swipes;\n\n  // 4. 核心判定：必须是字符串且长度大于0\n  if (Array.isArray(swipes) && typeof pointer === 'number') {\n    const content = swipes[pointer];\n    // 只有当内容是实实在在的字符串，且不是空串时，才视为历史记录\n    return typeof content === 'string' && content.length > 0;\n  }\n\n  return false;\n}\n\nfunction _registerContextualEventListeners() {\n  logProbe('[EventDispatcher] 正在注册“上下文专属”事件监听器...');\n\n  // [V9.6 修复] 移除 CHARACTER_MESSAGE_RENDERED 监听器。\n  // 它的主要问题是：当切换聊天时，酒馆会重新渲染历史消息，导致此事件被触发。\n  // 此时脚本内存中还是上一个聊天的状态，因此会错误地将播放器界面注入到新聊天中 (幽灵注入问题)。\n  // 我们将在后续阶段使用更精确的事件 (MESSAGE_RECEIVED) 来处理新消息。\n\n  eventOn(tavern_events.MESSAGE_DELETED, (deletedId: number) => {\n    if (!isScriptActive) return;\n    logProbe(`[EventAdapter] 捕获到删除事件 (原ID: ${deletedId})，正在通过“高级历史通道”触发全量校准...`);\n    void _handleHistoryChangeEvent('MESSAGE_DELETED');\n  });\n\n  eventOn(tavern_events.MESSAGE_SWIPED, (id: number) => {\n    if (!isScriptActive) return;\n\n    // 原始数据卫士 (Raw Data Guard)\n    // 目的: 区分 \"浏览历史Swipe\" 和 \"触发生成Swipe\"\n    // 原理: 直接检查内存。如果内容为空，说明是生成行为，必须拦截。\n    if (!_isSwipeContentReady(id)) {\n      logProbe(\n        `[Event-Swipe] (卫士) 拦截生效！检测到 message_id: ${id} 的内容尚未填充 (生成中/空内容)，忽略本次操作。`,\n        'warn',\n      );\n      return;\n    }\n\n    logProbe(`[Event] 捕获到滑动事件 (message_id: ${id})。卫士已放行 (内容已就绪)。`);\n    if (!isCorePlayerInitialized) return;\n\n    if (id === 0) {\n      logProbe('[Event-Swipe] 判断为开场白滑动，执行软重置...');\n      const wasPlaying = StateManager.isPlaying();\n      logProbe(`[Event-Swipe] (探针) 软重置前的播放状态: ${wasPlaying}`);\n      void _executeSoftReset({ autoPlayIfWasPlaying: wasPlaying });\n    } else {\n      logProbe('[Event-Swipe] 判断为历史消息滑动，执行历史变更处理...');\n      void _handleHistoryChangeEvent('MESSAGE_SWIPED', { transitionEffect: 'hard' });\n    }\n  });\n\n  logProbe('[EventDispatcher] “上下文专属”事件监听器注册完毕。');\n}\n\n/**\n * [原则: SRP] 这个函数的单一职责是：作为一个返回 Promise 的“观察哨”，\n * 它只负责“等待MVU创世完成”这一件事。成功则 resolve(true)，失败或超时则 resolve(false)。\n * 所有后续操作（如注册事件）都作为成功后的“副作用”在内部执行。\n */\nasync function _waitForMvuGenesis(): Promise<boolean> {\n  logProbe('【安全观察哨】已上岗，开始执行MVU就绪检查...', 'group');\n\n  try {\n    // [探针] 阶段一：等待 MVU 框架本身出现\n    await waitGlobalInitialized('Mvu');\n    logProbe('【观察哨】(探针) 阶段一成功：MVU 框架已加载。');\n  } catch (e) {\n    logProbe(`【观察哨】(探针) 阶段一失败: ${e}。`, 'warn');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段二：轮询观察，等待 MVU 将初始数据写入消息楼层\n  const WATCHER_TIMEOUT = 10000;\n  const WATCHER_INTERVAL = 250;\n  const startTime = Date.now();\n  let isGenesisComplete = false;\n\n  logProbe('【观察哨】(探针) 阶段二开始：正在严密监视 message_id: 0 的创世数据...');\n  while (Date.now() - startTime < WATCHER_TIMEOUT) {\n    try {\n      const mvuData: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n      if (mvuData && (mvuData.swipes_data || mvuData.stat_data)) {\n        logProbe('【观察哨】(探针) 阶段二成功：在消息楼层中确认到创世数据！');\n        isGenesisComplete = true;\n        break;\n      }\n    } catch (error) {\n      /* 在MVU启动初期，查询失败是正常现象，静默处理 */\n    }\n    await new Promise(resolve => setTimeout(resolve, WATCHER_INTERVAL));\n  }\n\n  if (!isGenesisComplete) {\n    logProbe('【观察哨】(探针) 阶段二失败：观察超时！', 'error');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段三：所有条件满足，执行激活序列\n  logProbe('【观察哨】(探针) 阶段三开始：执行MVU集成激活序列...');\n  try {\n    _registerMvuEventListeners();\n    isMvuIntegrationActive = true;\n    logProbe('【观察哨】(探针) 阶段三成功：MVU集成已完全激活。');\n    logProbe('【安全观察哨】任务成功完成！', 'groupEnd');\n    return true;\n  } catch (error) {\n    logProbe(`【观察哨】(探针) 阶段三失败：激活序列发生意外崩溃: ${error}`, 'error');\n    isMvuIntegrationActive = false;\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n}\n\n$(() => {\n  PlaybackEngine.initialize();\n  setupGlobalAPI();\n\n  eventOn(tavern_events.CHAT_CHANGED, () => {\n    logProbe(`[硬重置] CHAT_CHANGED 事件触发，检测到聊天上下文变更。即将执行“优雅停机”协议。`, 'warn');\n    executeHardReset();\n  });\n\n  const observerInterval = setInterval(() => {\n    void tryInitialize();\n    if (isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化成功，观察者已销毁。');\n    }\n  }, 250);\n\n  setTimeout(() => {\n    if (!isInitializedForThisChat) {\n      clearInterval(observerInterval);\n\n      // 这里使用和前端一模一样的中文文案，确保用户体验一致\n      const timeoutMsg = '后台脚本初始化超时。如果这是您第一次加载角色卡，请尝试刷新页面。';\n\n      logProbe(`【观察者模型】初始化超时！`, 'error');\n\n      _initializationResult = { success: false, error: timeoutMsg };\n\n      if (_initializationPromiseControls) {\n        _initializationPromiseControls.reject(timeoutMsg);\n        _initializationPromiseControls = null;\n      }\n    }\n  }, 10000);\n\n  $(window).on('pagehide', () => {\n    logProbe('PAGEHIDE 事件触发！', 'warn');\n\n    PlaybackEngine.getActivePlayer()?.pause();\n    logProbe('音频已暂停。');\n  });\n});\n"],"names":["z","performance","now","ZodTrackConfig","object","string","optional","url","message","strict","ZodSingleCondition","variable_path","greater_than","number","greater_than_or_equal_to","less_than","less_than_or_equal_to","value","union","boolean","value_contains","time_in_range","regex","ZodTriggerConfig","type","literal","playlist_id","priority","default","conditions","array","nonempty","ZodPlaylistConfig","id","onFinishRule","enum","tracks","ZodWorldbookConfig","default_playlist_id","playlists","triggers","is_mvu","ZodQueueItemState","playlistId","currentIndex","playedIndices","wasEverPlayed","triggerSource","ZodPersistedState","active_queue","mode","volume","min","max","last_active_swipe_id","nullable","finished_base_playlists","previousMvuState","record","any","STATE_KEY_MVU_HISTORY","_parseTimeToMinutes","timeStr","cleanStr","trim","replace","match","hours","parseInt","minutes","MvuManager","_previousMvuState","_checkTriggerCondition","trigger","statData","condition","currentValue","_","get","conditionMet","isHandled","undefined","includes","currentTimeInMinutes","startStr","endStr","split","startMinutes","endMinutes","checkTriggerCondition","initialize","savedState","getVariables","error","resetState","persistCurrentState","currentStateData","isScriptActive","cloneDeep","updateVariablesWith","vars","getPreviousState","calculateChangeReport","previousStateData","allTriggers","report","newlyActiveTriggers","newlyInactiveTriggers","wasMet","isMet","push","length","TextTagManager","SCENE_TAG_REGEX","getLatestState","async","latestMsgs","getChatMessages","tags","foundAtMessageId","lastId","message_id","rangeString","Math","msgs","i","msg","role","allMatches","matchAll","rawId","toLowerCase","normalizedId","StateManager","_activePlaylistQueue","_lastActiveSwipeId","_finishedBasePlaylists","Set","_playbackMode","_masterVolume","_playbackState","_isPerformingEffect","_applyDepartureIsHistoryPrinciple","item","departingIndex","add","getPlaybackMode","getVolume","isPlaying","getPlaybackState","isPerformingEffect","getTopQueueItem","getQueue","getStateSnapshotForRuntime","playbackState","getStateSnapshotForPersistence","map","omit","Array","from","clear","loadState","stateToLoad","size","setPlaybackMode","setVolume","setPlaybackState","newState","setPerformingEffect","isPerforming","getLastActiveSwipeId","setLastActiveSwipeId","getFinishedBasePlaylists","addToFinishedBasePlaylists","clearFinishedBasePlaylists","updateQueue","newQueue","sort","a","b","setCurrentIndex","index","currentItem","commitNavigationStep","newTrackIndex","playbackPlan","newPlanIndex","indexOf","planIndex","clearHistoryForCurrentItem","resetCurrentItemForLoop","commitGenesisState","newCurrentIndex","newPlaybackPlan","userInitiatedJump","trackIndex","this","clearRandomModePlan","applyNewPlaybackPlan","plan","PlaybackEngine","_playerA","_playerB","_activePlayer","_standbyPlayer","_fadeInterval","_fadeVolumeAsync","player","targetVolume","duration","Promise","resolve","clearInterval","startVolume","steps","volumeStep","currentStep","window","setInterval","createPlayer","audio","Audio","preload","crossOrigin","addEventListener","broadcastFullState","decision","StrategyManager","getCurrentStrategy","onTrackEnd","directive","_applyNavigationDecision","needsAsyncEffect","targetIndex","_executeTransition","_executeSelfHealingLoop","_releaseEffectLock","writeState","_handleTrackEnded","broadcastTimeUpdate","getActivePlayer","getStandbyPlayer","transitionToTrack","targetTrackUrl","slice","Error","standbyPlayer","activePlayer","src","load","reject","onCanPlay","removeEventListener","onError","e","target","pause","newActivePlayer","playPromise","play","fadeOutAndPause","executeHardCut","resumeAndFadeIn","ListStrategy","onQueueChanged","_currentItem","advance","direction","playlistContent","totalTracks","nextIndex","action","lastIndex","totalValidTracks","onPlaybackError","SingleStrategy","RandomStrategy","_generateIntelligentShuffle","allTrackIndices","sourceForShuffle","filter","has","j","floor","random","join","_generatePlaybackPlan","shuffledIndices","knownSequence","_handlePlanEnd","allIndices","shuffled","prepareGenesis","nextPlanIndex","targetTrackIndex","prevPlanIndex","_strategies","list","single","_currentStrategy","setMode","notifyQueueChanged","constructor","name","STATE_KEY","isInitializedForThisChat","isReconciling","_initializationResult","_initializationPromiseControls","_initializationPromise","allPlaylists","defaultPlaylistId","isMvuIntegrationActive","isCorePlayerInitialized","isMvuMode","_currentChatId","fullStateUpdateCallbacks","timeUpdateCallbacks","_reconcilePlaylistQueue","eventPayload","options","oldTopItem","stat_data","authState","_findLatestAuthoritativeMvuState","mvuData","textResult","changeReport","remove","some","inactiveTrigger","areTriggersFunctionallyEqual","baseItem","find","triggeredBy","currentBaseId","activeTrigger","newItem","createQueueItem","newTopItem","transitionEffect","_executeGenesisPlayInternal","track","currentPlaylist","payload","title","artist","cover","playbackMode","masterVolume","playlist","isTransitioning","forEach","callback","currentTime","source","dataToSave","_formatZodErrorForToastr","issue","issues","path","toastrMessage","toastr","timeOut","getCanonicalString","Object","keys","key","String","conditionsA","conditionsB","every","val","context","messageId","swipeId","mvuDataContainer","Mvu","getMvuData","swipeSpecificData","swipes_data","include_swipes","currentMessageId","parseWorldbookConfig","ConfigMissingError","super","aggregatedConfig","_defaultPlaylistIdSourceFile","explicitMvuMode","worldbookNames","getCharWorldbookNames","searchOrder","primary","additional","Boolean","foundAnyConfigEntry","bookName","configEntries","getWorldbook","entry","rawConfig","YAML","parse","content","validationResult","safeParse","success","data","p","_sourceFile","t","warningMsg","warning","closeButton","finalIsMvu","uniquePlaylistIds","pid","virtualTrigger","isGloballyValid","playlistsById","groupBy","errorMsg","allPlaylistIds","finalTriggers","playlistsAsMap","pl","normalizedTracks","decodeURIComponent","pop","defaultId","isMvu","reconstituteQueueItem","persistedItem","playlistConfig","Infinity","config","initializePlayerForChat","authoritativeState","savedData","readState","currentStatData","authoritativeMessageId","finalQueue","correctBasePlaylistId","msgZero","currentSwipeId","swipe_id","currentGreeting","swipes","tagMatch","tagPlaylistId","lastSwipeId","fatalErrorMsg","healedQueue","prototype","hasOwnProperty","call","currentTrigger","initialTopItem","autoPlayIfWasPlaying","_handleGenesisPlay","freshItem","targetTrack","nextTrack","prepareNextTrack","consecutiveFailures","currentItemForThreshold","threshold","errorDecision","nextError","nextTopItem","nextTrackTitle","itemToRemove","currentQueue","shift","genesisPlan","finalStartIndex","_handleNavigation","info","setupGlobalAPI","musicPlayerAPI","requestInitialization","togglePlayPause","playNext","playPrev","playIndex","currentMode","_handlePlayIndex","persistVolumeAndBroadcast","finalVolume","setLiveVolume","oldMode","seekTo","percentage","getCurrentState","c","x","onFullStateUpdate","splice","onTimeUpdate","initializeGlobal","tryInitialize","currentChatId","SillyTavern","getCurrentChatId","chat","isMvuCard","waitGlobalInitialized","WATCHER_TIMEOUT","WATCHER_INTERVAL","startTime","Date","isGenesisComplete","setTimeout","eventOn","events","VARIABLE_UPDATE_ENDED","_ensureUiVisibility","tavern_events","MESSAGE_RECEIVED","POLLING_INTERVAL","MAX_ATTEMPTS","_waitForMvuSentinel","_handleNewAssistantMessage","_waitForMvuGenesis","MESSAGE_EDITED","MESSAGE_DELETED","deletedId","_handleHistoryChangeEvent","MESSAGE_SWIPED","parent","getContext","pointer","isArray","_isSwipeContentReady","wasPlaying","_executeSoftReset","errorMessage","eventName","setChatMessages","lastMsgList","recentMessages","foundTarget","newContent","$","CHAT_CHANGED","reloadIframe","observerInterval","timeoutMsg","on"],"ignoreList":[],"sourceRoot":""}